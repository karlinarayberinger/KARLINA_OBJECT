<hr>
<p><strong>POLYGON</strong></p>
<hr>


<figure class="wp-block-image size-full"><img data-attachment-id="21602" data-permalink="https://karlinaobject.wordpress.com/polygon/polygon_inheritance_diagram-2/" data-orig-file="https://karlinaobject.wordpress.com/wp-content/uploads/2023/07/polygon_inheritance_diagram.png" data-orig-size="960,720" data-comments-opened="1" data-image-meta="{&quot;aperture&quot;:&quot;0&quot;,&quot;credit&quot;:&quot;&quot;,&quot;camera&quot;:&quot;&quot;,&quot;caption&quot;:&quot;&quot;,&quot;created_timestamp&quot;:&quot;0&quot;,&quot;copyright&quot;:&quot;&quot;,&quot;focal_length&quot;:&quot;0&quot;,&quot;iso&quot;:&quot;0&quot;,&quot;shutter_speed&quot;:&quot;0&quot;,&quot;title&quot;:&quot;&quot;,&quot;orientation&quot;:&quot;0&quot;}" data-image-title="polygon_inheritance_diagram" data-image-description="" data-image-caption="" data-medium-file="https://karlinaobject.wordpress.com/wp-content/uploads/2023/07/polygon_inheritance_diagram.png?w=300" data-large-file="https://karlinaobject.wordpress.com/wp-content/uploads/2023/07/polygon_inheritance_diagram.png?w=960" tabindex="0" role="button" width="960" height="720" src="https://karlinaobject.wordpress.com/wp-content/uploads/2023/07/polygon_inheritance_diagram.png" alt="" class="wp-image-21602" srcset="https://karlinaobject.wordpress.com/wp-content/uploads/2023/07/polygon_inheritance_diagram.png 960w, https://karlinaobject.wordpress.com/wp-content/uploads/2023/07/polygon_inheritance_diagram.png?w=150&amp;h=113 150w, https://karlinaobject.wordpress.com/wp-content/uploads/2023/07/polygon_inheritance_diagram.png?w=300&amp;h=225 300w, https://karlinaobject.wordpress.com/wp-content/uploads/2023/07/polygon_inheritance_diagram.png?w=768&amp;h=576 768w" sizes="(max-width: 960px) 100vw, 960px" /></figure>


<hr>
<p>image_link: <a style="background:#000000;color:#ff9000" href="https://raw.githubusercontent.com/karlinarayberinger/KARLINA_OBJECT_summer_2023_starter_pack/main/polygon_inheritance_diagram.png" target="_blank" rel="noopener">https://raw.githubusercontent.com/karlinarayberinger/KARLINA_OBJECT_summer_2023_starter_pack/main/polygon_inheritance_diagram.png</a></p>
<hr>


<figure class="wp-block-image size-full"><img data-attachment-id="21605" data-permalink="https://karlinaobject.wordpress.com/polygon/quadrilateral_image-2/" data-orig-file="https://karlinaobject.wordpress.com/wp-content/uploads/2023/07/quadrilateral_image.png" data-orig-size="960,720" data-comments-opened="1" data-image-meta="{&quot;aperture&quot;:&quot;0&quot;,&quot;credit&quot;:&quot;&quot;,&quot;camera&quot;:&quot;&quot;,&quot;caption&quot;:&quot;&quot;,&quot;created_timestamp&quot;:&quot;0&quot;,&quot;copyright&quot;:&quot;&quot;,&quot;focal_length&quot;:&quot;0&quot;,&quot;iso&quot;:&quot;0&quot;,&quot;shutter_speed&quot;:&quot;0&quot;,&quot;title&quot;:&quot;&quot;,&quot;orientation&quot;:&quot;0&quot;}" data-image-title="quadrilateral_image" data-image-description="" data-image-caption="" data-medium-file="https://karlinaobject.wordpress.com/wp-content/uploads/2023/07/quadrilateral_image.png?w=300" data-large-file="https://karlinaobject.wordpress.com/wp-content/uploads/2023/07/quadrilateral_image.png?w=960" tabindex="0" role="button" width="960" height="720" src="https://karlinaobject.wordpress.com/wp-content/uploads/2023/07/quadrilateral_image.png" alt="" class="wp-image-21605" srcset="https://karlinaobject.wordpress.com/wp-content/uploads/2023/07/quadrilateral_image.png 960w, https://karlinaobject.wordpress.com/wp-content/uploads/2023/07/quadrilateral_image.png?w=150&amp;h=113 150w, https://karlinaobject.wordpress.com/wp-content/uploads/2023/07/quadrilateral_image.png?w=300&amp;h=225 300w, https://karlinaobject.wordpress.com/wp-content/uploads/2023/07/quadrilateral_image.png?w=768&amp;h=576 768w" sizes="(max-width: 960px) 100vw, 960px" /></figure>


<hr>
<p>image_link: <a style="background:#000000;color:#ff9000" href="https://raw.githubusercontent.com/karlinarayberinger/KARLINA_OBJECT_summer_2023_starter_pack/main/quadrilateral_image.png" target="_blank" rel="noopener">https://raw.githubusercontent.com/karlinarayberinger/KARLINA_OBJECT_summer_2023_starter_pack/main/quadrilateral_image.png</a></p>
<hr>


<figure class="wp-block-image size-full"><img data-attachment-id="21581" data-permalink="https://karlinaobject.wordpress.com/triangle/triangle_image-2/" data-orig-file="https://karlinaobject.wordpress.com/wp-content/uploads/2023/07/triangle_image.png" data-orig-size="960,720" data-comments-opened="1" data-image-meta="{&quot;aperture&quot;:&quot;0&quot;,&quot;credit&quot;:&quot;&quot;,&quot;camera&quot;:&quot;&quot;,&quot;caption&quot;:&quot;&quot;,&quot;created_timestamp&quot;:&quot;0&quot;,&quot;copyright&quot;:&quot;&quot;,&quot;focal_length&quot;:&quot;0&quot;,&quot;iso&quot;:&quot;0&quot;,&quot;shutter_speed&quot;:&quot;0&quot;,&quot;title&quot;:&quot;&quot;,&quot;orientation&quot;:&quot;0&quot;}" data-image-title="triangle_image" data-image-description="" data-image-caption="" data-medium-file="https://karlinaobject.wordpress.com/wp-content/uploads/2023/07/triangle_image.png?w=300" data-large-file="https://karlinaobject.wordpress.com/wp-content/uploads/2023/07/triangle_image.png?w=960" tabindex="0" role="button" width="960" height="720" src="https://karlinaobject.wordpress.com/wp-content/uploads/2023/07/triangle_image.png" alt="" class="wp-image-21581" srcset="https://karlinaobject.wordpress.com/wp-content/uploads/2023/07/triangle_image.png 960w, https://karlinaobject.wordpress.com/wp-content/uploads/2023/07/triangle_image.png?w=150&amp;h=113 150w, https://karlinaobject.wordpress.com/wp-content/uploads/2023/07/triangle_image.png?w=300&amp;h=225 300w, https://karlinaobject.wordpress.com/wp-content/uploads/2023/07/triangle_image.png?w=768&amp;h=576 768w" sizes="(max-width: 960px) 100vw, 960px" /></figure>


<hr>
<p>image_link: <a style="background:#000000;color:#ff9000" href="https://raw.githubusercontent.com/karlinarayberinger/KARLINA_OBJECT_summer_2023_starter_pack/main/triangle_image.png" target="_blank" rel="noopener">https://raw.githubusercontent.com/karlinarayberinger/KARLINA_OBJECT_summer_2023_starter_pack/main/triangle_image.png</a></p>
<hr>


<figure class="wp-block-image size-full"><img data-attachment-id="21565" data-permalink="https://karlinaobject.wordpress.com/point/points_on_cartesian_grid-2/" data-orig-file="https://karlinaobject.wordpress.com/wp-content/uploads/2023/07/points_on_cartesian_grid.png" data-orig-size="960,720" data-comments-opened="1" data-image-meta="{&quot;aperture&quot;:&quot;0&quot;,&quot;credit&quot;:&quot;&quot;,&quot;camera&quot;:&quot;&quot;,&quot;caption&quot;:&quot;&quot;,&quot;created_timestamp&quot;:&quot;0&quot;,&quot;copyright&quot;:&quot;&quot;,&quot;focal_length&quot;:&quot;0&quot;,&quot;iso&quot;:&quot;0&quot;,&quot;shutter_speed&quot;:&quot;0&quot;,&quot;title&quot;:&quot;&quot;,&quot;orientation&quot;:&quot;0&quot;}" data-image-title="points_on_cartesian_grid" data-image-description="" data-image-caption="" data-medium-file="https://karlinaobject.wordpress.com/wp-content/uploads/2023/07/points_on_cartesian_grid.png?w=300" data-large-file="https://karlinaobject.wordpress.com/wp-content/uploads/2023/07/points_on_cartesian_grid.png?w=960" tabindex="0" role="button" loading="lazy" width="960" height="720" src="https://karlinaobject.wordpress.com/wp-content/uploads/2023/07/points_on_cartesian_grid.png" alt="" class="wp-image-21565" srcset="https://karlinaobject.wordpress.com/wp-content/uploads/2023/07/points_on_cartesian_grid.png 960w, https://karlinaobject.wordpress.com/wp-content/uploads/2023/07/points_on_cartesian_grid.png?w=150&amp;h=113 150w, https://karlinaobject.wordpress.com/wp-content/uploads/2023/07/points_on_cartesian_grid.png?w=300&amp;h=225 300w, https://karlinaobject.wordpress.com/wp-content/uploads/2023/07/points_on_cartesian_grid.png?w=768&amp;h=576 768w" sizes="(max-width: 960px) 100vw, 960px" /></figure>


<hr />
<p>image_link: <a style="background: #000000;color: #ff9000" href="https://raw.githubusercontent.com/karlinarayberinger/KARLINA_OBJECT_summer_2023_starter_pack/main/points_on_cartesian_grid.png" target="_blank" rel="noopener">https://raw.githubusercontent.com/karlinarayberinger/KARLINA_OBJECT_summer_2023_starter_pack/main/points_on_cartesian_grid.png</a></p>
<hr />
<p><span style="background: #ffff00">The <a style="background: #ff9000;color: #000000" href="https://en.wikipedia.org/wiki/C%2B%2B" target="_blank" rel="noopener">C++</a> program featured in this tutorial web page demonstrates the concept of Object Oriented Programming (<a style="background: #ff9000;color: #000000" href="https://en.wikipedia.org/wiki/Object-oriented_programming" target="_blank" rel="noopener">OOP</a>); especially the concept of <a style="background: #ff9000;color: #000000" href="https://en.wikipedia.org/wiki/Polymorphism_(computer_science)" target="_blank" rel="noopener">polymorphism</a> (i.e. implementing data types which inherit abstract attributes which can be made more concrete and specific).</span></p>
<p><span style="background: #ffff00">The program implements user defined data types for instantiating <strong>POLYGON</strong> type objects (and POLYGON is an <strong>abstract class</strong>) which are instances of either the POLYGON-derived non-abstract class named <strong>QUADRILATERAL</strong> or else the QUADRILATERAL-derived non-abstract class named <strong>TRAPEZOID</strong> or else the QUADRILATERAL-derived non-abstract class named <strong>RECTANGLE</strong> or else the RECTANGLE-derived non-abstract class named <strong>SQUARE</strong> or else the POLYGON-derived non-abstract class named <strong>TRILATERAL</strong> or else the TRILATERAL-derived non-abstract class named <strong>RIGHT_TRILATERAL</strong>.</span></p>
<p><span style="background: #ffff00">Each non-abstract POLYGON type object object represents either three or else four instances of the <a style="background: #000000;color: #00ff00" href="https://karlinaobject.wordpress.com/point/" target="_blank" rel="noopener">POINT</a> class such that each POINT instance represents a unique whole number coordinate pair and such that the polygon represented by the points whose coordinates are data members of the non-abstract POLYGON instance has a non-zero area and, if the polygon is an instance of TRILATERAL, the sum of the interior angles of that polygon is 180 degrees and, if the polygon is an instance of QUADRILATERAL, the sum of the interior angles of that polygon is 360 degrees.</span></p>
<p><span style="background: #ffff00">A non-abstract POLYGON object can execute various functions including the ability to compute the <a style="background: #ff9000;color: #000000" href="https://en.wikipedia.org/wiki/Area" target="_blank" rel="noopener">area</a> of the two-dimensional region whose boundaries are the line segments which connect the points which the POINT type variables of the non-abstract POLYGON object represent and the ability to compute the <a style="background: #ff9000;color: #000000" href="https://en.wikipedia.org/wiki/Perimeter" target="_blank" rel="noopener">perimeter</a> (i.e. length of the one-dimensional boundary of the two-dimensional area) which the non-abstract POLYGON object represents.</span></p>
<p><em>To view hidden text inside each of the preformatted text boxes below, scroll horizontally.</em></p>
<pre>class : object :: data_type : variable.</pre>
<hr />
<p><strong>SOFTWARE_APPLICATION_COMPONENTS</strong></p>
<hr />
<p>C++_header_file: <a style="background: #000000;color: #00ff00" href="https://raw.githubusercontent.com/karlinarayberinger/KARLINA_OBJECT_summer_2023_starter_pack/main/point.h" target="_blank" rel="noopener">https://raw.githubusercontent.com/karlinarayberinger/KARLINA_OBJECT_summer_2023_starter_pack/main/point.h</a></p>
<p>C++_source_file: <a style="background: #000000;color: #00ff00" href="https://raw.githubusercontent.com/karlinarayberinger/KARLINA_OBJECT_summer_2023_starter_pack/main/point.cpp" target="_blank" rel="noopener">https://raw.githubusercontent.com/karlinarayberinger/KARLINA_OBJECT_summer_2023_starter_pack/main/point.cpp</a></p>
<p>C++_header_file: <a style="background: #000000;color: #00ff00" href="https://raw.githubusercontent.com/karlinarayberinger/KARLINA_OBJECT_summer_2023_starter_pack/main/polygon.h" target="_blank" rel="noopener">https://raw.githubusercontent.com/karlinarayberinger/KARLINA_OBJECT_summer_2023_starter_pack/main/polygon.h</a></p>
<p>C++_source_file: <a style="background: #000000;color: #00ff00" href="https://raw.githubusercontent.com/karlinarayberinger/KARLINA_OBJECT_summer_2023_starter_pack/main/polygon.cpp" target="_blank" rel="noopener">https://raw.githubusercontent.com/karlinarayberinger/KARLINA_OBJECT_summer_2023_starter_pack/main/polygon.cpp</a></p>
<p>C++_header_file: <a style="background: #000000;color: #00ff00" href="https://raw.githubusercontent.com/karlinarayberinger/KARLINA_OBJECT_summer_2023_starter_pack/main/quadrilateral.h" target="_blank" rel="noopener">https://raw.githubusercontent.com/karlinarayberinger/KARLINA_OBJECT_summer_2023_starter_pack/main/quadrilateral.h</a></p>
<p>C++_source_file: <a style="background: #000000;color: #00ff00" href="https://raw.githubusercontent.com/karlinarayberinger/KARLINA_OBJECT_summer_2023_starter_pack/main/quadrilateral.cpp" target="_blank" rel="noopener">https://raw.githubusercontent.com/karlinarayberinger/KARLINA_OBJECT_summer_2023_starter_pack/main/quadrilateral.cpp</a></p>
<p>C++_header_file: <a style="background: #000000;color: #00ff00" href="https://raw.githubusercontent.com/karlinarayberinger/KARLINA_OBJECT_summer_2023_starter_pack/main/trapezoid.h" target="_blank" rel="noopener">https://raw.githubusercontent.com/karlinarayberinger/KARLINA_OBJECT_summer_2023_starter_pack/main/trapezoid.h</a></p>
<p>C++_source_file: <a style="background: #000000;color: #00ff00" href="https://raw.githubusercontent.com/karlinarayberinger/KARLINA_OBJECT_summer_2023_starter_pack/main/trapezoid.cpp" target="_blank" rel="noopener">https://raw.githubusercontent.com/karlinarayberinger/KARLINA_OBJECT_summer_2023_starter_pack/main/trapezoid.cpp</a></p>
<p>C++_header_file: <a style="background: #000000;color: #00ff00" href="https://raw.githubusercontent.com/karlinarayberinger/KARLINA_OBJECT_summer_2023_starter_pack/main/rectangle.h" target="_blank" rel="noopener">https://raw.githubusercontent.com/karlinarayberinger/KARLINA_OBJECT_summer_2023_starter_pack/main/rectangle.h</a></p>
<p>C++_source_file: <a style="background: #000000;color: #00ff00" href="https://raw.githubusercontent.com/karlinarayberinger/KARLINA_OBJECT_summer_2023_starter_pack/main/rectangle.cpp" target="_blank" rel="noopener">https://raw.githubusercontent.com/karlinarayberinger/KARLINA_OBJECT_summer_2023_starter_pack/main/rectangle.cpp</a></p>
<p>C++_header_file: <a style="background: #000000;color: #00ff00" href="https://raw.githubusercontent.com/karlinarayberinger/KARLINA_OBJECT_summer_2023_starter_pack/main/square.h" target="_blank" rel="noopener">https://raw.githubusercontent.com/karlinarayberinger/KARLINA_OBJECT_summer_2023_starter_pack/main/square.h</a></p>
<p>C++_source_file: <a style="background: #000000;color: #00ff00" href="https://raw.githubusercontent.com/karlinarayberinger/KARLINA_OBJECT_summer_2023_starter_pack/main/square.cpp" target="_blank" rel="noopener">https://raw.githubusercontent.com/karlinarayberinger/KARLINA_OBJECT_summer_2023_starter_pack/main/square.cpp</a></p>
<p>C++_header_file: <a style="background: #000000;color: #00ff00" href="https://raw.githubusercontent.com/karlinarayberinger/KARLINA_OBJECT_summer_2023_starter_pack/main/trilateral.h" target="_blank" rel="noopener">https://raw.githubusercontent.com/karlinarayberinger/KARLINA_OBJECT_summer_2023_starter_pack/main/trilateral.h</a></p>
<p>C++_source_file: <a style="background: #000000;color: #00ff00" href="https://raw.githubusercontent.com/karlinarayberinger/KARLINA_OBJECT_summer_2023_starter_pack/main/trilateral.cpp" target="_blank" rel="noopener">https://raw.githubusercontent.com/karlinarayberinger/KARLINA_OBJECT_summer_2023_starter_pack/main/trilateral.cpp</a></p>
<p>C++_header_file: <a style="background: #000000;color: #00ff00" href="https://raw.githubusercontent.com/karlinarayberinger/KARLINA_OBJECT_summer_2023_starter_pack/main/right_trilateral.h" target="_blank" rel="noopener">https://raw.githubusercontent.com/karlinarayberinger/KARLINA_OBJECT_summer_2023_starter_pack/main/right_trilateral.h</a></p>
<p>C++_source_file: <a style="background: #000000;color: #00ff00" href="https://raw.githubusercontent.com/karlinarayberinger/KARLINA_OBJECT_summer_2023_starter_pack/main/right_trilateral.cpp" target="_blank" rel="noopener">https://raw.githubusercontent.com/karlinarayberinger/KARLINA_OBJECT_summer_2023_starter_pack/main/right_trilateral.cpp</a></p>
<p>C++_source_file: <a style="background: #000000;color: #00ff00" href="https://raw.githubusercontent.com/karlinarayberinger/KARLINA_OBJECT_summer_2023_starter_pack/main/polygon_class_inheritance_tester.cpp" target="_blank" rel="noopener">https://raw.githubusercontent.com/karlinarayberinger/KARLINA_OBJECT_summer_2023_starter_pack/main/polygon_class_inheritance_tester.cpp</a></p>
<p>plain-text_file: <a style="background: #000000;color: #ff9000" href="https://raw.githubusercontent.com/karlinarayberinger/KARLINA_OBJECT_summer_2023_starter_pack/main/polygon_class_inheritance_tester_output.txt" target="_blank" rel="noopener">https://raw.githubusercontent.com/karlinarayberinger/KARLINA_OBJECT_summer_2023_starter_pack/main/polygon_class_inheritance_tester_output.txt</a></p>
<hr />
<p><strong>PROGRAM_COMPILATION_AND_EXECUTION</strong></p>
<hr />
<p>STEP_0: Copy and paste the C++ code from the files named <a style="background: #000000;color: #00ff00" href="https://raw.githubusercontent.com/karlinarayberinger/KARLINA_OBJECT_summer_2023_starter_pack/main/point.h" target="_blank" rel="noopener">point.h</a>, <a style="background: #000000;color: #00ff00" href="https://raw.githubusercontent.com/karlinarayberinger/KARLINA_OBJECT_summer_2023_starter_pack/main/point.cpp" target="_blank" rel="noopener">point.cpp</a>, <a style="background: #000000;color: #00ff00" href="https://raw.githubusercontent.com/karlinarayberinger/KARLINA_OBJECT_summer_2023_starter_pack/main/polygon.h" target="_blank" rel="noopener">polygon.h</a>, <a style="background: #000000;color: #00ff00" href="https://raw.githubusercontent.com/karlinarayberinger/KARLINA_OBJECT_summer_2023_starter_pack/main/polygon.cpp" target="_blank" rel="noopener">polygon.cpp</a>, <a style="background: #000000;color: #00ff00" href="https://raw.githubusercontent.com/karlinarayberinger/KARLINA_OBJECT_summer_2023_starter_pack/main/quadrilateral.h" target="_blank" rel="noopener">quadrilateral.h</a>, <a style="background: #000000;color: #00ff00" href="https://raw.githubusercontent.com/karlinarayberinger/KARLINA_OBJECT_summer_2023_starter_pack/main/quadrilateral.cpp" target="_blank" rel="noopener">quadrilateral.cpp</a>, <a style="background: #000000;color: #00ff00" href="https://raw.githubusercontent.com/karlinarayberinger/KARLINA_OBJECT_summer_2023_starter_pack/main/trapezoid.h" target="_blank" rel="noopener">trapezoid.h</a>, <a style="background: #000000;color: #00ff00" href="https://raw.githubusercontent.com/karlinarayberinger/KARLINA_OBJECT_summer_2023_starter_pack/main/trapezoid.cpp" target="_blank" rel="noopener">trapezoid.cpp</a>, <a style="background: #000000;color: #00ff00" href="https://raw.githubusercontent.com/karlinarayberinger/KARLINA_OBJECT_summer_2023_starter_pack/main/rectangle.h" target="_blank" rel="noopener">rectangle.h</a>, <a style="background: #000000;color: #00ff00" href="https://raw.githubusercontent.com/karlinarayberinger/KARLINA_OBJECT_summer_2023_starter_pack/main/rectangle.cpp" target="_blank" rel="noopener">rectangle.cpp</a>, <a style="background: #000000;color: #00ff00" href="https://raw.githubusercontent.com/karlinarayberinger/KARLINA_OBJECT_summer_2023_starter_pack/main/square.h" target="_blank" rel="noopener">square.h</a>, <a style="background: #000000;color: #00ff00" href="https://raw.githubusercontent.com/karlinarayberinger/KARLINA_OBJECT_summer_2023_starter_pack/main/square.cpp" target="_blank" rel="noopener">square.cpp</a>, <a style="background: #000000;color: #00ff00" href="https://raw.githubusercontent.com/karlinarayberinger/KARLINA_OBJECT_summer_2023_starter_pack/main/trilateral.h" target="_blank" rel="noopener">trilateral.h</a>, <a style="background: #000000;color: #00ff00" href="https://raw.githubusercontent.com/karlinarayberinger/KARLINA_OBJECT_summer_2023_starter_pack/main/trilateral.cpp" target="_blank" rel="noopener">trilateral.cpp</a>, <a style="background: #000000;color: #00ff00" href="https://raw.githubusercontent.com/karlinarayberinger/KARLINA_OBJECT_summer_2023_starter_pack/main/right_trilateral.h" target="_blank" rel="noopener">right_trilateral.h</a>, <a style="background: #000000;color: #00ff00" href="https://raw.githubusercontent.com/karlinarayberinger/KARLINA_OBJECT_summer_2023_starter_pack/main/right_trilateral.cpp" target="_blank" rel="noopener">right_trilateral.cpp</a>, and <a style="background: #000000;color: #00ff00" href="https://raw.githubusercontent.com/karlinarayberinger/KARLINA_OBJECT_summer_2023_starter_pack/main/polygon_class_inheritance_tester.cpp" target="_blank" rel="noopener">polygon_class_inheritance_tester.cpp</a> into their own new text editor documents and save those documents using their corresponding file names:</p>
<pre>point.h</pre>
<pre>point.cpp</pre>
<pre>polygon.h</pre>
<pre>polygon.cpp</pre>
<pre>quadrilateral.h</pre>
<pre>quadrilateral.cpp</pre>
<pre>trapezoid.h</pre>
<pre>trapezoid.cpp</pre>
<pre>rectangle.h</pre>
<pre>rectangle.cpp</pre>
<pre>square.h</pre>
<pre>square.cpp</pre>
<pre>trilateral.h</pre>
<pre>trilateral.cpp</pre>
<pre>right_trilateral.h</pre>
<pre>right_trilateral.cpp</pre>
<pre>polygon_class_inheritance_tester.cpp</pre>
<p>STEP_1: Open a <a style="background: #ff9000;color: #000000" href="https://en.wikipedia.org/wiki/Unix" target="_blank" rel="noopener">Unix</a> command line terminal application and set the current directory to wherever the C++ is located on the local machine (e.g. Desktop).</p>
<pre>cd Desktop</pre>
<p>STEP_2: Compile the C++ file into machine-executable instructions (i.e. object file) and then into an executable piece of software named <strong>app</strong> using the following command:</p>
<pre>g++ polygon_class_inherintance_tester.cpp right_trilateral.cpp trilateral.cpp square.cpp rectangle.cpp trapezoid.cpp quadrilateral.cpp polygon.cpp point.cpp -o app</pre>
<p>STEP_3: If the program compilation command does not work, then use the following commands (in top-down order) to install the C/C++ compiler (which is part of the <a style="background: #ff9000;color: #000000" href="https://en.wikipedia.org/wiki/GNU_Compiler_Collection" target="_blank" rel="noopener">GNU Compiler Collection (GCC)</a>):</p>
<pre>sudo apt install build-essential</pre>
<pre>sudo apt-get install g++</pre>
<p>STEP_4: After running the <strong>g++</strong> command, run the executable file using the following command:</p>
<pre>./app</pre>
<p>STEP_5: Observe program results on the command line terminal and in the <a style="background: #000000;color: #ff9000" href="https://raw.githubusercontent.com/karlinarayberinger/KARLINA_OBJECT_summer_2023_starter_pack/main/polygon_class_inheritance_tester_output.txt" target="_blank" rel="noopener">output file</a>.</p>
<hr />
<p><strong>POINT_CLASS_HEADER</strong></p>
<hr />
<p>The following header file contains the preprocessing directives and function prototypes of the POINT class.</p>
<p><em>When copy-pasting the source code from the preformatted text box below into a text editor document, remove the spaces between the angle brackets and the library names in the preprocessing directives code block. (The spaces were inserted between the library names and angle brackets in the preformatted text box below in order to prevent the WordPress server from misinterpreting those C++ library references as <a style="background: #ff9000;color: #000000" href="https://en.wikipedia.org/wiki/HTML" target="_blank" rel="noopener">HTML</a> tags in the source code of this web page).</em></p>
<p>C++_header_file: <a style="background: #000000;color: #00ff00" href="https://raw.githubusercontent.com/karlinarayberinger/KARLINA_OBJECT_summer_2023_starter_pack/main/point.h" target="_blank" rel="noopener">https://raw.githubusercontent.com/karlinarayberinger/KARLINA_OBJECT_summer_2023_starter_pack/main/point.h</a></p>
<hr />
<pre>/**
 * file: point.h
 * type: C++ (header file)
 * author: karbytes
 * date: 07_JULY_2023
 * license: PUBLIC_DOMAIN
 */

/* preprocessing directives */
#ifndef POINT_H // If point.h has not already been linked to a source file (.cpp), 
#define POINT_H // then link this header file to the source file(s) which include this header file.

/* preprocessing directives */
#include &lt; iostream &gt; // library for defining objects which handle command line input and command line output
#include &lt; fstream &gt; // library for defining objects which handle file input and file output
#include &lt; cmath &gt; // library which defines various math functions such as square root (sqrt()) and sine (sin())
#include &lt; string &gt; // library which defines a sequence of text characters (i.e. char type values) as a string type variable
#define MINIMUM_X -999 // constant which represents minimum X value
#define MAXIMUM_X 999 // constant which represents maximum X value
#define MINIMUM_Y -999 // constant which represents minimum Y value
#define MAXIMUM_Y 999 // constant which represents maximum Y value
#define PI 3.14159 // constant which represents the approximate value of a circle's circumference divided by that circle's diameter

/**
 * Define a class which is used to instantiate POINT type objects.
 * 
 * (An object is a variable whose data type is user defined rather than native to the C++ programming language).
 * 
 * A POINT object represents a whole number coordinate pair in the form (X,Y).
 * 
 * X represents a specific whole number position along the x-axis (i.e. horizontal dimension) of a two-dimensional Cartesian grid.
 * Y represents a specific whole number position along the y-axis (i.e. vertical dimension) of the same two-dimensional Cartesian grid.
 * 
 * X stores one integer value at a time which is no smaller than MINIMUM_X and which is no larger than MAXIMUM_X.
 * Y stores one integer value at a time which is no smaller than MINIMUM_Y and which is no larger than MAXIMUM_Y.
 */
class POINT
{
private:
    int X, Y; // data attributes
public:
    POINT(); // default constructor
    POINT(int X, int Y); // normal constructor
    POINT(const POINT &amp; point); // copy constructor
    int get_X(); // getter method
    int get_Y(); // getter method
    bool set_X(int X); // setter method
    bool set_Y(int Y); // setter method
    double get_distance_from(POINT &amp; point); // getter method
    double get_slope_of_line_to(POINT &amp; point); // getter method
    void print(std::ostream &amp; output = std::cout); // descriptor method
    friend std::ostream &amp; operator &lt;&lt; (std::ostream &amp; output, POINT &amp; point); // descriptor method
    ~POINT(); // destructor
};

/* preprocessing directives */
#endif // Terminate the conditional preprocessing directives code block in this header file.
</pre>
<hr />
<p><strong>POINT_CLASS_SOURCE_CODE</strong></p>
<hr />
<p>The following source code defines the functions of the POINT class.</p>
<p>C++_source_file: <a style="background: #000000;color: #00ff00" href="https://raw.githubusercontent.com/karlinarayberinger/KARLINA_OBJECT_summer_2023_starter_pack/main/point.cpp" target="_blank" rel="noopener">https://raw.githubusercontent.com/karlinarayberinger/KARLINA_OBJECT_summer_2023_starter_pack/main/point.cpp</a></p>
<hr />
<pre>/**
 * file: point.cpp
 * type: C++ (source file)
 * date: 07_JULY_2023
 * author: karbytes
 * license: PUBLIC_DOMAIN 
 */

/* preprocessing directives */
#include "point.h" // Include the C++ header file which contains preprocessing directives, variable declarations, and function prototypes for the POINT class.

/**
 * The default constructor method of the POINT class 
 * instantiates POINT type objects 
 * whose X value is initially set to 0 and 
 * whose Y value is initially set to 0.
 * 
 * The default constructor method of the POINT class is invoked 
 * when a POINT type variable is declared as follows:
 * 
 * // variable declaration example one
 * POINT point_0; 
 * 
 * // variable declaration example two
 * POINT point_1 = POINT();
 */
POINT::POINT()
{
    std::cout &lt;&lt; "\n\nCreating the POINT type object whose memory address is " &lt;&lt; this &lt;&lt; "...";
    X = 0;
    Y = 0;
}

/**
 * The normal constructor method of the POINT class 
 * instantiates POINT type objects 
 * whose X value is set to the leftmost function input value (if that input value is no smaller than MINIMUM_X and no larger than MAXIMUM_X) and 
 * whose Y value is set to the rightmost function input value (if that input value is no smaller than MINIMUM_Y and no larger than MAXIMUM_Y).
 * 
 * If a function input value is out of its specified range, then set the corresponding int type property of this to 0.
 * 
 * (The keyword this refers to the POINT object which is returned by this function).
 *
 * The normal constructor method of the POINT class is invoked when a POINT type variable is declared as follows:
 * 
 * // variable definition example one
 * POINT point_0 = POINT(-55,84);
 * 
 * // variable definition example two
 * POINT point_1 = POINT(3,-4);
 * 
 * // variable definition example three
 * POINT point_2 = POINT(-1000, 999); // point_2 = POINT(0,999).
 * 
 * // variable definition example four
 * POINT point_3 = POINT(1000,-999); // point_3 = POINT(0,-999).
 * 
 * // variable definition example five
 * POINT point_4 = POINT(999,-1000); // point_4 = POINT(999,0).
 * 
 * // variable definition example six
 * POINT point_5 = POINT(-999,1000); // point_5 = POINT(-999,0).
 */
POINT::POINT(int X, int Y)
{
    std::cout &lt;&lt; "\n\nCreating the POINT type object whose memory address is " &lt;&lt; this &lt;&lt; "...";
    this -&gt; X = ((X &lt; MINIMUM_X) || (X &gt; MAXIMUM_X)) ? 0 : X; // Set the X property of the POINT instance being created to 0 if the function input X value is out of range.
    this -&gt; Y = ((Y &lt; MINIMUM_Y) || (Y &gt; MAXIMUM_Y)) ? 0 : Y; // Set the Y property of the POINT instance being created to 0 if the function input Y value is out of range.
}

/**
 * The copy constructor method of the POINT class 
 * instantiates POINT type objects 
 * whose X value is set to the X value of the input POINT object and 
 * whose Y value is set to the Y value of the input POINT object.
 *
 * The copy constructor method of the POINT class is invoked when a POINT type variable is declared as follows:
 * 
 * // variable definition example one
 * POINT point_0 = POINT(33,55);
 * POINT point_1 = POINT(point_0); // point_1 = POINT(33,55).
 * 
 * // variable definition example two
 * POINT point_2 = POINT(point_1); // point_2 = POINT(33,55).
 */
POINT::POINT(const POINT &amp; point) 
{
    std::cout &lt;&lt; "\n\nCreating the POINT type object whose memory address is " &lt;&lt; this &lt;&lt; "...";
    X = point.X;
    Y = point.Y;
}

/**
 * The getter method of the POINT class returns the value of the caller POINT object's X property.
 * 
 * X is an int type variable which stores exactly one integer value at a time which is no smaller than MINIMUM_X and which is no larger than MAXIMUM_X.
 * 
 * X represents a specific whole number position along the x-axis (i.e. horizontal dimension) of a two-dimensional Cartesian grid.
 */
int POINT::get_X()
{
    return X;
}

/**
 * The getter method of the POINT class returns the value of the caller POINT object's Y property.
 * 
 * Y is an int type variable which stores exactly one integer value at a time which is no smaller than MINIMUM_Y and which is no larger than MAXIMUM_Y.
 * 
 * Y represents a specific whole number position along the y-axis (i.e. vertical dimension) of a two-dimensional Cartesian grid.
 */
int POINT::get_Y()
{
    return Y;
}

/**
 * The setter method of the POINT class sets the POINT object's X property to the function input value 
 * if that value is no smaller than MINIMUM_X and which is no larger than MAXIMUM_X.
 * 
 * If the input value is in range, then return true. 
 * Otherwise, do not change the caller POINT object's X value and return false.
 * 
 * (The keyword this refers to the POINT object which calls this function).
 * 
 * (X represents a specific whole number position along the x-axis (i.e. horizontal dimension) of a two-dimensional Cartesian grid).
 */
bool POINT::set_X(int X)
{
    if ((X &gt;= MINIMUM_X) &amp;&amp; (X &lt;= MAXIMUM_X)) 
    {
        this -&gt; X = X;
        return true;
    }
    return false;
}

/**
 * The setter method of the POINT class sets the POINT object's Y property to the function input value 
 * if that value is no smaller than MINIMUM_Y and which is no larger than MAXIMUM_Y.
 * 
 * If the input value is in range, then return true. 
 * Otherwise, do not change the caller POINT object's Y value and return false.
 * 
 * (The keyword this refers to the POINT object which calls this function).
 * 
 * (Y represents a specific whole number position along the y-axis (i.e. vertical dimension) of a two-dimensional Cartesian grid).
 */
bool POINT::set_Y(int Y)
{
    if ((Y &gt;= MINIMUM_Y) &amp;&amp; (Y &lt;= MAXIMUM_Y)) 
    {
        this -&gt; Y = Y;
        return true;
    }
    return false;
}

/**
 * The getter method of the POINT class returns the length of the shortest path 
 * between the two-dimensional point represented by the the caller POINT object (i.e. this) 
 * and the two-dimensional point represented by the input POINT object (i.e. point).
 * 
 * Use the Pythagorean Theorem to compute the length of a right triangle's hypotenuse 
 * such that the two end points of that hypotenuse are represented by this and point.
 * 
 * (A hypotenuse is the only side of a right triangle which does not form a right angle 
 * with any other side of that triangle).
 * 
 * (A hypotenuse is the longest side of a triangle (and a triangle is a three-sided polygon 
 * in which three unique line segments connect three unique points)).
 * 
 * // c is the length of a right triangle's hypotenuse.
 * // a is the length of that right triangle's horizontal leg.
 * // b is the length of that triangle's vertical leg.
 * (c * c) = (a * a) + (b * b). 
 * 
 * // sqrt() is a native C++ function defined in the cmath library.
 * c = square_root( (a * a) + (b * b)). 
 */
double POINT::get_distance_from(POINT &amp; point)
{
    int horizontal_difference = 0.0, vertical_difference = 0.0;
    horizontal_difference = X - point.X; // a
    vertical_difference = Y - point.Y; // b
    return sqrt((horizontal_difference * horizontal_difference) + (vertical_difference * vertical_difference)); // c
}

/**
 * The getter method of the POINT class returns the slope of the line which intersects 
 * the two-dimensional point represented by the caller POINT instance (i.e. this)
 * and the two-dimensional point represented by the input POINT instance (i.e. point).
 * 
 * // y := f(x), 
 * // b := f(0), 
 * // f is a function whose input is an x-axis position and whose output is a y-axis position.
 * y := mx + b.
 * 
 * // m is a constant which represents the rate at which y changes in relation to x changing.
 * m := (y - b) / x. 
 * 
 * // m represents the difference of the two y-values divided by the difference of the two x-values.
 * m := (point.Y - this.Y) / (point.X - this.X).
 */
double POINT::get_slope_of_line_to(POINT &amp; point)
{
    double vertical_difference = 0.0, horizontal_difference = 0.0, result = 0.0;
    vertical_difference = point.Y - Y;
    horizontal_difference = point.X - X;
    result = vertical_difference / horizontal_difference;
    if (result == -0) result = 0; // Signed zeros sometimes occur inside of C++ program runtime instances.
    return result;
}

/**
 * The print method of the POINT class prints a description of the caller POINT object to the output stream.
 * 
 * Note that the default value of the function input parameter is the standard command line output stream (std::cout).
 * 
 * The default parameter is defined in the POINT class header file (i.e. point.h) and not in the POINT class source file (i.e. point.cpp).
 */
void POINT::print(std::ostream &amp; output)
{
    output &lt;&lt; "\n\n--------------------------------------------------------------------------------------------------";
    output &lt;&lt; "\nthis = " &lt;&lt; this &lt;&lt; ". // The keyword named this is a pointer which stores the memory address of the first memory cell of a POINT sized chunk of contiguous memory cells which are allocated to the caller POINT object.";
    output &lt;&lt; "\n&amp;X = " &lt;&lt; &amp;X &lt;&lt; ". // The reference operation returns the memory address of the first memory cell of an int sized chunk of contiguous memory cells which are allocated to the caller POINT data attribute named X.";
    output &lt;&lt; "\n&amp;Y = " &lt;&lt; &amp;Y &lt;&lt; ". // The reference operation returns the memory address of the first memory cell of an int sized chunk of contiguous memory cells which are allocated to the caller POINT data attribute named Y.";    
    output &lt;&lt; "\nsizeof(int) = " &lt;&lt; sizeof(int) &lt;&lt; ". // The sizeof() operation returns the number of bytes of memory which an int type variable occupies. (Each memory cell has a data capacity of 1 byte).";
    output &lt;&lt; "\nsizeof(POINT) = " &lt;&lt; sizeof(POINT) &lt;&lt; ". // The sizeof() operation returns the number of bytes of memory which a POINT type object occupies. (Each memory cell has a data capacity of 1 byte).";
    output &lt;&lt; "\nX = " &lt;&lt; X &lt;&lt; ". // X stores one int type value at a time which represents the horizontal position of a two-dimensional point plotted on a Cartesian grid.";
    output &lt;&lt; "\nY = " &lt;&lt; Y &lt;&lt; ". // Y stores one int type value at a time which represents the vertical position of a two-dimensional point plotted on a Cartesian grid.";
    output &lt;&lt; "\n--------------------------------------------------------------------------------------------------";
}

/**
 * The friend function is an alternative to the print method.
 * The friend function overloads the ostream operator (&lt;&lt;).
 * 
 * (Overloading an operator is assigning a different function to a native operator other than the function which that operator is used to represent by default).
 * 
 * Note that the default value of the leftmost function input parameter is the standard command line output stream (std::cout).
 * The default parameter is defined in the POINT class header file (i.e. point.h).
 * 
 * The friend function is not a member of the POINT class, 
 * but the friend function has access to the private and protected members 
 * of the POINT class and not just to the public members of the POINT class.
 * 
 * The friend keyword only prefaces the function prototype of this function 
 * (and the prototype of this function is declared in the POINT class header file (i.e. point.h)). 
 * 
 * The friend keyword does not preface the definition of this function
 * (and the definition of this function is specified in the POINT class source file (i.e. point.cpp)).
 * 
 * // overloaded print function example one
 * POINT point_0;
 * std::cout &lt;&lt; point_0; // identical to point_0.print();
 * 
 * // overloaded print function example two
 * std::ofstream file;
 * POINT point_1;
 * file &lt;&lt; point_1; // identical to point_1.print(file);
 */
std::ostream &amp; operator &lt;&lt; (std::ostream &amp; output, POINT &amp; point)
{
    point.print(output);
    return output;
}

/**
 * The destructor method of the POINT class de-allocates memory which was used to 
 * instantiate the POINT object which is calling this function.
 * 
 * The destructor method of the POINT class is automatically called when 
 * the program scope in which the caller POINT object was instantiated terminates.
 */
POINT::~POINT()
{
    std::cout &lt;&lt; "\n\nDeleting the POINT type object whose memory address is " &lt;&lt; this &lt;&lt; "...";
}
</pre>
<hr />
<p><strong>POLYGON_CLASS_HEADER</strong></p>
<hr />
<p>The following header file contains the preprocessing directives and function prototypes of the POLYGON class.</p>
<p>C++_header_file: <a style="background: #000000;color: #00ff00" href="https://raw.githubusercontent.com/karlinarayberinger/KARLINA_OBJECT_summer_2023_starter_pack/main/polygon.h" target="_blank" rel="noopener">https://raw.githubusercontent.com/karlinarayberinger/KARLINA_OBJECT_summer_2023_starter_pack/main/polygon.h</a></p>
<hr />
<pre>/**
 * file: polygon.h
 * type: C++ (header file)
 * date: 07_JULY_2023
 * author: karbytes
 * license: PUBLIC_DOMAIN
 */

// If polygon.h has not already been linked to a source file (.cpp), then link this header file to the source file(s) which include this header file.
#ifndef POLYGON_H 
#define POLYGON_H

// Include the C++ header file which contains preprocessing directives, variable declarations, and function prototypes for the POINT class.
#include "point.h" 

/**
 * POLYGON is an abstract class whose members are the essential components of objects 
 * whose classes are TRILATERAL, RIGHT_TRILATERAL, QUADRILATERAL, TRAPEZOID, RECTANGLE, and SQUARE.
 * 
 * (An abstract class has at least one virtual function).
 * 
 * The POLYGON class includes the POINT class via composition and not via inheritance.
 * 
 * Class members which are set to the protected access specifier
 * are accessible to the base class and to derived classes.
 * 
 * Class members which are set to the private access specifier
 * are only accessible to the base class.
 * 
 * Class members which are set to the public access specifier
 * are accessible to any scope within the program where
 * the base class and its derived classes are implemented.
 */
class POLYGON
{
protected:
    
    /**
     * category is a description of the POLYGON instance.
     * category is set to a constant (i.e. immutable) string type value.
     */
    const std::string category = "POLYGON";
    
    /**
     * color is an arbitrary string type value.
     * color is used to demonstrate how abstract constructors work.
     */
    std::string color;
    
public:
    
    /**
     * The default POLYGON constructor sets the color value to "orange".
     * 
     * Note that POLYGON type objects cannot be instantiated (i.e. occupy space in memory)
     * because the POLYGON class is abstract. 
     * 
     * (pointer-to-POLYGON type variables can be instantiated, however, and used to store the memory addresses
     * of objects whose classes are derived from the POLYGON).
     * 
     * POLYGON polygon; // This command does not work because POLYGON is an abstract class.
     * POLYGON * pointer_to_polygon; // The pointer-to-polygon type variable can store the memory address of an object whose data type is a non-abstract derived class of POLYGON such as QUADRILATERAL.
     * pointer_to_polygon = new QUADRILATERAL; // Assign memory to a dynamic QUADRILATERAL instance (i.e. and dynamic implies that the variable was created during program runtime instead of during program compile time).
     * pointer_to_polygon -&gt; print(output); // Indirectly call the POLYGON print method and not the QUADRILATERAL print method.
     * 
     * The POLYGON constructor is implemented only by classes which are
     * descendents of the POLYGON class.
     */
    POLYGON();
    
    /**
     * The virtual methods get_area() and get_perimeter() 
     * must be defined by classes which are derived from the POLYGON class.
     */
    virtual double get_area() = 0;
    virtual double get_perimeter() = 0;

    /**
     * The descriptor method prints a description of the caller POLYGON instance to the output stream.
     * If no function input is supplied, output is set to the command line terminal.
     */
    void print(std::ostream &amp; output = std::cout);

    /**
     * The friend function is an alternative to the print method.
     * The friend function overloads the ostream operator (i.e. &lt;&lt;).
     * 
     * The friend function is not a member of the POLYGON class,
     * but that friend function does have access to the private and protected members of the POLYGON class
     * as though that friend function was a member of the POLYGON class.
     */
    friend std::ostream &amp; operator &lt;&lt; (std::ostream &amp; output, POLYGON &amp; polygon);

    /**
     * The destructor method of the POLYGON class de-allocates memory which was used to 
     * instantiate the POLYGON object which is calling this function.
     * 
     * The destructor method of the POLYGON class is automatically called when 
     * the program scope in which the caller POLYGON object was instantiated terminates.
     */
    ~POLYGON();
};

/* preprocessing directives */
#endif // Terminate the conditional preprocessing directives code block in this header file.
</pre>
<hr />
<p><strong>POLYGON_CLASS_SOURCE_CODE</strong></p>
<hr />
<p>The following source code defines the functions of the POLYGON class.</p>
<p>C++_source_file: <a style="background: #000000;color: #00ff00" href="https://raw.githubusercontent.com/karlinarayberinger/KARLINA_OBJECT_summer_2023_starter_pack/main/polygon.cpp" target="_blank" rel="noopener">https://raw.githubusercontent.com/karlinarayberinger/KARLINA_OBJECT_summer_2023_starter_pack/main/polygon.cpp</a></p>
<hr />
<pre>/**
 * file: polygon.cpp
 * type: C++ (source file)
 * date: 07_JULY_2023
 * author: karbytes
 * license: PUBLIC_DOMAIN
 */

// Include the C++ header file which contains preprocessing directives, variable declarations, and function prototypes for the POLYGON class.
#include "polygon.h" 

/**
 * The default POLYGON constructor sets the color value to "orange".
 * 
 * Note that POLYGON type objects cannot be instantiated (i.e. occupy space in memory)
 * because the POLYGON class is abstract. 
 * 
 * (pointer-to-POLYGON type variables can be instantiated, however, and used to store the memory addresses
 * of objects whose classes are derived from the POLYGON).
 * 
 * POLYGON polygon; // This command does not work because POLYGON is an abstract class.
 * POLYGON * pointer_to_polygon; // The pointer-to-polygon type variable can store the memory address of an object whose data type is a non-abstract derived class of POLYGON such as QUADRILATERAL.
 * pointer_to_polygon = new QUADRILATERAL; // Assign memory to a dynamic QUADRILATERAL instance (i.e. and dynamic implies that the variable was created during program runtime instead of during program compile time).
 * pointer_to_polygon -&gt; print(output); // Indirectly call the POLYGON print method and not the QUADRILATERAL print method.
 * 
 * The POLYGON constructor is implemented only by classes which are
 * descendents of the POLYGON class.
 */
POLYGON::POLYGON()
{
    std::cout &lt;&lt; "\n\nCreating the POLYGON type object whose memory address is " &lt;&lt; this &lt;&lt; "...";
    color = "orange";
}

/**
 * The virtual methods get_area() and get_perimeter() must be defined by 
 * classes which are derived from the POLYGON class.
 */
double POLYGON::get_area() { return 0.0; }
double POLYGON::get_perimeter() { return 0.0; }

/**
 * The descriptor method prints a description of the caller POLYGON instance to the output stream.
 * If no function input is supplied, output is set to the command line terminal.
 */
void POLYGON::print(std::ostream &amp; output)
{
    output &lt;&lt; "\n\n--------------------------------------------------------------------------------------------------";
    output &lt;&lt; "\nmemory_address = " &lt;&lt; this &lt;&lt; ".";
    output &lt;&lt; "\ncategory = " &lt;&lt; category &lt;&lt; ".";
    output &lt;&lt; "\ncolor = " &lt;&lt; color &lt;&lt; ".";
    output &lt;&lt; "\n&amp;category = " &lt;&lt; &amp;category &lt;&lt; ".";
    output &lt;&lt; "\n&amp;color = " &lt;&lt; &amp;color &lt;&lt; ".";
    output &lt;&lt; "\n--------------------------------------------------------------------------------------------------";
}

/**
 * The friend function is an alternative to the print method.
 * The friend function overloads the ostream operator (i.e. &lt;&lt;).
 * 
 * The friend function is not a member of the POLYGON class,
 * but that friend function does have access to the private and protected members of the POLYGON class
 * as though that friend function was a member of the POLYGON class.
 */
std::ostream &amp; operator &lt;&lt; (std::ostream &amp; output, POLYGON &amp; polygon)
{
    polygon.print(output);
    return output;
}

/**
 * The destructor method of the POLYGON class de-allocates memory which was used to 
 * instantiate the POLYGON object which is calling this function.
 * 
 * The destructor method of the POLYGON class is automatically called when 
 * the program scope in which the caller POLYGON object was instantiated terminates.
 */
POLYGON::~POLYGON()
{
    std::cout &lt;&lt; "\n\nDeleting the POLYGON type object whose memory address is " &lt;&lt; this &lt;&lt; "...";
}
</pre>
<hr />
<p><strong>QUADRILATERAL_CLASS_HEADER</strong></p>
<hr />
<p>The following header file contains the preprocessing directives and function prototypes of the QUADRILATERAL class.</p>
<p>C++_header_file: <a style="background: #000000;color: #00ff00" href="https://raw.githubusercontent.com/karlinarayberinger/KARLINA_OBJECT_summer_2023_starter_pack/main/quadrilateral.h" target="_blank" rel="noopener">https://raw.githubusercontent.com/karlinarayberinger/KARLINA_OBJECT_summer_2023_starter_pack/main/quadrilateral.h</a></p>
<hr />
<pre>/**
 * file: quadrilateral.h
 * type: C++ (header file)
 * date: 07_JULY_2023
 * author: karbytes
 * license: PUBLIC_DOMAIN
 */

// If quadrilateral.h has not already been linked to a source file (.cpp), then link this header file to the source file(s) which include this header file.
#ifndef QUADRILATERAL_H 
#define QUADRILATERAL_H

// Include the C++ header file which contains preprocessing directives, variable declarations, and function prototypes for the POLYGON class.
#include "polygon.h" 

/**
 * QUADRILATERAL is a class which inherits the protected and public data
 * attributes and methods of POLYGON (and POLYGON is an abstract class).
 * 
 * A QUADRILATERAL object represents an instance in which four unique POINT instances exist 
 * such that each one of those four POINT instances represents a unique coordinate pair within the tuple of four POINT instances 
 * (such that each coordinate pair represents exactly one two-dimensional point, POINT(X,Y), on a Cartesian grid).
 * 
 * Each QUADRILATERAL object represents a specific four-sided polygon whose area is a positive real number.
 * 
 * Class members which are set to the protected access specifier
 * are accessible to the base class and to derived classes.
 * 
 * Class members which are set to the private access specifier
 * are only accessible to the base class.
 * 
 * Class members which are set to the public access specifier
 * are accessible to any scope within the program where
 * the base class and its derived classes are implemented.
 */
class QUADRILATERAL: public POLYGON
{
protected:

    /**
     * category is a description of the POLYGON instance.
     * category is set to a constant (i.e. immutable) string type value.
     */
    const std::string category = "POLYGON/QUADRILATERAL";

    /**
     * POINT type objects A, B, C, and D represent points on a Cartesian plane.
     * Each POINT type object has two int type variables for representing a two-dimensional whole number coordinate pair.
     * The X data attribute of a POINT object represents a whole number position on the horizontal axis (i.e. x-axis) of a Cartesian plane.
     * The Y data attribute of a POINT object represents a whole number position on the vertical axis (i.e. y-axis) of the same Cartesian plane.
     */
    POINT A, B, C, D;

    /**
     * If each of the four whole number coordinate pairs represented by the POINT type input values named _A, _B, _C, and _D are unique whole number coordinate pairs, 
     * return true. 
     * Otherwise, return false.
     */
    bool points_represent_unique_coordinate_pairs(POINT _A, POINT _B, POINT _C, POINT _D);

    /**
     * If sum of the interior angle measurements of the quadrilateral which the caller QUADRILATERAL object represents add up to approximately 360 degrees, 
     * return true.
     * Otherwise, return false.
     */
    bool interior_angles_add_up_to_360_degrees();
    
public:

    /**
     * The test function helps to illustrate how pointers work.
     */
    int quadrilateral_test(); // return 555
    
    /**
     * The default constructor of the QUADRILATERAL class calls the constructor of the POLYGON class and
     * sets the POINT type data member of the QUADRILATERAL object returned by this function named A to POINT(0,0), 
     * sets the POINT type data member of the QUADRILATERAL object returned by this function named B to POINT(0,5), 
     * sets the POINT type data member of the QUADRILATERAL object returned by this function named C to POINT(4,5), and
     * sets the POINT type data member of the QUADRILATERAL object returned by this function named D to POINT(4,0).
     */
    QUADRILATERAL();
    
    /**
     * The normal constructor of QUADRILATERAL attempts to set
     * the string type data member of this to the input string type value named color and
     * the POINT type data member of this named A to the input POINT type value named A and
     * the POINT type data member of this named B to the input POINT type value named B and
     * the POINT type data member of this named C to the input POINT type value named C and
     * the POINT type data member of this named D to the input POINT type value named D.
     * 
     * (The keyword this refers to the QUADRILATERAL object which is returned by this function).
     * 
     * If A, B, C, and D represent unique points on a Cartesian plane and
     * if the interior angles of the quadrilateral which those points would represent add up to 360 degrees and
     * if the area of the quadrilateral which those points represents is larger than zero,
     * use the input POINT values as the POINT values for the QUADRILATERAL object which is returned by this function.
     */
    QUADRILATERAL(std::string color, POINT A, POINT B, POINT C, POINT D);

    /**
     * The copy constructor method of the QUADRILATERAL class 
     * instantiates QUADRILATERAL type objects 
     * whose A value is set to the A value of the input QUADRILATERAL object,
     * whose B value is set to the B value of the input QUADRILATERAL object,
     * whose C value is set to the C value of the input QUADRILATERAL object, and
     * whose D value is set to the D value of the input QUADRILATERAL object.
     */
    QUADRILATERAL(QUADRILATERAL &amp; quadrilateral);

    /**
     * The QUADRILATERAL class implements the virtual get_area() method of the POLYGON class.
     * 
     * The getter method returns the area of the quadrilateral represented by the caller QUADRILATERAL object
     * using using Heron's Formula to 
     * compute the area of each of the two triangles which comprise that quadrilateral.
     * 
     * Let AB be the length of the line segment whose endpoints are A and B.
     * Let BC be the length of the line segment whose endpoints are B and C.
     * Let CA be the length of the line segment whose endpoints are C and A.
     * Let CD be the length of the line segment whose endpoints are C and D.
     * Let DA be the length of the line segment whose endpoints are D and A.
     * 
     * Let the first triangle be the area which is enclosed inside line segments represented by AB, BC, and CA.
     * Let the second triangle be the area which is enclosed inside line segments represented by AC, CD, and DA.
     * 
     * Then compute the area of each triangle using Heron's Formula as follows:
     * 
     * Let s be the semiperimeter of a triangle (i.e. the perimeter divided by 2).
     * Let a, b, and c be the side lengths of a triangle.
     * 
     * Then 
     * 
     * area = square_root( s * (s - a) * (s - b) * (s - c) ).
     * 
     * Finally, return the sum of the two triangle areas.
     */
    double get_area();

    /**
     * The QUADRILATERAL class implements the virtual get_perimeter() method of the POLYGON class.
     * 
     * The getter method returns the perimeter of the quadrilateral represented by the caller QUADRILATERAL object
     * by adding up the four side lengths of that quadrilateral.
     * 
     * Let AB be the length of the line segment whose endpoints are A and B.
     * Let BC be the length of the line segment whose endpoints are B and C.
     * Let CD be the length of the line segment whose endpoints are C and D.
     * Let DA be the length of the line segment whose endpoints are D and A.
     * 
     * Then return the sum of AB, BC, CD, and DA.
     */
    double get_perimeter();
    
    /** 
     * This method overrides the POLYGON class's print method.
     * 
     * The descriptor method prints a description of the caller QUADRILATERAL instance to the output stream.
     * 
     * If no function input is supplied, output is set to the command line terminal.
     */
    void print(std::ostream &amp; output = std::cout);
    
    /**
     * The friend function is an alternative to the print method.
     * The friend function overloads the ostream operator (i.e. &lt;&lt;).
     * 
     * The friend function is not a member of the QUADRILATERAL class,
     * but the friend function does have access to the private and protected members of the QUADRILATERAL class as though
     * the friend function was a member of the QUADRILATERAL class.
     */
    friend std::ostream &amp; operator &lt;&lt; (std::ostream &amp; output, QUADRILATERAL &amp; quadrilateral);

    /**
     * The destructor method of the QUADRILATERAL class de-allocates memory which was used to 
     * instantiate the QUADRILATERAL object which is calling this function.
     * 
     * The destructor method of the QUADRILATERAL class is automatically called when 
     * the program scope in which the caller QUADRILATERAL object was instantiated terminates.
     */
    ~QUADRILATERAL();
};

/* preprocessing directives */
#endif // Terminate the conditional preprocessing directives code block in this header file.
</pre>
<hr />
<p><strong>QUADRILATERAL_CLASS_SOURCE_CODE</strong></p>
<hr />
<p>The following source code defines the functions of the QUADRILATERAL class.</p>
<p>C++_source_file: <a style="background: #000000;color: #00ff00" href="https://raw.githubusercontent.com/karlinarayberinger/KARLINA_OBJECT_summer_2023_starter_pack/main/quadrilateral.cpp" target="_blank" rel="noopener">https://raw.githubusercontent.com/karlinarayberinger/KARLINA_OBJECT_summer_2023_starter_pack/main/quadrilateral.cpp</a></p>
<hr />
<pre>/**
 * file: quadrilateral.cpp
 * type: C++ (source file)
 * date: 07_JULY_2023
 * author: karbytes
 * license: PUBLIC_DOMAIN
 */

// Include the C++ header file which contains preprocessing directives, variable declarations, and function prototypes for the QUADRILATERAL class.
#include "quadrilateral.h" 

/**
 * If each of the four whole number coordinate pairs represented by the POINT type input values named _A, _B, _C, and _D are unique whole number coordinate pairs, 
 * return true. 
 * Otherwise, return false.
 */
bool QUADRILATERAL::points_represent_unique_coordinate_pairs(POINT _A, POINT _B, POINT _C, POINT _D)
{
    if ((_A.get_X() == _B.get_X()) &amp;&amp; (_A.get_Y() == _B.get_Y())) return false;
    if ((_A.get_X() == _C.get_X()) &amp;&amp; (_A.get_Y() == _C.get_Y())) return false;
    if ((_A.get_X() == _D.get_X()) &amp;&amp; (_A.get_Y() == _D.get_Y())) return false;
    if ((_B.get_X() == _C.get_X()) &amp;&amp; (_B.get_Y() == _C.get_Y())) return false;
    if ((_B.get_X() == _D.get_X()) &amp;&amp; (_B.get_Y() == _D.get_Y())) return false;
    if ((_C.get_X() == _D.get_X()) &amp;&amp; (_C.get_Y() == _D.get_Y())) return false;
    return true;
}

/**
 * If sum of the interior angle measurements of the quadrilateral which the caller QUADRILATERAL object represents add up to approximately 360 degrees, 
 * return true.
 * Otherwise, return false.
 */
bool QUADRILATERAL::interior_angles_add_up_to_360_degrees()
{
    double a0 = 0.0, b0 = 0.0, c0 = 0.0;
    double a1 = 0.0, b1 = 0.0, c1 = 0.0;
    double angle_opposite_of_a0 = 0.0, angle_opposite_of_b0 = 0.0, angle_opposite_of_c0 = 0.0; 
    double angle_opposite_of_a1 = 0.0, angle_opposite_of_b1 = 0.0, angle_opposite_of_c1 = 0.0; 
    double interior_angle_of_A = 0.0, interior_angle_of_B = 0.0, interior_angle_of_C = 0.0, interior_angle_of_D = 0.0;
    double sum_of_interior_angles = 0.0;

    // first triangle
    a0 = A.get_distance_from(B);
    b0 = B.get_distance_from(D);
    c0 = D.get_distance_from(A);
    angle_opposite_of_a0 = acos(((b0 * b0) + (c0 * c0) - (a0 * a0)) / (2 * b0 * c0)) * (180 / PI);
    angle_opposite_of_b0 = acos(((a0 * a0) + (c0 * c0) - (b0 * b0)) / (2 * a0 * c0)) * (180 / PI);
    angle_opposite_of_c0 = acos(((a0 * a0) + (b0 * b0) - (c0 * c0)) / (2 * a0 * b0)) * (180 / PI);

    // second triangle
    a1 = D.get_distance_from(B);
    b1 = B.get_distance_from(C);
    c1 = C.get_distance_from(D);
    angle_opposite_of_a1 = acos(((b1 * b1) + (c1 * c1) - (a1 * a1)) / (2 * b1 * c1)) * (180 / PI);
    angle_opposite_of_b1 = acos(((a1 * a1) + (c1 * c1) - (b1 * b1)) / (2 * a1 * c1)) * (180 / PI);
    angle_opposite_of_c1 = acos(((a1 * a1) + (b1 * b1) - (c1 * c1)) / (2 * a1 * b1)) * (180 / PI);

    interior_angle_of_A = angle_opposite_of_b0;
    interior_angle_of_B = angle_opposite_of_c0 + angle_opposite_of_c1;
    interior_angle_of_C = angle_opposite_of_a1;
    interior_angle_of_D = angle_opposite_of_b1 + angle_opposite_of_a0;

    sum_of_interior_angles = interior_angle_of_A + interior_angle_of_B + interior_angle_of_C + interior_angle_of_D;

    // Allow for there to be a +/- 2 margin of error for the value stored in sum_of_interior_angles with the ideal value being 360.
    if ((sum_of_interior_angles &gt;= 358) &amp;&amp; (sum_of_interior_angles &lt;= 362)) return true;
    return false;
}

/**
 * The test function helps to illustrate how pointers work.
 */
int QUADRILATERAL::quadrilateral_test()
{
    return 555;
}
    
/**
 * The default constructor of the QUADRILATERAL class calls the constructor of the POLYGON class and
 * sets the POINT type data member of the QUADRILATERAL object returned by this function named A to POINT(0,0), 
 * sets the POINT type data member of the QUADRILATERAL object returned by this function named B to POINT(0,5), 
 * sets the POINT type data member of the QUADRILATERAL object returned by this function named C to POINT(4,5), and
 * sets the POINT type data member of the QUADRILATERAL object returned by this function named D to POINT(4,0).
 */
QUADRILATERAL::QUADRILATERAL()
{
    std::cout &lt;&lt; "\n\nCreating the QUADRILATERAL type object whose memory address is " &lt;&lt; this &lt;&lt; "...";
    A = POINT(0,0);
    B = POINT(0,5);
    C = POINT(4,5);
    D = POINT(4,0);
}
    
/**
 * The normal constructor of QUADRILATERAL attempts to set
 * the string type data member of this to the input string type value named color and
 * the POINT type data member of this named A to the input POINT type value named A and
 * the POINT type data member of this named B to the input POINT type value named B and
 * the POINT type data member of this named C to the input POINT type value named C and
 * the POINT type data member of this named D to the input POINT type value named D.
 * 
 * (The keyword this refers to the QUADRILATERAL object which is returned by this function).
 * 
 * If A, B, C, and D represent unique points on a Cartesian plane and
 * if the interior angles of the quadrilateral which those points would represent add up to 360 degrees and
 * if the area of the quadrilateral which those points represents is larger than zero,
 * use the input POINT values as the POINT values for the QUADRILATERAL object which is returned by this function.
 */
QUADRILATERAL::QUADRILATERAL(std::string color, POINT A, POINT B, POINT C, POINT D)
{
    std::cout &lt;&lt; "\n\nCreating the QUADRILATERAL type object whose memory address is " &lt;&lt; this &lt;&lt; "...";
    QUADRILATERAL test_quadrilateral;
    test_quadrilateral.A.set_X(A.get_X());
    test_quadrilateral.A.set_Y(A.get_Y());
    test_quadrilateral.B.set_X(B.get_X());
    test_quadrilateral.B.set_Y(B.get_Y());
    test_quadrilateral.C.set_X(C.get_X());
    test_quadrilateral.C.set_Y(C.get_Y());
    test_quadrilateral.D.set_X(D.get_X());
    test_quadrilateral.D.set_Y(D.get_Y());
    if (points_represent_unique_coordinate_pairs(A, B, C, D) &amp;&amp; test_quadrilateral.interior_angles_add_up_to_360_degrees() &amp;&amp; (test_quadrilateral.get_area() &gt; 0))
    {
        this -&gt; A = A;
        this -&gt; B = B;
        this -&gt; C = C;
        this -&gt; D = D;
    }
    else
    {
        this -&gt; A = POINT(0,0);
        this -&gt; B = POINT(0,5);
        this -&gt; C = POINT(4,5);
        this -&gt; D = POINT(4,0);
    }
    this -&gt; color = color;
}

/**
 * The copy constructor method of the QUADRILATERAL class 
 * instantiates QUADRILATERAL type objects 
 * whose A value is set to the A value of the input QUADRILATERAL object,
 * whose B value is set to the B value of the input QUADRILATERAL object,
 * whose C value is set to the C value of the input QUADRILATERAL object, and
 * whose D value is set to the D value of the input QUADRILATERAL object.
 */
QUADRILATERAL::QUADRILATERAL(QUADRILATERAL &amp; quadrilateral)
{
    std::cout &lt;&lt; "\n\nCreating the QUADRILATERAL type object whose memory address is " &lt;&lt; this &lt;&lt; "...";
    A = quadrilateral.A;
    B = quadrilateral.B;
    C = quadrilateral.C;
    D = quadrilateral.D;
    color = quadrilateral.color;
}

/**
 * The QUADRILATERAL class implements the virtual get_area() method of the POLYGON class.
 * 
 * The getter method returns the area of the quadrilateral represented by the caller QUADRILATERAL object
 * using using Heron's Formula to 
 * compute the area of each of the two triangles which comprise that quadrilateral.
 * 
 * Let AB be the length of the line segment whose endpoints are A and B.
 * Let BC be the length of the line segment whose endpoints are B and C.
 * Let CA be the length of the line segment whose endpoints are C and A.
 * Let CD be the length of the line segment whose endpoints are C and D.
 * Let DA be the length of the line segment whose endpoints are D and A.
 * 
 * Let the first triangle be the area which is enclosed inside line segments represented by AB, BC, and CA.
 * Let the second triangle be the area which is enclosed inside line segments represented by AC, CD, and DA.
 * 
 * Then compute the area of each triangle using Heron's Formula as follows:
 * 
 * Let s be the semiperimeter of a triangle (i.e. the perimeter divided by 2).
 * Let a, b, and c be the side lengths of a triangle.
 * 
 * Then 
 * 
 * area = square_root( s * (s - a) * (s - b) * (s - c) ).
 * 
 * Finally, return the sum of the two triangle areas.
 */
double QUADRILATERAL::get_area()
{
    double a0 = 0.0, b0 = 0.0, c0= 0.0, s0 = 0.0, area_0 = 0.0;
    double a1 = 0.0, b1 = 0.0, c1 = 0.0, s1 = 0.0, area_1 = 0.0;

    // first triangle
    a0 = A.get_distance_from(B);
    b0 = B.get_distance_from(C);
    c0 = C.get_distance_from(A);
    s0 = (a0 + b0 + c0) / 2;
    area_0 = sqrt(s0 * (s0 - a0) * (s0 - b0) * (s0 - c0));

    // second triangle
    a1 = A.get_distance_from(C);
    b1 = C.get_distance_from(D);
    c1 = D.get_distance_from(A);
    s1 = (a1 + b1 + c1) / 2;
    area_1 = sqrt(s1 * (s1 - a1) * (s1 - b1) * (s1 - c1));

    // Return the sum of the two triangle areas.
    return area_0 + area_1;
}

/**
 * The QUADRILATERAL class implements the virtual get_perimeter() method of the POLYGON class.
 * 
 * The getter method returns the perimeter of the quadrilateral represented by the caller QUADRILATERAL object
 * by adding up the four side lengths of that quadrilateral.
 * 
 * Let AB be the length of the line segment whose endpoints are A and B.
 * Let BC be the length of the line segment whose endpoints are B and C.
 * Let CD be the length of the line segment whose endpoints are C and D.
 * Let DA be the length of the line segment whose endpoints are D and A.
 * 
 * Then return the sum of AB, BC, CD, and DA.
 */
double QUADRILATERAL::get_perimeter()
{
    double AB = 0.0, BC = 0.0, CD = 0.0, DA = 0.0;
    AB = A.get_distance_from(B);
    BC = B.get_distance_from(C);
    CD = C.get_distance_from(D);
    DA = D.get_distance_from(A);
    return AB + BC + CD + DA;
}
    
/** 
 * This method overrides the POLYGON class's print method.
 * 
 * The descriptor method prints a description of the caller QUADRILATERAL instance to the output stream.
 * 
 * If no function input is supplied, output is set to the command line terminal.
 */
void QUADRILATERAL::print(std::ostream &amp; output)
{
    double a0 = 0.0, b0 = 0.0, c0 = 0.0;
    double a1 = 0.0, b1 = 0.0, c1 = 0.0;
    double angle_opposite_of_a0 = 0.0, angle_opposite_of_b0 = 0.0, angle_opposite_of_c0 = 0.0; 
    double angle_opposite_of_a1 = 0.0, angle_opposite_of_b1 = 0.0, angle_opposite_of_c1 = 0.0; 
    double interior_angle_of_A = 0.0, interior_angle_of_B = 0.0, interior_angle_of_C = 0.0, interior_angle_of_D = 0.0;

    // first triangle
    a0 = A.get_distance_from(B);
    b0 = B.get_distance_from(D);
    c0 = D.get_distance_from(A);
    angle_opposite_of_a0 = acos(((b0 * b0) + (c0 * c0) - (a0 * a0)) / (2 * b0 * c0)) * (180 / PI);
    angle_opposite_of_b0 = acos(((a0 * a0) + (c0 * c0) - (b0 * b0)) / (2 * a0 * c0)) * (180 / PI);
    angle_opposite_of_c0 = acos(((a0 * a0) + (b0 * b0) - (c0 * c0)) / (2 * a0 * b0)) * (180 / PI);

    // second triangle
    a1 = D.get_distance_from(B);
    b1 = B.get_distance_from(C);
    c1 = C.get_distance_from(D);
    angle_opposite_of_a1 = acos(((b1 * b1) + (c1 * c1) - (a1 * a1)) / (2 * b1 * c1)) * (180 / PI);
    angle_opposite_of_b1 = acos(((a1 * a1) + (c1 * c1) - (b1 * b1)) / (2 * a1 * c1)) * (180 / PI);
    angle_opposite_of_c1 = acos(((a1 * a1) + (b1 * b1) - (c1 * c1)) / (2 * a1 * b1)) * (180 / PI);

    interior_angle_of_A = angle_opposite_of_b0;
    interior_angle_of_B = angle_opposite_of_c0 + angle_opposite_of_c1;
    interior_angle_of_C = angle_opposite_of_a1;
    interior_angle_of_D = angle_opposite_of_b1 + angle_opposite_of_a0;

    output &lt;&lt; "\n\n--------------------------------------------------------------------------------------------------";
    output &lt;&lt; "\nthis = " &lt;&lt; this &lt;&lt; ". // The keyword named this is a pointer which stores the memory address of the first memory cell of a QUADRILATERAL sized chunk of contiguous memory cells which are allocated to the caller TRIANGLE object.";
    output &lt;&lt; "\n&amp;category = " &lt;&lt; &amp;category &lt;&lt; ". // The reference operation returns the memory address of the first memory cell of a string sized chunk of contiguous memory cells which are allocated to the string data attribute named category.";
    output &lt;&lt; "\n&amp;color = " &lt;&lt; &amp;color &lt;&lt; ". // The reference operation returns the memory address of the first memory cell of a string sized chunk of contiguous memory cells which are allocated to the string data attribute named color..";
    output &lt;&lt; "\n&amp;A = " &lt;&lt; &amp;A &lt;&lt; ". // The reference operation returns the memory address of the first memory cell of a POINT sized chunk of contiguous memory cells which are allocated to the POINT data attribute named A.";
    output &lt;&lt; "\n&amp;B = " &lt;&lt; &amp;B &lt;&lt; ". // The reference operation returns the memory address of the first memory cell of a POINT sized chunk of contiguous memory cells which are allocated to the POINT data attribute named B.";
    output &lt;&lt; "\n&amp;C = " &lt;&lt; &amp;C &lt;&lt; ". // The reference operation returns the memory address of the first memory cell of a POINT sized chunk of contiguous memory cells which are allocated to the POINT data attribute named C.";
    output &lt;&lt; "\n&amp;D = " &lt;&lt; &amp;D &lt;&lt; ". // The reference operation returns the memory address of the first memory cell of a POINT sized chunk of contiguous memory cells which are allocated to the POINT data attribute named D.";
    output &lt;&lt; "\nsizeof(int) = " &lt;&lt; sizeof(int) &lt;&lt; ". // The sizeof() operation returns the nonnegative integer number of bytes of memory which an int type variable occupies. (Each memory cell has a data capacity of 1 byte).";
    output &lt;&lt; "\nsizeof(int *) = " &lt;&lt; sizeof(int *) &lt;&lt; ". // The sizeof() operation returns the nonnegative integer number of bytes of memory which a pointer-to-int type variable occupies. (Each memory cell has a data capacity of 1 byte).";
    output &lt;&lt; "\nsizeof(int **) = " &lt;&lt; sizeof(int **) &lt;&lt; ". // The sizeof() operation returns the nonnegative integer number of bytes of memory which an pointer-to-pointer-to-int type variable occupies. (Each memory cell has a data capacity of 1 byte).";
    output &lt;&lt; "\nsizeof(std::string) = " &lt;&lt; sizeof(std::string) &lt;&lt; ". // The sizeof() operation returns the nonnegative integer number of bytes of memory which a string type variable occupies. (Each memory cell has a data capacity of 1 byte).";
    output &lt;&lt; "\nsizeof(std::string *) = " &lt;&lt; sizeof(std::string *) &lt;&lt; ". // The sizeof() operation returns the nonnegative integer number of bytes of memory which a pointer-to-string type variable occupies. (Each memory cell has a data capacity of 1 byte).";
    output &lt;&lt; "\nsizeof(std::string **) = " &lt;&lt; sizeof(std::string **) &lt;&lt; ". // The sizeof() operation returns the nonnegative integer number of bytes of memory which a pointer-to-pointer-to-string type variable occupies. (Each memory cell has a data capacity of 1 byte).";
    output &lt;&lt; "\nsizeof(POINT) = " &lt;&lt; sizeof(POINT) &lt;&lt; ". // The sizeof() operation returns the nonnegative integer number of bytes of memory which a POINT type object occupies. (Each memory cell has a data capacity of 1 byte).";
    output &lt;&lt; "\nsizeof(POINT *) = " &lt;&lt; sizeof(POINT *) &lt;&lt; ". // The sizeof() operation returns the nonnegative integer number of bytes of memory which a pointer-to-POINT type variable occupies. (Each memory cell has a data capacity of 1 byte).";
    output &lt;&lt; "\nsizeof(POINT **) = " &lt;&lt; sizeof(POINT **) &lt;&lt; ". // The sizeof() operation returns the nonnegative integer number of bytes of memory which a pointer-to-pointer-to-POINT type variable occupies. (Each memory cell has a data capacity of 1 byte).";
    output &lt;&lt; "\nsizeof(POLYGON) = " &lt;&lt; sizeof(POLYGON) &lt;&lt; ". // The sizeof() operation returns the nonnegative integer number of bytes of memory which a POLYGON type object occupies. (Each memory cell has a data capacity of 1 byte).";
    output &lt;&lt; "\nsizeof(POLYGON *) = " &lt;&lt; sizeof(POLYGON *) &lt;&lt; ". // The sizeof() operation returns the nonnegative integer number of bytes of memory which a pointer-to-POLYGON type variable occupies. (Each memory cell has a data capacity of 1 byte).";
    output &lt;&lt; "\nsizeof(POLYGON **) = " &lt;&lt; sizeof(POLYGON **) &lt;&lt; ". // The sizeof() operation returns the nonnegative integer number of bytes of memory which a pointer-to-pointer-to-POLYGON type variable occupies. (Each memory cell has a data capacity of 1 byte).";
    output &lt;&lt; "\nsizeof(QUADRILATERAL) = " &lt;&lt; sizeof(QUADRILATERAL) &lt;&lt; ". // The sizeof() operation returns the nonnegative integer number of bytes of memory which a QUADRILATERAL type object occupies. (Each memory cell has a data capacity of 1 byte).";
    output &lt;&lt; "\nsizeof(QUADRILATERAL *) = " &lt;&lt; sizeof(QUADRILATERAL *) &lt;&lt; ". // The sizeof() operation returns the nonnegative integer number of bytes of memory which a pointer-to-QUADRILATERAL type variable occupies. (Each memory cell has a data capacity of 1 byte).";
    output &lt;&lt; "\nsizeof(QUADRILATERAL **) = " &lt;&lt; sizeof(QUADRILATERAL **) &lt;&lt; ". // The sizeof() operation returns the nonnegative integer number of bytes of memory which a pointer-to-pointer-to-QUADRILATERAL type variable occupies. (Each memory cell has a data capacity of 1 byte).";
    output &lt;&lt; "\ncategory = " &lt;&lt; category &lt;&lt; ". // This is an immutable string type value which is a data member of the caller QUADRILATERAL object.";
    output &lt;&lt; "\ncolor = " &lt;&lt; color &lt;&lt; ". // This is a string type value which is a data member of the caller QUADRILATERAL object.";
    output &lt;&lt; "\nA = POINT(" &lt;&lt; A.get_X() &lt;&lt; "," &lt;&lt; A.get_Y() &lt;&lt; "). // A represents a point (which is neither B nor C nor D) plotted on a two-dimensional Cartesian grid (such that the X value represents a real whole number position along the horizontal axis of the Cartesian grid while Y represents a real whole number position along the vertical axis of the same Cartesian grid).";
    output &lt;&lt; "\nB = POINT(" &lt;&lt; B.get_X() &lt;&lt; "," &lt;&lt; B.get_Y() &lt;&lt; "). // B represents a point (which is neither A nor C nor D) plotted on a two-dimensional Cartesian grid (such that the X value represents a real whole number position along the horizontal axis of the Cartesian grid while Y represents a real whole number position along the vertical axis of the same Cartesian grid).";
    output &lt;&lt; "\nC = POINT(" &lt;&lt; C.get_X() &lt;&lt; "," &lt;&lt; C.get_Y() &lt;&lt; "). // C represents a point (which is neither A nor B nor D) plotted on a two-dimensional Cartesian grid (such that the X value represents a real whole number position along the horizontal axis of the Cartesian grid while Y represents a real whole number position along the vertical axis of the same Cartesian grid).";
    output &lt;&lt; "\nD = POINT(" &lt;&lt; D.get_X() &lt;&lt; "," &lt;&lt; D.get_Y() &lt;&lt; "). // D represents a point (which is neither A nor B nor C) plotted on a two-dimensional Cartesian grid (such that the X value represents a real whole number position along the horizontal axis of the Cartesian grid while Y represents a real whole number position along the vertical axis of the same Cartesian grid).";
    output &lt;&lt; "\na = B.get_distance_from(C) = " &lt;&lt; B.get_distance_from(C) &lt;&lt; ". // The method returns the approximate nonnegative real number of Cartesian grid unit lengths which span the length of the shortest path between points B and C.";
    output &lt;&lt; "\nb = C.get_distance_from(D) = " &lt;&lt; C.get_distance_from(D) &lt;&lt; ". // The method returns the approximate nonnegative real number of Cartesian grid unit lengths which span the length of the shortest path between points C and D.";
    output &lt;&lt; "\nc = D.get_distance_from(A) = " &lt;&lt; D.get_distance_from(A) &lt;&lt; ". // The method returns the approximate nonnegative real number of Cartesian grid unit lengths which span the length of the shortest path between points D and A.";
    output &lt;&lt; "\nd = A.get_distance_from(B) = " &lt;&lt; A.get_distance_from(B) &lt;&lt; ". // The method returns the approximate nonnegative real number of Cartesian grid unit lengths which span the length of the shortest path between points A and B.";
    output &lt;&lt; "\nA.get_slope_of_line_to(B) = " &lt;&lt; A.get_slope_of_line_to(B) &lt;&lt; ". // The method returns the approximate nonnegative real number which represents the slope of the line which intersects points A and B.";
    output &lt;&lt; "\nB.get_slope_of_line_to(C) = " &lt;&lt; B.get_slope_of_line_to(C) &lt;&lt; ". // The method returns the approximate nonnegative real number which represents the slope of the line which intersects points B and C.";
    output &lt;&lt; "\nC.get_slope_of_line_to(D) = " &lt;&lt; C.get_slope_of_line_to(D) &lt;&lt; ". // The method returns the approximate nonnegative real number which represents the slope of the line which intersects points C and D.";
    output &lt;&lt; "\nD.get_slope_of_line_to(A) = " &lt;&lt; D.get_slope_of_line_to(A) &lt;&lt; ". // The method returns the approximate nonnegative real number which represents the slope of the line which intersects points B and C.";
    output &lt;&lt; "\ninterior_angle_DAB = interior_angle_of_A = " &lt;&lt; interior_angle_of_A &lt;&lt; ". // The value represents the approximate nonnegative real number angle measurement of the acute or else right angle formed by the intersection of the line segment whose endpoints are D and A with the line segment whose endpoints are A and B such that those two line segments intersect at A (and the angle measurement is in degrees and not in radians).";
    output &lt;&lt; "\ninterior_angle_ABC = interior_angle_of_B = " &lt;&lt; interior_angle_of_B &lt;&lt; ". // The method returns the approximate nonnegative real number angle measurement of the acute or else right angle formed by the intersection of the line segment whose endpoints are A and B with the line segment whose endpoints are B and C such that those two line segments intersect at B (and the angle measurement is in degrees and not in radians).";
    output &lt;&lt; "\ninterior_angle_BCD = interior_angle_of_C = " &lt;&lt; interior_angle_of_C &lt;&lt; ". // The method returns the approximate nonnegative real number angle measurement of the acute or else right angle formed by the intersection of the line segment whose endpoints are B and C with the line segment whose endpoints are C and D such that those two line segments intersect at C (and the angle measurement is in degrees and not in radians).";
    output &lt;&lt; "\ninterior_angle_CDA = interior_angle_of_D = " &lt;&lt; interior_angle_of_D &lt;&lt; ". // The method returns the approximate nonnegative real number angle measurement of the acute or else right angle formed by the intersection of the line segment whose endpoints are C and D with the line segment whose endpoints are D and A such that those two line segments intersect at D (and the angle measurement is in degrees and not in radians).";
    output &lt;&lt; "\ninterior_angle_of_A + interior_angle_of_B + interior_angle_of_C + interior_angle_of_D = " &lt;&lt; interior_angle_of_A + interior_angle_of_B + interior_angle_of_C + interior_angle_of_D &lt;&lt; ". // sum of all four approximate interior angle measurements of the quadrilateral represented by the caller QUADRILATERAL object (in degrees and not in radians)";
    output &lt;&lt; "\nget_perimeter() = a + b + c + d = " &lt;&lt; get_perimeter() &lt;&lt; ". // The method returns the sum of the four approximated side lengths of the quadrilateral which the caller QUADRILATERAL object represents.";
    output &lt;&lt; "\nget_area() = " &lt;&lt; get_area() &lt;&lt; ". // The method returns the approximate nonnegative real number of Cartesian grid unit squares which are enclosed inside of the two-dimensional region formed by the four line segments which connect points A to B, B to C, C to D, and D to A.";
    output &lt;&lt; "\n--------------------------------------------------------------------------------------------------";
}

/**
 * The friend function is an alternative to the print method.
 * The friend function overloads the ostream operator (i.e. &lt;&lt;).
 * 
 * The friend function is not a member of the QUADRILATERAL class,
 * but it does have access to the members of QUADRILATERAL as though
 * it were a member of that class.
 */
std::ostream &amp; operator &lt;&lt; (std::ostream &amp; output, QUADRILATERAL &amp; quadrilateral)
{
    quadrilateral.print(output);
    return output;
}

/**
 * The destructor method of the QUADRILATERAL class de-allocates memory which was used to 
 * instantiate the QUADRILATERAL object which is calling this function.
 * 
 * The destructor method of the QUADRILATERAL class is automatically called when 
 * the program scope in which the caller QUADRILATERAL object was instantiated terminates.
 */
QUADRILATERAL::~QUADRILATERAL()
{
    std::cout &lt;&lt; "\n\nDeleting the QUADRILATERAL type object whose memory address is " &lt;&lt; this &lt;&lt; "...";
}
</pre>
<hr />
<p><strong>TRAPEZOID_CLASS_HEADER</strong></p>
<hr />
<p>The following header file contains the preprocessing directives and function prototypes of the TRAPEZOID class.</p>
<p>C++_header_file: <a style="background: #000000;color: #00ff00" href="https://raw.githubusercontent.com/karlinarayberinger/KARLINA_OBJECT_summer_2023_starter_pack/main/trapezoid.h" target="_blank" rel="noopener">https://raw.githubusercontent.com/karlinarayberinger/KARLINA_OBJECT_summer_2023_starter_pack/main/trapezoid.h</a></p>
<hr />
<pre>/**
 * file: trapezoid.h
 * type: C++ (header file)
 * date: 07_JULY_2023
 * author: karbytes
 * license: PUBLIC_DOMAIN
 */

// If trapezoid.h has not already been linked to a source file (.cpp), then link this header file to the source file(s) which include this header file.
#ifndef TRAPEZOID_H 
#define TRAPEZOID_H

// Include the C++ header file which contains preprocessing directives, variable declarations, and function prototypes for the QUADRILATERAL class.
#include "quadrilateral.h" 

/**
 * TRAPEZOID is a class which inherits the protected and public data
 * attributes and methods of QUADRILATERAL.
 * 
 * A TRAPEZOID object represents a four-sided polygon such that exactly two opposite sides
 * are parallel to each other and not the same length.
 * 
 * Class members which are set to the protected access specifier
 * are accessible to the base class and to derived classes.
 * 
 * Class members which are set to the private access specifier
 * are only accessible to the base class.
 * 
 * Class members which are set to the public access specifier
 * are accessible to any scope within the program where
 * the base class and its derived classes are implemented.
 */
class TRAPEZOID: public QUADRILATERAL
{
protected:

    /**
     * category is a description of the POLYGON instance.
     * category is set to a const (i.e. const (i.e. immutable)) value.
     */
    const std::string category = "POLYGON/QUADRILATERAL/TRAPEZOID";

    /**
     * The helper method determines whether or not the caller TRAPEZOID instance represents a
     * quadrilateral with exactly two parallel opposite sides whose lengths are not identical.
     * Return true if the caller TRAPEZOID satisfies those conditions. Otherwise, return false.
     */
    bool is_trapezoid();
    
public:
    
    /**
     * The default constructor of the TRAPEZOID class calls the constructor of the QUADRILATERAL class and
     * sets the POINT type data member of the TRAPEZOID object returned by this function named A to POINT(0,0), 
     * sets the POINT type data member of the TRAPEZOID object returned by this function named B to POINT(1,1), 
     * sets the POINT type data member of the TRAPEZOID object returned by this function named C to POINT(2,1), and
     * sets the POINT type data member of the TRAPEZOID object returned by this function named D to POINT(3,0).
     */
    TRAPEZOID();

    /**
     * The normal constructor of TRAPEZOID attempts to set
     * the string type data member of this to the input string type value named color and
     * the POINT type data member of this named A to the input POINT type value named A and
     * the POINT type data member of this named B to the input POINT type value named B and
     * the POINT type data member of this named C to the input POINT type value named C and
     * the POINT type data member of this named D to the input POINT type value named D.
     * 
     * (The keyword this refers to the TRAPEZOID object which is returned by this function).
     * 
     * If A, B, C, and D represent unique points on a Cartesian plane and
     * if the interior angles of the quadrilateral which those points would represent add up to 360 degrees and
     * if the area of the quadrilateral which those points represents is larger than zero, and
     * if exactly two sides of the quadrilateral are parallel to each other,
     * use the input POINT values as the POINT values for the TRAPEZOID object which is returned by this function.
     */
    TRAPEZOID(std::string color, POINT A, POINT B, POINT C, POINT D);
    
    /**
     * The copy constructor of TRAPEZOID creates a clone of 
     * the input TRAPEZOID instance.
     */
    TRAPEZOID(TRAPEZOID &amp; trapezoid);
    
    /** 
     * This method overrides the QUADRILATERAL class's print method.
     * 
     * The descriptor method prints a description of the caller TRAPEZOID instance to the output stream.
     * 
     * If no function input is supplied, output is set to the command line terminal.
     */
    void print(std::ostream &amp; output = std::cout);
    
    /**
     * The friend function is an alternative to the print method.
     * The friend function overloads the ostream operator (i.e. &lt;&lt;).
     * 
     * The friend function is not a member of the TRAPEZOID class,
     * but the friend function does have access to the private and protected members of the TRAPEZOID class as though
     * the friend function was a member of the TRAPEZOID class.
     */
    friend std::ostream &amp; operator &lt;&lt; (std::ostream &amp; output, TRAPEZOID &amp; trapezoid);

    /**
     * The destructor method of the TRAPEZOID class de-allocates memory which was used to 
     * instantiate the TRAPEZOID object which is calling this function.
     * 
     * The destructor method of the TRAPEZOID class is automatically called when 
     * the program scope in which the caller TRAPEZOID object was instantiated terminates.
     */
    ~TRAPEZOID();
};

/* preprocessing directives */
#endif // Terminate the conditional preprocessing directives code block in this header file.
</pre>
<hr />
<p><strong>TRAPEZOID_CLASS_SOURCE_CODE</strong></p>
<hr />
<p>The following source code defines the functions of the TRAPEZOID class.</p>
<p>C++_source_file: <a style="background: #000000;color: #00ff00" href="https://raw.githubusercontent.com/karlinarayberinger/KARLINA_OBJECT_summer_2023_starter_pack/main/trapezoid.cpp" target="_blank" rel="noopener">https://raw.githubusercontent.com/karlinarayberinger/KARLINA_OBJECT_summer_2023_starter_pack/main/trapezoid.cpp</a></p>
<hr />
<pre>/**
 * file: trapezoid.cpp
 * type: C++ (source file)
 * date: 07_JULY_2023
 * author: karbytes
 * license: PUBLIC_DOMAIN
 */

// Include the C++ header file which contains preprocessing directives, variable declarations, and function prototypes for the TRAPEZOID class.
#include "trapezoid.h" 

/**
 * The helper method determines whether or not the caller TRAPEZOID instance represents a
 * quadrilateral with exactly two parallel opposite sides whose lengths are not identical.
 * Return true if the caller TRAPEZOID satisfies those conditions. Otherwise, return false.
 */
bool TRAPEZOID::is_trapezoid()
{
    double a = 0.0, b = 0.0, c = 0.0, d = 0.0;
    double slope_of_a = 0.0, slope_of_b = 0.0, slope_of_c = 0.0, slope_of_d = 0.0;
    double a0 = 0.0, b0 = 0.0, c0 = 0.0;
    double a1 = 0.0, b1 = 0.0, c1 = 0.0;
    double angle_opposite_of_a0 = 0.0, angle_opposite_of_b0 = 0.0, angle_opposite_of_c0 = 0.0; 
    double angle_opposite_of_a1 = 0.0, angle_opposite_of_b1 = 0.0, angle_opposite_of_c1 = 0.0; 
    double interior_angle_of_A = 0.0, interior_angle_of_B = 0.0, interior_angle_of_C = 0.0, interior_angle_of_D = 0.0;
    double sum_of_interior_angles = 0.0;

    // first triangle
    a0 = floor(A.get_distance_from(B));
    b0 = floor(B.get_distance_from(D));
    c0 = floor(D.get_distance_from(A));
    angle_opposite_of_a0 = floor(acos(((b0 * b0) + (c0 * c0) - (a0 * a0)) / (2 * b0 * c0)) * (180 / PI));
    angle_opposite_of_b0 = floor(acos(((a0 * a0) + (c0 * c0) - (b0 * b0)) / (2 * a0 * c0)) * (180 / PI));
    angle_opposite_of_c0 = floor(acos(((a0 * a0) + (b0 * b0) - (c0 * c0)) / (2 * a0 * b0)) * (180 / PI));

    // second triangle
    a1 = floor(D.get_distance_from(B));
    b1 = floor(B.get_distance_from(C));
    c1 = floor(C.get_distance_from(D));
    angle_opposite_of_a1 = floor(acos(((b1 * b1) + (c1 * c1) - (a1 * a1)) / (2 * b1 * c1)) * (180 / PI));
    angle_opposite_of_b1 = floor(acos(((a1 * a1) + (c1 * c1) - (b1 * b1)) / (2 * a1 * c1)) * (180 / PI));
    angle_opposite_of_c1 = floor(acos(((a1 * a1) + (b1 * b1) - (c1 * c1)) / (2 * a1 * b1)) * (180 / PI));

    interior_angle_of_A = angle_opposite_of_b0;
    interior_angle_of_B = angle_opposite_of_c0 + angle_opposite_of_c1;
    interior_angle_of_C = angle_opposite_of_a1;
    interior_angle_of_D = angle_opposite_of_b1 + angle_opposite_of_a0;

    /* sides of quadrilateral */
    a = B.get_distance_from(C);
    b = C.get_distance_from(D);
    c = D.get_distance_from(A);
    d = A.get_distance_from(B);

    /* slope of sides of quadrilateral */
    slope_of_a = B.get_slope_of_line_to(C);
    slope_of_b = C.get_slope_of_line_to(D);
    slope_of_c = D.get_slope_of_line_to(A);
    slope_of_d = A.get_slope_of_line_to(B);

    if (!points_represent_unique_coordinate_pairs(A,B,C,D) || !interior_angles_add_up_to_360_degrees()) return false;
    if ((slope_of_a == slope_of_c) &amp;&amp; (slope_of_b != slope_of_d)) return true;
    if ((slope_of_a != slope_of_c) &amp;&amp; (slope_of_b == slope_of_d)) return true;
    return false;
}

/**
 * The default constructor of the TRAPEZOID class calls the constructor of the QUADRILATERAL class and
 * sets the POINT type data member of the TRAPEZOID object returned by this function named A to POINT(0,0), 
 * sets the POINT type data member of the TRAPEZOID object returned by this function named B to POINT(1,1), 
 * sets the POINT type data member of the TRAPEZOID object returned by this function named C to POINT(2,1), and
 * sets the POINT type data member of the TRAPEZOID object returned by this function named D to POINT(3,0).
 */
TRAPEZOID::TRAPEZOID()
{
    std::cout &lt;&lt; "\n\nCreating the TRAPEZOID type object whose memory address is " &lt;&lt; this &lt;&lt; "...";
    A = POINT(0,0);
    B = POINT(1,1);
    C = POINT(2,1);
    D = POINT(3,0);
}

/**
 * The normal constructor of TRAPEZOID attempts to set
 * the string type data member of this to the input string type value named color and
 * the POINT type data member of this named A to the input POINT type value named A and
 * the POINT type data member of this named B to the input POINT type value named B and
 * the POINT type data member of this named C to the input POINT type value named C and
 * the POINT type data member of this named D to the input POINT type value named D.
 * 
 * (The keyword this refers to the TRAPEZID object which is returned by this function).
 * 
 * If A, B, C, and D represent unique points on a Cartesian plane and
 * if the interior angles of the quadrilateral which those points would represent add up to 360 degrees and
 * if the area of the quadrilateral which those points represents is larger than zero, and
 * if exactly two sides of the quadrilateral are parallel to each other,
 * use the input POINT values as the POINT values for the TRAPEZOID object which is returned by this function.
 */
TRAPEZOID::TRAPEZOID(std::string color, POINT A, POINT B, POINT C, POINT D)
{
    std::cout &lt;&lt; "\n\nCreating the TRAPEZOID type object whose memory address is " &lt;&lt; this &lt;&lt; "...";
    TRAPEZOID test_trapezoid;
    test_trapezoid.A.set_X(A.get_X());
    test_trapezoid.A.set_Y(A.get_Y());
    test_trapezoid.B.set_X(B.get_X());
    test_trapezoid.B.set_Y(B.get_Y());
    test_trapezoid.C.set_X(C.get_X());
    test_trapezoid.C.set_Y(C.get_Y());
    test_trapezoid.D.set_X(D.get_X());
    test_trapezoid.D.set_Y(D.get_Y());
    if (test_trapezoid.is_trapezoid())
    {
        this -&gt; A = A;
        this -&gt; B = B;
        this -&gt; C = C;
        this -&gt; D = D;
    }
    else
    {
        this -&gt; A = POINT(0,0);
        this -&gt; B = POINT(0,5);
        this -&gt; C = POINT(4,5);
        this -&gt; D = POINT(4,0);
    }
    this -&gt; color = color;
}

/**
 * The copy constructor of TRAPEZOID creates a clone of 
 * the input TRAPEZOID instance.
 */
TRAPEZOID::TRAPEZOID(TRAPEZOID &amp; trapezoid)
{
    std::cout &lt;&lt; "\n\nCreating the TRAPEZOID type object whose memory address is " &lt;&lt; this &lt;&lt; "...";
    A = trapezoid.A;
    B = trapezoid.B;
    C = trapezoid.C;
    D = trapezoid.D;
    color = trapezoid.color;
}

/** 
 * This method overrides the QUADRILATERAL class's print method.
 * 
 * The descriptor method prints a description of the caller TRAPEZOID instance to the output stream.
 * 
 * If no function input is supplied, output is set to the command line terminal.
 */
void TRAPEZOID::print(std::ostream &amp; output)
{
    double a0 = 0.0, b0 = 0.0, c0 = 0.0;
    double a1 = 0.0, b1 = 0.0, c1 = 0.0;
    double angle_opposite_of_a0 = 0.0, angle_opposite_of_b0 = 0.0, angle_opposite_of_c0 = 0.0; 
    double angle_opposite_of_a1 = 0.0, angle_opposite_of_b1 = 0.0, angle_opposite_of_c1 = 0.0; 
    double interior_angle_of_A = 0.0, interior_angle_of_B = 0.0, interior_angle_of_C = 0.0, interior_angle_of_D = 0.0;

    // first triangle
    a0 = A.get_distance_from(B);
    b0 = B.get_distance_from(D);
    c0 = D.get_distance_from(A);
    angle_opposite_of_a0 = acos(((b0 * b0) + (c0 * c0) - (a0 * a0)) / (2 * b0 * c0)) * (180 / PI);
    angle_opposite_of_b0 = acos(((a0 * a0) + (c0 * c0) - (b0 * b0)) / (2 * a0 * c0)) * (180 / PI);
    angle_opposite_of_c0 = acos(((a0 * a0) + (b0 * b0) - (c0 * c0)) / (2 * a0 * b0)) * (180 / PI);

    // second triangle
    a1 = D.get_distance_from(B);
    b1 = B.get_distance_from(C);
    c1 = C.get_distance_from(D);
    angle_opposite_of_a1 = acos(((b1 * b1) + (c1 * c1) - (a1 * a1)) / (2 * b1 * c1)) * (180 / PI);
    angle_opposite_of_b1 = acos(((a1 * a1) + (c1 * c1) - (b1 * b1)) / (2 * a1 * c1)) * (180 / PI);
    angle_opposite_of_c1 = acos(((a1 * a1) + (b1 * b1) - (c1 * c1)) / (2 * a1 * b1)) * (180 / PI);

    interior_angle_of_A = angle_opposite_of_b0;
    interior_angle_of_B = angle_opposite_of_c0 + angle_opposite_of_c1;
    interior_angle_of_C = angle_opposite_of_a1;
    interior_angle_of_D = angle_opposite_of_b1 + angle_opposite_of_a0;

    output &lt;&lt; "\n\n--------------------------------------------------------------------------------------------------";
    output &lt;&lt; "\nthis = " &lt;&lt; this &lt;&lt; ". // The keyword named this is a pointer which stores the memory address of the first memory cell of a QUADRILATERAL sized chunk of contiguous memory cells which are allocated to the caller TRIANGLE object.";
    output &lt;&lt; "\n&amp;category = " &lt;&lt; &amp;category &lt;&lt; ". // The reference operation returns the memory address of the first memory cell of a string sized chunk of contiguous memory cells which are allocated to the string data attribute named category.";
    output &lt;&lt; "\n&amp;color = " &lt;&lt; &amp;color &lt;&lt; ". // The reference operation returns the memory address of the first memory cell of a string sized chunk of contiguous memory cells which are allocated to the string data attribute named color..";
    output &lt;&lt; "\n&amp;A = " &lt;&lt; &amp;A &lt;&lt; ". // The reference operation returns the memory address of the first memory cell of a POINT sized chunk of contiguous memory cells which are allocated to the POINT data attribute named A.";
    output &lt;&lt; "\n&amp;B = " &lt;&lt; &amp;B &lt;&lt; ". // The reference operation returns the memory address of the first memory cell of a POINT sized chunk of contiguous memory cells which are allocated to the POINT data attribute named B.";
    output &lt;&lt; "\n&amp;C = " &lt;&lt; &amp;C &lt;&lt; ". // The reference operation returns the memory address of the first memory cell of a POINT sized chunk of contiguous memory cells which are allocated to the POINT data attribute named C.";
    output &lt;&lt; "\n&amp;D = " &lt;&lt; &amp;D &lt;&lt; ". // The reference operation returns the memory address of the first memory cell of a POINT sized chunk of contiguous memory cells which are allocated to the POINT data attribute named D.";
    output &lt;&lt; "\nsizeof(int) = " &lt;&lt; sizeof(int) &lt;&lt; ". // The sizeof() operation returns the nonnegative integer number of bytes of memory which an int type variable occupies. (Each memory cell has a data capacity of 1 byte).";
    output &lt;&lt; "\nsizeof(int *) = " &lt;&lt; sizeof(int *) &lt;&lt; ". // The sizeof() operation returns the nonnegative integer number of bytes of memory which a pointer-to-int type variable occupies. (Each memory cell has a data capacity of 1 byte).";
    output &lt;&lt; "\nsizeof(int **) = " &lt;&lt; sizeof(int **) &lt;&lt; ". // The sizeof() operation returns the nonnegative integer number of bytes of memory which an pointer-to-pointer-to-int type variable occupies. (Each memory cell has a data capacity of 1 byte).";
    output &lt;&lt; "\nsizeof(std::string) = " &lt;&lt; sizeof(std::string) &lt;&lt; ". // The sizeof() operation returns the nonnegative integer number of bytes of memory which a string type variable occupies. (Each memory cell has a data capacity of 1 byte).";
    output &lt;&lt; "\nsizeof(std::string *) = " &lt;&lt; sizeof(std::string *) &lt;&lt; ". // The sizeof() operation returns the nonnegative integer number of bytes of memory which a pointer-to-string type variable occupies. (Each memory cell has a data capacity of 1 byte).";
    output &lt;&lt; "\nsizeof(std::string **) = " &lt;&lt; sizeof(std::string **) &lt;&lt; ". // The sizeof() operation returns the nonnegative integer number of bytes of memory which a pointer-to-pointer-to-string type variable occupies. (Each memory cell has a data capacity of 1 byte).";
    output &lt;&lt; "\nsizeof(POINT) = " &lt;&lt; sizeof(POINT) &lt;&lt; ". // The sizeof() operation returns the nonnegative integer number of bytes of memory which a POINT type object occupies. (Each memory cell has a data capacity of 1 byte).";
    output &lt;&lt; "\nsizeof(POINT *) = " &lt;&lt; sizeof(POINT *) &lt;&lt; ". // The sizeof() operation returns the nonnegative integer number of bytes of memory which a pointer-to-POINT type variable occupies. (Each memory cell has a data capacity of 1 byte).";
    output &lt;&lt; "\nsizeof(POINT **) = " &lt;&lt; sizeof(POINT **) &lt;&lt; ". // The sizeof() operation returns the nonnegative integer number of bytes of memory which a pointer-to-pointer-to-POINT type variable occupies. (Each memory cell has a data capacity of 1 byte).";
    output &lt;&lt; "\nsizeof(POLYGON) = " &lt;&lt; sizeof(POLYGON) &lt;&lt; ". // The sizeof() operation returns the nonnegative integer number of bytes of memory which a POLYGON type object occupies. (Each memory cell has a data capacity of 1 byte).";
    output &lt;&lt; "\nsizeof(POLYGON *) = " &lt;&lt; sizeof(POLYGON *) &lt;&lt; ". // The sizeof() operation returns the nonnegative integer number of bytes of memory which a pointer-to-POLYGON type variable occupies. (Each memory cell has a data capacity of 1 byte).";
    output &lt;&lt; "\nsizeof(POLYGON **) = " &lt;&lt; sizeof(POLYGON **) &lt;&lt; ". // The sizeof() operation returns the nonnegative integer number of bytes of memory which a pointer-to-pointer-to-POLYGON type variable occupies. (Each memory cell has a data capacity of 1 byte).";
    output &lt;&lt; "\nsizeof(QUADRILATERAL) = " &lt;&lt; sizeof(QUADRILATERAL) &lt;&lt; ". // The sizeof() operation returns the nonnegative integer number of bytes of memory which a QUADRILATERAL type object occupies. (Each memory cell has a data capacity of 1 byte).";
    output &lt;&lt; "\nsizeof(QUADRILATERAL *) = " &lt;&lt; sizeof(QUADRILATERAL *) &lt;&lt; ". // The sizeof() operation returns the nonnegative integer number of bytes of memory which a pointer-to-QUADRILATERAL type variable occupies. (Each memory cell has a data capacity of 1 byte).";
    output &lt;&lt; "\nsizeof(QUADRILATERAL **) = " &lt;&lt; sizeof(QUADRILATERAL **) &lt;&lt; ". // The sizeof() operation returns the nonnegative integer number of bytes of memory which a pointer-to-pointer-to-QUADRILATERAL type variable occupies. (Each memory cell has a data capacity of 1 byte).";
    output &lt;&lt; "\nsizeof(TRAPEZOID) = " &lt;&lt; sizeof(TRAPEZOID) &lt;&lt; ". // The sizeof() operation returns the nonnegative integer number of bytes of memory which a TRAPEZOID type object occupies. (Each memory cell has a data capacity of 1 byte).";
    output &lt;&lt; "\nsizeof(TRAPEZOID *) = " &lt;&lt; sizeof(TRAPEZOID *) &lt;&lt; ". // The sizeof() operation returns the nonnegative integer number of bytes of memory which a pointer-to-TRAPEZOID type variable occupies. (Each memory cell has a data capacity of 1 byte).";
    output &lt;&lt; "\nsizeof(TRAPEZOID **) = " &lt;&lt; sizeof(TRAPEZOID **) &lt;&lt; ". // The sizeof() operation returns the nonnegative integer number of bytes of memory which a pointer-to-pointer-to-TRAPEZOID type variable occupies. (Each memory cell has a data capacity of 1 byte).";
    output &lt;&lt; "\ncategory = " &lt;&lt; category &lt;&lt; ". // This is an immutable string type value which is a data member of the caller TRAPEZOID object.";
    output &lt;&lt; "\ncolor = " &lt;&lt; color &lt;&lt; ". // This is a string type value which is a data member of the caller TRAPEZOID object.";
    output &lt;&lt; "\nA = POINT(" &lt;&lt; A.get_X() &lt;&lt; "," &lt;&lt; A.get_Y() &lt;&lt; "). // A represents a point (which is neither B nor C nor D) plotted on a two-dimensional Cartesian grid (such that the X value represents a real whole number position along the horizontal axis of the Cartesian grid while Y represents a real whole number position along the vertical axis of the same Cartesian grid).";
    output &lt;&lt; "\nB = POINT(" &lt;&lt; B.get_X() &lt;&lt; "," &lt;&lt; B.get_Y() &lt;&lt; "). // B represents a point (which is neither A nor C nor D) plotted on a two-dimensional Cartesian grid (such that the X value represents a real whole number position along the horizontal axis of the Cartesian grid while Y represents a real whole number position along the vertical axis of the same Cartesian grid).";
    output &lt;&lt; "\nC = POINT(" &lt;&lt; C.get_X() &lt;&lt; "," &lt;&lt; C.get_Y() &lt;&lt; "). // C represents a point (which is neither A nor B nor D) plotted on a two-dimensional Cartesian grid (such that the X value represents a real whole number position along the horizontal axis of the Cartesian grid while Y represents a real whole number position along the vertical axis of the same Cartesian grid).";
    output &lt;&lt; "\nD = POINT(" &lt;&lt; D.get_X() &lt;&lt; "," &lt;&lt; D.get_Y() &lt;&lt; "). // D represents a point (which is neither A nor B nor C) plotted on a two-dimensional Cartesian grid (such that the X value represents a real whole number position along the horizontal axis of the Cartesian grid while Y represents a real whole number position along the vertical axis of the same Cartesian grid).";
    output &lt;&lt; "\na = B.get_distance_from(C) = " &lt;&lt; B.get_distance_from(C) &lt;&lt; ". // The method returns the approximate nonnegative real number of Cartesian grid unit lengths which span the length of the shortest path between points B and C.";
    output &lt;&lt; "\nb = C.get_distance_from(D) = " &lt;&lt; C.get_distance_from(D) &lt;&lt; ". // The method returns the approximate nonnegative real number of Cartesian grid unit lengths which span the length of the shortest path between points C and D.";
    output &lt;&lt; "\nc = D.get_distance_from(A) = " &lt;&lt; D.get_distance_from(A) &lt;&lt; ". // The method returns the approximate nonnegative real number of Cartesian grid unit lengths which span the length of the shortest path between points D and A.";
    output &lt;&lt; "\nd = A.get_distance_from(B) = " &lt;&lt; A.get_distance_from(B) &lt;&lt; ". // The method returns the approximate nonnegative real number of Cartesian grid unit lengths which span the length of the shortest path between points A and B.";
    output &lt;&lt; "\nA.get_slope_of_line_to(B) = " &lt;&lt; A.get_slope_of_line_to(B) &lt;&lt; ". // The method returns the approximate nonnegative real number which represents the slope of the line which intersects points A and B.";
    output &lt;&lt; "\nB.get_slope_of_line_to(C) = " &lt;&lt; B.get_slope_of_line_to(C) &lt;&lt; ". // The method returns the approximate nonnegative real number which represents the slope of the line which intersects points B and C.";
    output &lt;&lt; "\nC.get_slope_of_line_to(D) = " &lt;&lt; C.get_slope_of_line_to(D) &lt;&lt; ". // The method returns the approximate nonnegative real number which represents the slope of the line which intersects points C and D.";
    output &lt;&lt; "\nD.get_slope_of_line_to(A) = " &lt;&lt; D.get_slope_of_line_to(A) &lt;&lt; ". // The method returns the approximate nonnegative real number which represents the slope of the line which intersects points B and C.";
    output &lt;&lt; "\ninterior_angle_DAB = interior_angle_of_A = " &lt;&lt; interior_angle_of_A &lt;&lt; ". // The value represents the approximate nonnegative real number angle measurement of the acute or else right angle formed by the intersection of the line segment whose endpoints are D and A with the line segment whose endpoints are A and B such that those two line segments intersect at A (and the angle measurement is in degrees and not in radians).";
    output &lt;&lt; "\ninterior_angle_ABC = interior_angle_of_B = " &lt;&lt; interior_angle_of_B &lt;&lt; ". // The method returns the approximate nonnegative real number angle measurement of the acute or else right angle formed by the intersection of the line segment whose endpoints are A and B with the line segment whose endpoints are B and C such that those two line segments intersect at B (and the angle measurement is in degrees and not in radians).";
    output &lt;&lt; "\ninterior_angle_BCD = interior_angle_of_C = " &lt;&lt; interior_angle_of_C &lt;&lt; ". // The method returns the approximate nonnegative real number angle measurement of the acute or else right angle formed by the intersection of the line segment whose endpoints are B and C with the line segment whose endpoints are C and D such that those two line segments intersect at C (and the angle measurement is in degrees and not in radians).";
    output &lt;&lt; "\ninterior_angle_CDA = interior_angle_of_D = " &lt;&lt; interior_angle_of_D &lt;&lt; ". // The method returns the approximate nonnegative real number angle measurement of the acute or else right angle formed by the intersection of the line segment whose endpoints are C and D with the line segment whose endpoints are D and A such that those two line segments intersect at D (and the angle measurement is in degrees and not in radians).";
    output &lt;&lt; "\ninterior_angle_of_A + interior_angle_of_B + interior_angle_of_C + interior_angle_of_D = " &lt;&lt; interior_angle_of_A + interior_angle_of_B + interior_angle_of_C + interior_angle_of_D &lt;&lt; ". // sum of all four approximate interior angle measurements of the quadrilateral represented by the caller QUADRILATERAL object (in degrees and not in radians)";
    output &lt;&lt; "\nget_perimeter() = a + b + c + d = " &lt;&lt; get_perimeter() &lt;&lt; ". // The method returns the sum of the four approximated side lengths of the trapezoid which the caller TRAPEZOID object represents.";
    output &lt;&lt; "\nget_area() = " &lt;&lt; get_area() &lt;&lt; ". // The method returns the approximate nonnegative real number of Cartesian grid unit squares which are enclosed inside of the two-dimensional region formed by the four line segments which connect points A to B, B to C, C to D, and D to A.";
    output &lt;&lt; "\n--------------------------------------------------------------------------------------------------";
}

/**
 * The friend function is an alternative to the print method.
 * The friend function overloads the ostream operator (i.e. &lt;&lt;).
 * 
 * The friend function is not a member of the TRAPEZOID class,
 * but the friend function does have access to the private and protected members of the TRAPEZOID class as though
 * the friend function was a member of the TRAPEZOID class.
 */
std::ostream &amp; operator &lt;&lt; (std::ostream &amp; output, TRAPEZOID &amp; trapezoid)
{
    trapezoid.print(output);
    return output;
}

/**
 * The destructor method of the TRAPEZOID class de-allocates memory which was used to 
 * instantiate the TRAPEZOID object which is calling this function.
 * 
 * The destructor method of the TRAPEZOID class is automatically called when 
 * the program scope in which the caller TRAPEZOID object was instantiated terminates.
 */
TRAPEZOID::~TRAPEZOID()
{
    std::cout &lt;&lt; "\n\nDeleting the TRAPEZOID type object whose memory address is " &lt;&lt; this &lt;&lt; "...";
}
</pre>
<hr />
<p><strong>RECTANGLE_CLASS_HEADER</strong></p>
<hr />
<p>The following header file contains the preprocessing directives and function prototypes of the RECTANGLE class.</p>
<p>C++_header_file: <a style="background: #000000;color: #00ff00" href="https://raw.githubusercontent.com/karlinarayberinger/KARLINA_OBJECT_summer_2023_starter_pack/main/rectangle.h" target="_blank" rel="noopener">https://raw.githubusercontent.com/karlinarayberinger/KARLINA_OBJECT_summer_2023_starter_pack/main/rectangle.h</a></p>
<hr />
<pre>/**
 * file: rectangle.h
 * type: C++ (header file)
 * date: 07_JULY_2023
 * author: karbytes
 * license: PUBLIC_DOMAIN
 */

// If rectangle.h has not already been linked to a source file (.cpp), then link this header file to the source file(s) which include this header file.
#ifndef RECTANGLE_H 
#define RECTANGLE_H

// Include the C++ header file which contains preprocessing directives, variable declarations, and function prototypes for the QUADRILATERAL class.
#include "quadrilateral.h" 

/**
 * RECTANGLE is a class which inherits the protected and public data
 * attributes and methods of QUADRILATERAL.
 * 
 * A RECTANGLE object represents a four-sided polygon such that opposite sides 
 * are the same length and each interior angle measurement of that quadrilateral 
 * is 90 degrees.
 * 
 * Class members which are set to the protected access specifier
 * are accessible to the base class and to derived classes.
 * 
 * Class members which are set to the private access specifier
 * are only accessible to the base class.
 * 
 * Class members which are set to the public access specifier
 * are accessible to any scope within the program where
 * the base class and its derived classes are implemented.
 */
class RECTANGLE: public QUADRILATERAL
{
protected:

    /**
     * category is a description of the POLYGON instance.
     * category is set to a const (i.e. const (i.e. immutable)) value.
     */
    const std::string category = "POLYGON/QUADRILATERAL/RECTANGLE";

    /**
     * The helper method determines whether or not the caller RECTANGLE instance represents a
     * quadrilateral such that opposite sides are the same length and each interior angle 
     * measurement of that quadrilateral is 90 degrees.
     * Return true if the caller RECTANGLE satisfies those conditions. Otherwise, return false.
     */
    bool is_rectangle();
    
public:

    /**
     * The test function helps to illustrate how pointers work.
     */
    int rectangle_test(); // return 666
    
    /**
     * The default constructor of the RECTANGLE class calls the constructor of the QUADRILATERAL class and
     * sets the POINT type data member of the RECTANGLE object returned by this function named A to POINT(0,0), 
     * sets the POINT type data member of the RECTANGLE object returned by this function named B to POINT(0,3), 
     * sets the POINT type data member of the RECTANGLE object returned by this function named C to POINT(4,3), and
     * sets the POINT type data member of the RECTANGLE object returned by this function named D to POINT(4,0).
     */
    RECTANGLE();

    /**
     * The normal constructor of RECTANGLE attempts to set
     * the string type data member of this to the input string type value named color and
     * the POINT type data member of this named A to the input POINT type value named A and
     * the POINT type data member of this named B to the input POINT type value named B and
     * the POINT type data member of this named C to the input POINT type value named C and
     * the POINT type data member of this named D to the input POINT type value named D.
     * 
     * (The keyword this refers to the RECTANGLE object which is returned by this function).
     * 
     * If A, B, C, and D represent unique points on a Cartesian plane and
     * if the interior angles of the quadrilateral which those points would represent add up to 360 degrees and
     * if the area of the quadrilateral which those points represents is larger than zero, and
     * if each interior angle of that quadrilateral has an angle measurement of 90 degrees,
     * use the input POINT values as the POINT values for the RECTANGLE object which is returned by this function.
     */
    RECTANGLE(std::string color, POINT A, POINT B, POINT C, POINT D);
    
    /**
     * The copy constructor of RECTANGLE creates a clone of 
     * the input RECTANGLE instance.
     */
    RECTANGLE(RECTANGLE &amp; rectangle);
    
    /** 
     * This method overrides the QUADRILATERAL class's print method.
     * 
     * The descriptor method prints a description of the caller RECTANGLE instance to the output stream.
     * 
     * If no function input is supplied, output is set to the command line terminal.
     */
    void print(std::ostream &amp; output = std::cout);
    
    /**
     * The friend function is an alternative to the print method.
     * The friend function overloads the ostream operator (i.e. &lt;&lt;).
     * 
     * The friend function is not a member of the RECTANGLE class,
     * but the friend function does have access to the private and protected members of the RECTANGLE class as though
     * the friend function was a member of the RECTANGLE class.
     */
    friend std::ostream &amp; operator &lt;&lt; (std::ostream &amp; output, RECTANGLE &amp; rectangle);

    /**
     * The destructor method of the RECTANGLE class de-allocates memory which was used to 
     * instantiate the RECTANGLE object which is calling this function.
     * 
     * The destructor method of the RECTANGLE class is automatically called when 
     * the program scope in which the caller RECTANGLE object was instantiated terminates.
     */
    ~RECTANGLE();
};

/* preprocessing directives */
#endif // Terminate the conditional preprocessing directives code block in this header file.
</pre>
<hr />
<p><strong>RECTANGLE_CLASS_SOURCE_CODE</strong></p>
<hr />
<p>The following source code defines the functions of the RECTANGLE class.</p>
<p>C++_source_file: <a style="background: #000000;color: #00ff00" href="https://raw.githubusercontent.com/karlinarayberinger/KARLINA_OBJECT_summer_2023_starter_pack/main/rectangle.cpp" target="_blank" rel="noopener">https://raw.githubusercontent.com/karlinarayberinger/KARLINA_OBJECT_summer_2023_starter_pack/main/rectangle.cpp</a></p>
<hr />
<pre>/**
 * file: rectangle.cpp
 * type: C++ (source file)
 * date: 07_JULY_2023
 * author: karbytes
 * license: PUBLIC_DOMAIN
 */

// Include the C++ header file which contains preprocessing directives, variable declarations, and function prototypes for the RECTANGLE class.
#include "rectangle.h" 

/**
 * The helper method determines whether or not the caller RECTANGLE instance represents a
 * quadrilateral such that opposite sides are the same length and each interior angle 
 * measurement of that quadrilateral is 90 degrees.
 * Return true if the caller RECTANGLE satisfies those conditions. Otherwise, return false.
 */
bool RECTANGLE::is_rectangle()
{
    double a = 0.0, b = 0.0, c = 0.0, d = 0.0;
    double a0 = 0.0, b0 = 0.0, c0 = 0.0;
    double a1 = 0.0, b1 = 0.0, c1 = 0.0;
    double angle_opposite_of_a0 = 0.0, angle_opposite_of_b0 = 0.0, angle_opposite_of_c0 = 0.0; 
    double angle_opposite_of_a1 = 0.0, angle_opposite_of_b1 = 0.0, angle_opposite_of_c1 = 0.0; 
    double interior_angle_of_A = 0.0, interior_angle_of_B = 0.0, interior_angle_of_C = 0.0, interior_angle_of_D = 0.0;

    // first triangle
    a0 = A.get_distance_from(B);
    b0 = B.get_distance_from(D);
    c0 = D.get_distance_from(A);
    angle_opposite_of_a0 = acos(((b0 * b0) + (c0 * c0) - (a0 * a0)) / (2 * b0 * c0)) * (180 / PI);
    angle_opposite_of_b0 = acos(((a0 * a0) + (c0 * c0) - (b0 * b0)) / (2 * a0 * c0)) * (180 / PI);
    angle_opposite_of_c0 = acos(((a0 * a0) + (b0 * b0) - (c0 * c0)) / (2 * a0 * b0)) * (180 / PI);

    // second triangle
    a1 = D.get_distance_from(B);
    b1 = B.get_distance_from(C);
    c1 = C.get_distance_from(D);
    angle_opposite_of_a1 = acos(((b1 * b1) + (c1 * c1) - (a1 * a1)) / (2 * b1 * c1)) * (180 / PI);
    angle_opposite_of_b1 = acos(((a1 * a1) + (c1 * c1) - (b1 * b1)) / (2 * a1 * c1)) * (180 / PI);
    angle_opposite_of_c1 = acos(((a1 * a1) + (b1 * b1) - (c1 * c1)) / (2 * a1 * b1)) * (180 / PI);

    interior_angle_of_A = angle_opposite_of_b0;
    interior_angle_of_B = angle_opposite_of_c0 + angle_opposite_of_c1;
    interior_angle_of_C = angle_opposite_of_a1;
    interior_angle_of_D = angle_opposite_of_b1 + angle_opposite_of_a0;

    /* sides of quadrilateral */
    a = B.get_distance_from(C);
    b = C.get_distance_from(D);
    c = D.get_distance_from(A);
    d = A.get_distance_from(B);

    if (!points_represent_unique_coordinate_pairs(A,B,C,D) || !interior_angles_add_up_to_360_degrees()) return false;

    // Determine whether or not exactly one pair of opposite sides of the quadrilateral are parallel to each other.
    if ((a == c) &amp;&amp; (b == d))
    {
        if (!floor(interior_angle_of_A) == 90) return false;
        if (!floor(interior_angle_of_B) == 90) return false;
        if (!floor(interior_angle_of_C) == 90) return false;
        if (!floor(interior_angle_of_C) == 90) return false;
        return true;
    }
    return false;
}

/**
 * The test function helps to illustrate how pointers work.
 */
int RECTANGLE::rectangle_test()
{
    return 666;
}

/**
 * The default constructor of the RECTANGLE class calls the constructor of the QUADRILATERAL class and
 * sets the POINT type data member of the RECTANGLE object returned by this function named A to POINT(0,0), 
 * sets the POINT type data member of the RECTANGLE object returned by this function named B to POINT(0,3), 
 * sets the POINT type data member of the RECTANGLE object returned by this function named C to POINT(4,3), and
 * sets the POINT type data member of the RECTANGLE object returned by this function named D to POINT(4,0).
 */
RECTANGLE::RECTANGLE()
{
    std::cout &lt;&lt; "\n\nCreating the RECTANGLE type object whose memory address is " &lt;&lt; this &lt;&lt; "...";
    A = POINT(0,0);
    B = POINT(0,3);
    C = POINT(4,3);
    D = POINT(4,0);
}

/**
 * The normal constructor of RECTANGLE attempts to set
 * the string type data member of this to the input string type value named color and
 * the POINT type data member of this named A to the input POINT type value named A and
 * the POINT type data member of this named B to the input POINT type value named B and
 * the POINT type data member of this named C to the input POINT type value named C and
 * the POINT type data member of this named D to the input POINT type value named D.
 * 
 * (The keyword this refers to the RECTANGLE object which is returned by this function).
 * 
 * If A, B, C, and D represent unique points on a Cartesian plane and
 * if the interior angles of the quadrilateral which those points would represent add up to 360 degrees and
 * if the area of the quadrilateral which those points represents is larger than zero, and
 * if each interior angle of that quadrilateral has an angle measurement of 90 degrees,
 * use the input POINT values as the POINT values for the RECTANGLE object which is returned by this function.
 */
RECTANGLE::RECTANGLE(std::string color, POINT A, POINT B, POINT C, POINT D)
{
    std::cout &lt;&lt; "\n\nCreating the RECTANGLE type object whose memory address is " &lt;&lt; this &lt;&lt; "...";
    RECTANGLE test_rectangle;
    test_rectangle.A.set_X(A.get_X());
    test_rectangle.A.set_Y(A.get_Y());
    test_rectangle.B.set_X(B.get_X());
    test_rectangle.B.set_Y(B.get_Y());
    test_rectangle.C.set_X(C.get_X());
    test_rectangle.C.set_Y(C.get_Y());
    test_rectangle.D.set_X(D.get_X());
    test_rectangle.D.set_Y(D.get_Y());
    if (test_rectangle.is_rectangle())
    {
        this -&gt; A = A;
        this -&gt; B = B;
        this -&gt; C = C;
        this -&gt; D = D;
    }
    else
    {
        this -&gt; A = POINT(0,0);
        this -&gt; B = POINT(0,3);
        this -&gt; C = POINT(4,3);
        this -&gt; D = POINT(4,0);
    }
    this -&gt; color = color;
}
    
/**
 * The copy constructor of RECTANGLE creates a clone of 
 * the input RECTANGLE instance.
 */
RECTANGLE::RECTANGLE(RECTANGLE &amp; rectangle)
{
    std::cout &lt;&lt; "\n\nCreating the RECTANGLE type object whose memory address is " &lt;&lt; this &lt;&lt; "...";
    A = rectangle.A;
    B = rectangle.B;
    C = rectangle.C;
    D = rectangle.D;
    color = rectangle.color;
}
    
/** 
 * This method overrides the QUADRILATERAL class's print method.
 * 
 * The descriptor method prints a description of the caller RECTANGLE instance to the output stream.
 * 
 * If no function input is supplied, output is set to the command line terminal.
 */
void RECTANGLE::print(std::ostream &amp; output)
{
    double a0 = 0.0, b0 = 0.0, c0 = 0.0;
    double a1 = 0.0, b1 = 0.0, c1 = 0.0;
    double angle_opposite_of_a0 = 0.0, angle_opposite_of_b0 = 0.0, angle_opposite_of_c0 = 0.0; 
    double angle_opposite_of_a1 = 0.0, angle_opposite_of_b1 = 0.0, angle_opposite_of_c1 = 0.0; 
    double interior_angle_of_A = 0.0, interior_angle_of_B = 0.0, interior_angle_of_C = 0.0, interior_angle_of_D = 0.0;

    // first triangle
    a0 = A.get_distance_from(B);
    b0 = B.get_distance_from(D);
    c0 = D.get_distance_from(A);
    angle_opposite_of_a0 = acos(((b0 * b0) + (c0 * c0) - (a0 * a0)) / (2 * b0 * c0)) * (180 / PI);
    angle_opposite_of_b0 = acos(((a0 * a0) + (c0 * c0) - (b0 * b0)) / (2 * a0 * c0)) * (180 / PI);
    angle_opposite_of_c0 = acos(((a0 * a0) + (b0 * b0) - (c0 * c0)) / (2 * a0 * b0)) * (180 / PI);

    // second triangle
    a1 = D.get_distance_from(B);
    b1 = B.get_distance_from(C);
    c1 = C.get_distance_from(D);
    angle_opposite_of_a1 = acos(((b1 * b1) + (c1 * c1) - (a1 * a1)) / (2 * b1 * c1)) * (180 / PI);
    angle_opposite_of_b1 = acos(((a1 * a1) + (c1 * c1) - (b1 * b1)) / (2 * a1 * c1)) * (180 / PI);
    angle_opposite_of_c1 = acos(((a1 * a1) + (b1 * b1) - (c1 * c1)) / (2 * a1 * b1)) * (180 / PI);

    interior_angle_of_A = angle_opposite_of_b0;
    interior_angle_of_B = angle_opposite_of_c0 + angle_opposite_of_c1;
    interior_angle_of_C = angle_opposite_of_a1;
    interior_angle_of_D = angle_opposite_of_b1 + angle_opposite_of_a0;

    output &lt;&lt; "\n\n--------------------------------------------------------------------------------------------------";
    output &lt;&lt; "\nthis = " &lt;&lt; this &lt;&lt; ". // The keyword named this is a pointer which stores the memory address of the first memory cell of a QUADRILATERAL sized chunk of contiguous memory cells which are allocated to the caller TRIANGLE object.";
    output &lt;&lt; "\n&amp;category = " &lt;&lt; &amp;category &lt;&lt; ". // The reference operation returns the memory address of the first memory cell of a string sized chunk of contiguous memory cells which are allocated to the string data attribute named category.";
    output &lt;&lt; "\n&amp;color = " &lt;&lt; &amp;color &lt;&lt; ". // The reference operation returns the memory address of the first memory cell of a string sized chunk of contiguous memory cells which are allocated to the string data attribute named color..";
    output &lt;&lt; "\n&amp;A = " &lt;&lt; &amp;A &lt;&lt; ". // The reference operation returns the memory address of the first memory cell of a POINT sized chunk of contiguous memory cells which are allocated to the POINT data attribute named A.";
    output &lt;&lt; "\n&amp;B = " &lt;&lt; &amp;B &lt;&lt; ". // The reference operation returns the memory address of the first memory cell of a POINT sized chunk of contiguous memory cells which are allocated to the POINT data attribute named B.";
    output &lt;&lt; "\n&amp;C = " &lt;&lt; &amp;C &lt;&lt; ". // The reference operation returns the memory address of the first memory cell of a POINT sized chunk of contiguous memory cells which are allocated to the POINT data attribute named C.";
    output &lt;&lt; "\n&amp;D = " &lt;&lt; &amp;D &lt;&lt; ". // The reference operation returns the memory address of the first memory cell of a POINT sized chunk of contiguous memory cells which are allocated to the POINT data attribute named D.";
    output &lt;&lt; "\nsizeof(int) = " &lt;&lt; sizeof(int) &lt;&lt; ". // The sizeof() operation returns the nonnegative integer number of bytes of memory which an int type variable occupies. (Each memory cell has a data capacity of 1 byte).";
    output &lt;&lt; "\nsizeof(int *) = " &lt;&lt; sizeof(int *) &lt;&lt; ". // The sizeof() operation returns the nonnegative integer number of bytes of memory which a pointer-to-int type variable occupies. (Each memory cell has a data capacity of 1 byte).";
    output &lt;&lt; "\nsizeof(int **) = " &lt;&lt; sizeof(int **) &lt;&lt; ". // The sizeof() operation returns the nonnegative integer number of bytes of memory which an pointer-to-pointer-to-int type variable occupies. (Each memory cell has a data capacity of 1 byte).";
    output &lt;&lt; "\nsizeof(std::string) = " &lt;&lt; sizeof(std::string) &lt;&lt; ". // The sizeof() operation returns the nonnegative integer number of bytes of memory which a string type variable occupies. (Each memory cell has a data capacity of 1 byte).";
    output &lt;&lt; "\nsizeof(std::string *) = " &lt;&lt; sizeof(std::string *) &lt;&lt; ". // The sizeof() operation returns the nonnegative integer number of bytes of memory which a pointer-to-string type variable occupies. (Each memory cell has a data capacity of 1 byte).";
    output &lt;&lt; "\nsizeof(std::string **) = " &lt;&lt; sizeof(std::string **) &lt;&lt; ". // The sizeof() operation returns the nonnegative integer number of bytes of memory which a pointer-to-pointer-to-string type variable occupies. (Each memory cell has a data capacity of 1 byte).";
    output &lt;&lt; "\nsizeof(POINT) = " &lt;&lt; sizeof(POINT) &lt;&lt; ". // The sizeof() operation returns the nonnegative integer number of bytes of memory which a POINT type object occupies. (Each memory cell has a data capacity of 1 byte).";
    output &lt;&lt; "\nsizeof(POINT *) = " &lt;&lt; sizeof(POINT *) &lt;&lt; ". // The sizeof() operation returns the nonnegative integer number of bytes of memory which a pointer-to-POINT type variable occupies. (Each memory cell has a data capacity of 1 byte).";
    output &lt;&lt; "\nsizeof(POINT **) = " &lt;&lt; sizeof(POINT **) &lt;&lt; ". // The sizeof() operation returns the nonnegative integer number of bytes of memory which a pointer-to-pointer-to-POINT type variable occupies. (Each memory cell has a data capacity of 1 byte).";
    output &lt;&lt; "\nsizeof(POLYGON) = " &lt;&lt; sizeof(POLYGON) &lt;&lt; ". // The sizeof() operation returns the nonnegative integer number of bytes of memory which a POLYGON type object occupies. (Each memory cell has a data capacity of 1 byte).";
    output &lt;&lt; "\nsizeof(POLYGON *) = " &lt;&lt; sizeof(POLYGON *) &lt;&lt; ". // The sizeof() operation returns the nonnegative integer number of bytes of memory which a pointer-to-POLYGON type variable occupies. (Each memory cell has a data capacity of 1 byte).";
    output &lt;&lt; "\nsizeof(POLYGON **) = " &lt;&lt; sizeof(POLYGON **) &lt;&lt; ". // The sizeof() operation returns the nonnegative integer number of bytes of memory which a pointer-to-pointer-to-POLYGON type variable occupies. (Each memory cell has a data capacity of 1 byte).";
    output &lt;&lt; "\nsizeof(QUADRILATERAL) = " &lt;&lt; sizeof(QUADRILATERAL) &lt;&lt; ". // The sizeof() operation returns the nonnegative integer number of bytes of memory which a QUADRILATERAL type object occupies. (Each memory cell has a data capacity of 1 byte).";
    output &lt;&lt; "\nsizeof(QUADRILATERAL *) = " &lt;&lt; sizeof(QUADRILATERAL *) &lt;&lt; ". // The sizeof() operation returns the nonnegative integer number of bytes of memory which a pointer-to-QUADRILATERAL type variable occupies. (Each memory cell has a data capacity of 1 byte).";
    output &lt;&lt; "\nsizeof(QUADRILATERAL **) = " &lt;&lt; sizeof(QUADRILATERAL **) &lt;&lt; ". // The sizeof() operation returns the nonnegative integer number of bytes of memory which a pointer-to-pointer-to-QUADRILATERAL type variable occupies. (Each memory cell has a data capacity of 1 byte).";
    output &lt;&lt; "\nsizeof(RECTANGLE) = " &lt;&lt; sizeof(RECTANGLE) &lt;&lt; ". // The sizeof() operation returns the nonnegative integer number of bytes of memory which a RECTANGLE type object occupies. (Each memory cell has a data capacity of 1 byte).";
    output &lt;&lt; "\nsizeof(RECTANGLE *) = " &lt;&lt; sizeof(RECTANGLE *) &lt;&lt; ". // The sizeof() operation returns the nonnegative integer number of bytes of memory which a pointer-to-RECTANGLE type variable occupies. (Each memory cell has a data capacity of 1 byte).";
    output &lt;&lt; "\nsizeof(RECTANGLE **) = " &lt;&lt; sizeof(RECTANGLE **) &lt;&lt; ". // The sizeof() operation returns the nonnegative integer number of bytes of memory which a pointer-to-pointer-to-RECTANGLE type variable occupies. (Each memory cell has a data capacity of 1 byte).";
    output &lt;&lt; "\ncategory = " &lt;&lt; category &lt;&lt; ". // This is an immutable string type value which is a data member of the caller RECTANGLE object.";
    output &lt;&lt; "\ncolor = " &lt;&lt; color &lt;&lt; ". // This is a string type value which is a data member of the caller RECTANGLE object.";
    output &lt;&lt; "\nA = POINT(" &lt;&lt; A.get_X() &lt;&lt; "," &lt;&lt; A.get_Y() &lt;&lt; "). // A represents a point (which is neither B nor C nor D) plotted on a two-dimensional Cartesian grid (such that the X value represents a real whole number position along the horizontal axis of the Cartesian grid while Y represents a real whole number position along the vertical axis of the same Cartesian grid).";
    output &lt;&lt; "\nB = POINT(" &lt;&lt; B.get_X() &lt;&lt; "," &lt;&lt; B.get_Y() &lt;&lt; "). // B represents a point (which is neither A nor C nor D) plotted on a two-dimensional Cartesian grid (such that the X value represents a real whole number position along the horizontal axis of the Cartesian grid while Y represents a real whole number position along the vertical axis of the same Cartesian grid).";
    output &lt;&lt; "\nC = POINT(" &lt;&lt; C.get_X() &lt;&lt; "," &lt;&lt; C.get_Y() &lt;&lt; "). // C represents a point (which is neither A nor B nor D) plotted on a two-dimensional Cartesian grid (such that the X value represents a real whole number position along the horizontal axis of the Cartesian grid while Y represents a real whole number position along the vertical axis of the same Cartesian grid).";
    output &lt;&lt; "\nD = POINT(" &lt;&lt; D.get_X() &lt;&lt; "," &lt;&lt; D.get_Y() &lt;&lt; "). // D represents a point (which is neither A nor B nor C) plotted on a two-dimensional Cartesian grid (such that the X value represents a real whole number position along the horizontal axis of the Cartesian grid while Y represents a real whole number position along the vertical axis of the same Cartesian grid).";
    output &lt;&lt; "\na = B.get_distance_from(C) = " &lt;&lt; B.get_distance_from(C) &lt;&lt; ". // The method returns the approximate nonnegative real number of Cartesian grid unit lengths which span the length of the shortest path between points B and C.";
    output &lt;&lt; "\nb = C.get_distance_from(D) = " &lt;&lt; C.get_distance_from(D) &lt;&lt; ". // The method returns the approximate nonnegative real number of Cartesian grid unit lengths which span the length of the shortest path between points C and D.";
    output &lt;&lt; "\nc = D.get_distance_from(A) = " &lt;&lt; D.get_distance_from(A) &lt;&lt; ". // The method returns the approximate nonnegative real number of Cartesian grid unit lengths which span the length of the shortest path between points D and A.";
    output &lt;&lt; "\nd = A.get_distance_from(B) = " &lt;&lt; A.get_distance_from(B) &lt;&lt; ". // The method returns the approximate nonnegative real number of Cartesian grid unit lengths which span the length of the shortest path between points A and B.";
    output &lt;&lt; "\nA.get_slope_of_line_to(B) = " &lt;&lt; A.get_slope_of_line_to(B) &lt;&lt; ". // The method returns the approximate nonnegative real number which represents the slope of the line which intersects points A and B.";
    output &lt;&lt; "\nB.get_slope_of_line_to(C) = " &lt;&lt; B.get_slope_of_line_to(C) &lt;&lt; ". // The method returns the approximate nonnegative real number which represents the slope of the line which intersects points B and C.";
    output &lt;&lt; "\nC.get_slope_of_line_to(D) = " &lt;&lt; C.get_slope_of_line_to(D) &lt;&lt; ". // The method returns the approximate nonnegative real number which represents the slope of the line which intersects points C and D.";
    output &lt;&lt; "\nD.get_slope_of_line_to(A) = " &lt;&lt; D.get_slope_of_line_to(A) &lt;&lt; ". // The method returns the approximate nonnegative real number which represents the slope of the line which intersects points B and C.";
    output &lt;&lt; "\ninterior_angle_DAB = interior_angle_of_A = " &lt;&lt; interior_angle_of_A &lt;&lt; ". // The value represents the approximate nonnegative real number angle measurement of the acute or else right angle formed by the intersection of the line segment whose endpoints are D and A with the line segment whose endpoints are A and B such that those two line segments intersect at A (and the angle measurement is in degrees and not in radians).";
    output &lt;&lt; "\ninterior_angle_ABC = interior_angle_of_B = " &lt;&lt; interior_angle_of_B &lt;&lt; ". // The method returns the approximate nonnegative real number angle measurement of the acute or else right angle formed by the intersection of the line segment whose endpoints are A and B with the line segment whose endpoints are B and C such that those two line segments intersect at B (and the angle measurement is in degrees and not in radians).";
    output &lt;&lt; "\ninterior_angle_BCD = interior_angle_of_C = " &lt;&lt; interior_angle_of_C &lt;&lt; ". // The method returns the approximate nonnegative real number angle measurement of the acute or else right angle formed by the intersection of the line segment whose endpoints are B and C with the line segment whose endpoints are C and D such that those two line segments intersect at C (and the angle measurement is in degrees and not in radians).";
    output &lt;&lt; "\ninterior_angle_CDA = interior_angle_of_D = " &lt;&lt; interior_angle_of_D &lt;&lt; ". // The method returns the approximate nonnegative real number angle measurement of the acute or else right angle formed by the intersection of the line segment whose endpoints are C and D with the line segment whose endpoints are D and A such that those two line segments intersect at D (and the angle measurement is in degrees and not in radians).";
    output &lt;&lt; "\ninterior_angle_of_A + interior_angle_of_B + interior_angle_of_C + interior_angle_of_D = " &lt;&lt; interior_angle_of_A + interior_angle_of_B + interior_angle_of_C + interior_angle_of_D &lt;&lt; ". // sum of all four approximate interior angle measurements of the quadrilateral represented by the caller QUADRILATERAL object (in degrees and not in radians)";
    output &lt;&lt; "\nget_perimeter() = a + b + c + d = " &lt;&lt; get_perimeter() &lt;&lt; ". // The method returns the sum of the four approximated side lengths of the rectangle which the caller RECTANGLE object represents.";
    output &lt;&lt; "\nget_area() = " &lt;&lt; get_area() &lt;&lt; ". // The method returns the approximate nonnegative real number of Cartesian grid unit squares which are enclosed inside of the two-dimensional region formed by the four line segments which connect points A to B, B to C, C to D, and D to A.";
    output &lt;&lt; "\n--------------------------------------------------------------------------------------------------";
}
    
/**
 * The friend function is an alternative to the print method.
 * The friend function overloads the ostream operator (i.e. &lt;&lt;).
 * 
 * The friend function is not a member of the RECTANGLE class,
 * but the friend function does have access to the private and protected members of the RECTANGLE class as though
 * the friend function was a member of the RECTANGLE class.
 */
std::ostream &amp; operator &lt;&lt; (std::ostream &amp; output, RECTANGLE &amp; rectangle)
{
    rectangle.print(output);
    return output;
}

/**
 * The destructor method of the RECTANGLE class de-allocates memory which was used to 
 * instantiate the RECTANGLE object which is calling this function.
 * 
 * The destructor method of the RECTANGLE class is automatically called when 
 * the program scope in which the caller RECTANGLE object was instantiated terminates.
 */
RECTANGLE::~RECTANGLE()
{
    std::cout &lt;&lt; "\n\nDeleting the RECTANGLE type object whose memory address is " &lt;&lt; this &lt;&lt; "...";
}</pre>
<hr />
<p><strong>SQUARE_CLASS_HEADER</strong></p>
<hr />
<p>The following header file contains the preprocessing directives and function prototypes of the SQUARE class.</p>
<p>C++_header_file: <a style="background: #000000;color: #00ff00" href="https://raw.githubusercontent.com/karlinarayberinger/KARLINA_OBJECT_summer_2023_starter_pack/main/square.h" target="_blank" rel="noopener">https://raw.githubusercontent.com/karlinarayberinger/KARLINA_OBJECT_summer_2023_starter_pack/main/square.h</a></p>
<hr />
<pre>/**
 * file: square.h
 * type: C++ (header file)
 * date: 07_JULY_2023
 * author: karbytes
 * license: PUBLIC_DOMAIN
 */

// If square.h has not already been linked to a source file (.cpp), then link this header file to the source file(s) which include this header file.
#ifndef SQUARE_H 
#define SQUARE_H

// Include the C++ header file which contains preprocessing directives, variable declarations, and function prototypes for the RECTANGLE class.
#include "rectangle.h" 

/**
 * SQUARE is a class which inherits the protected and public data
 * attributes and methods of RECTANGLE.
 * 
 * A SQUARE object represents a four-sided polygon such that each side of that
 * quadrilateral is the same length and each interior angle measurement of that 
 * quadrilateral is 90 degrees.
 * 
 * Class members which are set to the protected access specifier
 * are accessible to the base class and to derived classes.
 * 
 * Class members which are set to the private access specifier
 * are only accessible to the base class.
 * 
 * Class members which are set to the public access specifier
 * are accessible to any scope within the program where
 * the base class and its derived classes are implemented.
 */
class SQUARE: public RECTANGLE
{
protected:

    /**
     * category is a description of the POLYGON instance.
     * category is set to a const (i.e. const (i.e. immutable)) value.
     */
    const std::string category = "POLYGON/QUADRILATERAL/RECTANGLE/SQUARE";

    /**
     * The helper method determines whether or not the caller SQUARE instance represents a
     * quadrilateral such that each side is the same length and each interior angle measurement of that is 90 degrees.
     * Return true if the caller SQUARE satisfies those conditions. Otherwise, return false.
     */
    bool is_square();
    
public:
    
    /**
     * The default constructor of the SQUARE class calls the constructor of the RECTANGLE class and
     * sets the POINT type data member of the SQUARE object returned by this function named A to POINT(0,0), 
     * sets the POINT type data member of the SQUARE object returned by this function named B to POINT(0,5), 
     * sets the POINT type data member of the SQUARE object returned by this function named C to POINT(5,5), and
     * sets the POINT type data member of the SQUARE object returned by this function named D to POINT(5,0).
     */
    SQUARE();

    /**
     * The normal constructor of SQUARE attempts to set
     * the string type data member of this to the input string type value named color and
     * the POINT type data member of this named A to the input POINT type value named A and
     * the POINT type data member of this named B to the input POINT type value named B and
     * the POINT type data member of this named C to the input POINT type value named C and
     * the POINT type data member of this named D to the input POINT type value named D.
     * 
     * (The keyword this refers to the SQUARE object which is returned by this function).
     * 
     * If A, B, C, and D represent unique points on a Cartesian plane and
     * if the interior angles of the quadrilateral which those points would represent add up to 360 degrees and
     * if the area of the quadrilateral which those points represents is larger than zero,
     * if each interior angle of that quadrilateral has an angle measurement of 90 degrees, and
     * if each side of that quadrilateral has the same length,
     * use the input POINT values as the POINT values for the SQUARE object which is returned by this function.
     */
    SQUARE(std::string color, POINT A, POINT B, POINT C, POINT D);
    
    /**
     * The copy constructor of SQUARE creates a clone of 
     * the input SQUARE instance.
     */
    SQUARE(SQUARE &amp; square);
    
    /** 
     * This method overrides the RECTANGLE class's print method.
     * 
     * The descriptor method prints a description of the caller SQUARE instance to the output stream.
     * 
     * If no function input is supplied, output is set to the command line terminal.
     */
    void print(std::ostream &amp; output = std::cout);
    
    /**
     * The friend function is an alternative to the print method.
     * The friend function overloads the ostream operator (i.e. &lt;&lt;).
     * 
     * The friend function is not a member of the SQUARE class,
     * but the friend function does have access to the private and protected members of the SQUARE class as though
     * the friend function was a member of the SQUARE class.
     */
    friend std::ostream &amp; operator &lt;&lt; (std::ostream &amp; output, SQUARE &amp; square);

    /**
     * The destructor method of the SQUARE class de-allocates memory which was used to 
     * instantiate the SQUARE object which is calling this function.
     * 
     * The destructor method of the SQUARE class is automatically called when 
     * the program scope in which the caller SQUARE object was instantiated terminates.
     */
    ~SQUARE();
};

/* preprocessing directives */
#endif // Terminate the conditional preprocessing directives code block in this header file.
</pre>
<hr />
<p><strong>SQUARE_CLASS_SOURCE_CODE</strong></p>
<hr />
<p>The following source code defines the functions of the SQUARE class.</p>
<p>C++_source_file: <a style="background: #000000;color: #00ff00" href="https://raw.githubusercontent.com/karlinarayberinger/KARLINA_OBJECT_summer_2023_starter_pack/main/square.cpp" target="_blank" rel="noopener">https://raw.githubusercontent.com/karlinarayberinger/KARLINA_OBJECT_summer_2023_starter_pack/main/square.cpp</a></p>
<hr />
<pre>/**
 * file: square.cpp
 * type: C++ (source file)
 * date: 07_JULY_2023
 * author: karbytes
 * license: PUBLIC_DOMAIN
 */

// Include the C++ header file which contains preprocessing directives, variable declarations, and function prototypes for the SQUARE class.
#include "square.h" 

/**
 * The helper method determines whether or not the caller SQUARE instance represents a
 * quadrilateral such that each side is the same length and each interior angle measurement of that is 90 degrees.
 * Return true if the caller SQUARE satisfies those conditions. Otherwise, return false.
 */
bool SQUARE::is_square()
{
    double a = 0.0, b = 0.0, c = 0.0, d = 0.0;
    double a0 = 0.0, b0 = 0.0, c0 = 0.0;
    double a1 = 0.0, b1 = 0.0, c1 = 0.0;
    double angle_opposite_of_a0 = 0.0, angle_opposite_of_b0 = 0.0, angle_opposite_of_c0 = 0.0; 
    double angle_opposite_of_a1 = 0.0, angle_opposite_of_b1 = 0.0, angle_opposite_of_c1 = 0.0; 
    double interior_angle_of_A = 0.0, interior_angle_of_B = 0.0, interior_angle_of_C = 0.0, interior_angle_of_D = 0.0;

    // first triangle
    a0 = A.get_distance_from(B);
    b0 = B.get_distance_from(D);
    c0 = D.get_distance_from(A);
    angle_opposite_of_a0 = acos(((b0 * b0) + (c0 * c0) - (a0 * a0)) / (2 * b0 * c0)) * (180 / PI);
    angle_opposite_of_b0 = acos(((a0 * a0) + (c0 * c0) - (b0 * b0)) / (2 * a0 * c0)) * (180 / PI);
    angle_opposite_of_c0 = acos(((a0 * a0) + (b0 * b0) - (c0 * c0)) / (2 * a0 * b0)) * (180 / PI);

    // second triangle
    a1 = D.get_distance_from(B);
    b1 = B.get_distance_from(C);
    c1 = C.get_distance_from(D);
    angle_opposite_of_a1 = acos(((b1 * b1) + (c1 * c1) - (a1 * a1)) / (2 * b1 * c1)) * (180 / PI);
    angle_opposite_of_b1 = acos(((a1 * a1) + (c1 * c1) - (b1 * b1)) / (2 * a1 * c1)) * (180 / PI);
    angle_opposite_of_c1 = acos(((a1 * a1) + (b1 * b1) - (c1 * c1)) / (2 * a1 * b1)) * (180 / PI);

    interior_angle_of_A = angle_opposite_of_b0;
    interior_angle_of_B = angle_opposite_of_c0 + angle_opposite_of_c1;
    interior_angle_of_C = angle_opposite_of_a1;
    interior_angle_of_D = angle_opposite_of_b1 + angle_opposite_of_a0;

    /* sides of quadrilateral */
    a = B.get_distance_from(C);
    b = C.get_distance_from(D);
    c = D.get_distance_from(A);
    d = A.get_distance_from(B);

    if (!is_rectangle()) return false;

    // Determine whether each side of the quadrilateral has the same length.
    if ((a == b) &amp;&amp; (b == c) &amp;&amp; (c == d) &amp;&amp; (d == a)) return true;
    return false;
}

/**
 * The default constructor of the SQUARE class calls the constructor of the RECTANGLE class and
 * sets the POINT type data member of the SQUARE object returned by this function named A to POINT(0,0), 
 * sets the POINT type data member of the SQUARE object returned by this function named B to POINT(0,5), 
 * sets the POINT type data member of the SQUARE object returned by this function named C to POINT(5,5), and
 * sets the POINT type data member of the SQUARE object returned by this function named D to POINT(5,0).
 */
SQUARE::SQUARE()
{
    std::cout &lt;&lt; "\n\nCreating the SQUARE type object whose memory address is " &lt;&lt; this &lt;&lt; "...";
    A = POINT(0,0);
    B = POINT(0,5);
    C = POINT(5,5);
    D = POINT(5,0);
}

/**
 * The normal constructor of SQUARE attempts to set
 * the string type data member of this to the input string type value named color and
 * the POINT type data member of this named A to the input POINT type value named A and
 * the POINT type data member of this named B to the input POINT type value named B and
 * the POINT type data member of this named C to the input POINT type value named C and
 * the POINT type data member of this named D to the input POINT type value named D.
 * 
 * (The keyword this refers to the SQUARE object which is returned by this function).
 * 
 * If A, B, C, and D represent unique points on a Cartesian plane and
 * if the interior angles of the quadrilateral which those points would represent add up to 360 degrees and
 * if the area of the quadrilateral which those points represents is larger than zero,
 * if each interior angle of that quadrilateral has an angle measurement of 90 degrees, and
 * if each side of that quadrilateral has the same length,
 * use the input POINT values as the POINT values for the SQUARE object which is returned by this function.
 */
SQUARE::SQUARE(std::string color, POINT A, POINT B, POINT C, POINT D)
{
    std::cout &lt;&lt; "\n\nCreating the SQUARE type object whose memory address is " &lt;&lt; this &lt;&lt; "...";
    SQUARE test_square;
    test_square.A.set_X(A.get_X());
    test_square.A.set_Y(A.get_Y());
    test_square.B.set_X(B.get_X());
    test_square.B.set_Y(B.get_Y());
    test_square.C.set_X(C.get_X());
    test_square.C.set_Y(C.get_Y());
    test_square.D.set_X(D.get_X());
    test_square.D.set_Y(D.get_Y());
    if (test_square.is_square())
    {
        this -&gt; A = A;
        this -&gt; B = B;
        this -&gt; C = C;
        this -&gt; D = D;
    }
    else
    {
        this -&gt; A = POINT(0,0);
        this -&gt; B = POINT(0,3);
        this -&gt; C = POINT(4,3);
        this -&gt; D = POINT(4,0);
    }
    this -&gt; color = color;
}
    
/**
 * The copy constructor of SQUARE creates a clone of 
 * the input SQUARE instance.
 */
SQUARE::SQUARE(SQUARE &amp; square)
{
    std::cout &lt;&lt; "\n\nCreating the SQUARE type object whose memory address is " &lt;&lt; this &lt;&lt; "...";
    A = square.A;
    B = square.B;
    C = square.C;
    D = square.D;
    color = square.color;
}
    
/** 
 * This method overrides the RECTANGLE class's print method.
 * 
 * The descriptor method prints a description of the caller SQUARE instance to the output stream.
 * 
 * If no function input is supplied, output is set to the command line terminal.
 */
void SQUARE::print(std::ostream &amp; output)
{
    double a0 = 0.0, b0 = 0.0, c0 = 0.0;
    double a1 = 0.0, b1 = 0.0, c1 = 0.0;
    double angle_opposite_of_a0 = 0.0, angle_opposite_of_b0 = 0.0, angle_opposite_of_c0 = 0.0; 
    double angle_opposite_of_a1 = 0.0, angle_opposite_of_b1 = 0.0, angle_opposite_of_c1 = 0.0; 
    double interior_angle_of_A = 0.0, interior_angle_of_B = 0.0, interior_angle_of_C = 0.0, interior_angle_of_D = 0.0;

    // first triangle
    a0 = A.get_distance_from(B);
    b0 = B.get_distance_from(D);
    c0 = D.get_distance_from(A);
    angle_opposite_of_a0 = acos(((b0 * b0) + (c0 * c0) - (a0 * a0)) / (2 * b0 * c0)) * (180 / PI);
    angle_opposite_of_b0 = acos(((a0 * a0) + (c0 * c0) - (b0 * b0)) / (2 * a0 * c0)) * (180 / PI);
    angle_opposite_of_c0 = acos(((a0 * a0) + (b0 * b0) - (c0 * c0)) / (2 * a0 * b0)) * (180 / PI);

    // second triangle
    a1 = D.get_distance_from(B);
    b1 = B.get_distance_from(C);
    c1 = C.get_distance_from(D);
    angle_opposite_of_a1 = acos(((b1 * b1) + (c1 * c1) - (a1 * a1)) / (2 * b1 * c1)) * (180 / PI);
    angle_opposite_of_b1 = acos(((a1 * a1) + (c1 * c1) - (b1 * b1)) / (2 * a1 * c1)) * (180 / PI);
    angle_opposite_of_c1 = acos(((a1 * a1) + (b1 * b1) - (c1 * c1)) / (2 * a1 * b1)) * (180 / PI);

    interior_angle_of_A = angle_opposite_of_b0;
    interior_angle_of_B = angle_opposite_of_c0 + angle_opposite_of_c1;
    interior_angle_of_C = angle_opposite_of_a1;
    interior_angle_of_D = angle_opposite_of_b1 + angle_opposite_of_a0;

    output &lt;&lt; "\n\n--------------------------------------------------------------------------------------------------";
    output &lt;&lt; "\nthis = " &lt;&lt; this &lt;&lt; ". // The keyword named this is a pointer which stores the memory address of the first memory cell of a QUADRILATERAL sized chunk of contiguous memory cells which are allocated to the caller TRIANGLE object.";
    output &lt;&lt; "\n&amp;category = " &lt;&lt; &amp;category &lt;&lt; ". // The reference operation returns the memory address of the first memory cell of a string sized chunk of contiguous memory cells which are allocated to the string data attribute named category.";
    output &lt;&lt; "\n&amp;color = " &lt;&lt; &amp;color &lt;&lt; ". // The reference operation returns the memory address of the first memory cell of a string sized chunk of contiguous memory cells which are allocated to the string data attribute named color..";
    output &lt;&lt; "\n&amp;A = " &lt;&lt; &amp;A &lt;&lt; ". // The reference operation returns the memory address of the first memory cell of a POINT sized chunk of contiguous memory cells which are allocated to the POINT data attribute named A.";
    output &lt;&lt; "\n&amp;B = " &lt;&lt; &amp;B &lt;&lt; ". // The reference operation returns the memory address of the first memory cell of a POINT sized chunk of contiguous memory cells which are allocated to the POINT data attribute named B.";
    output &lt;&lt; "\n&amp;C = " &lt;&lt; &amp;C &lt;&lt; ". // The reference operation returns the memory address of the first memory cell of a POINT sized chunk of contiguous memory cells which are allocated to the POINT data attribute named C.";
    output &lt;&lt; "\n&amp;D = " &lt;&lt; &amp;D &lt;&lt; ". // The reference operation returns the memory address of the first memory cell of a POINT sized chunk of contiguous memory cells which are allocated to the POINT data attribute named D.";
    output &lt;&lt; "\nsizeof(int) = " &lt;&lt; sizeof(int) &lt;&lt; ". // The sizeof() operation returns the nonnegative integer number of bytes of memory which an int type variable occupies. (Each memory cell has a data capacity of 1 byte).";
    output &lt;&lt; "\nsizeof(int *) = " &lt;&lt; sizeof(int *) &lt;&lt; ". // The sizeof() operation returns the nonnegative integer number of bytes of memory which a pointer-to-int type variable occupies. (Each memory cell has a data capacity of 1 byte).";
    output &lt;&lt; "\nsizeof(int **) = " &lt;&lt; sizeof(int **) &lt;&lt; ". // The sizeof() operation returns the nonnegative integer number of bytes of memory which an pointer-to-pointer-to-int type variable occupies. (Each memory cell has a data capacity of 1 byte).";
    output &lt;&lt; "\nsizeof(std::string) = " &lt;&lt; sizeof(std::string) &lt;&lt; ". // The sizeof() operation returns the nonnegative integer number of bytes of memory which a string type variable occupies. (Each memory cell has a data capacity of 1 byte).";
    output &lt;&lt; "\nsizeof(std::string *) = " &lt;&lt; sizeof(std::string *) &lt;&lt; ". // The sizeof() operation returns the nonnegative integer number of bytes of memory which a pointer-to-string type variable occupies. (Each memory cell has a data capacity of 1 byte).";
    output &lt;&lt; "\nsizeof(std::string **) = " &lt;&lt; sizeof(std::string **) &lt;&lt; ". // The sizeof() operation returns the nonnegative integer number of bytes of memory which a pointer-to-pointer-to-string type variable occupies. (Each memory cell has a data capacity of 1 byte).";
    output &lt;&lt; "\nsizeof(POINT) = " &lt;&lt; sizeof(POINT) &lt;&lt; ". // The sizeof() operation returns the nonnegative integer number of bytes of memory which a POINT type object occupies. (Each memory cell has a data capacity of 1 byte).";
    output &lt;&lt; "\nsizeof(POINT *) = " &lt;&lt; sizeof(POINT *) &lt;&lt; ". // The sizeof() operation returns the nonnegative integer number of bytes of memory which a pointer-to-POINT type variable occupies. (Each memory cell has a data capacity of 1 byte).";
    output &lt;&lt; "\nsizeof(POINT **) = " &lt;&lt; sizeof(POINT **) &lt;&lt; ". // The sizeof() operation returns the nonnegative integer number of bytes of memory which a pointer-to-pointer-to-POINT type variable occupies. (Each memory cell has a data capacity of 1 byte).";
    output &lt;&lt; "\nsizeof(POLYGON) = " &lt;&lt; sizeof(POLYGON) &lt;&lt; ". // The sizeof() operation returns the nonnegative integer number of bytes of memory which a POLYGON type object occupies. (Each memory cell has a data capacity of 1 byte).";
    output &lt;&lt; "\nsizeof(POLYGON *) = " &lt;&lt; sizeof(POLYGON *) &lt;&lt; ". // The sizeof() operation returns the nonnegative integer number of bytes of memory which a pointer-to-POLYGON type variable occupies. (Each memory cell has a data capacity of 1 byte).";
    output &lt;&lt; "\nsizeof(POLYGON **) = " &lt;&lt; sizeof(POLYGON **) &lt;&lt; ". // The sizeof() operation returns the nonnegative integer number of bytes of memory which a pointer-to-pointer-to-POLYGON type variable occupies. (Each memory cell has a data capacity of 1 byte).";
    output &lt;&lt; "\nsizeof(QUADRILATERAL) = " &lt;&lt; sizeof(QUADRILATERAL) &lt;&lt; ". // The sizeof() operation returns the nonnegative integer number of bytes of memory which a QUADRILATERAL type object occupies. (Each memory cell has a data capacity of 1 byte).";
    output &lt;&lt; "\nsizeof(QUADRILATERAL *) = " &lt;&lt; sizeof(QUADRILATERAL *) &lt;&lt; ". // The sizeof() operation returns the nonnegative integer number of bytes of memory which a pointer-to-QUADRILATERAL type variable occupies. (Each memory cell has a data capacity of 1 byte).";
    output &lt;&lt; "\nsizeof(QUADRILATERAL **) = " &lt;&lt; sizeof(QUADRILATERAL **) &lt;&lt; ". // The sizeof() operation returns the nonnegative integer number of bytes of memory which a pointer-to-pointer-to-QUADRILATERAL type variable occupies. (Each memory cell has a data capacity of 1 byte).";
    output &lt;&lt; "\nsizeof(RECTANGLE) = " &lt;&lt; sizeof(RECTANGLE) &lt;&lt; ". // The sizeof() operation returns the nonnegative integer number of bytes of memory which a RECTANGLE type object occupies. (Each memory cell has a data capacity of 1 byte).";
    output &lt;&lt; "\nsizeof(RECTANGLE *) = " &lt;&lt; sizeof(RECTANGLE *) &lt;&lt; ". // The sizeof() operation returns the nonnegative integer number of bytes of memory which a pointer-to-RECTANGLE type variable occupies. (Each memory cell has a data capacity of 1 byte).";
    output &lt;&lt; "\nsizeof(RECTANGLE **) = " &lt;&lt; sizeof(RECTANGLE **) &lt;&lt; ". // The sizeof() operation returns the nonnegative integer number of bytes of memory which a pointer-to-pointer-to-RECTANGLE type variable occupies. (Each memory cell has a data capacity of 1 byte).";
    output &lt;&lt; "\nsizeof(SQUARE) = " &lt;&lt; sizeof(SQUARE) &lt;&lt; ". // The sizeof() operation returns the nonnegative integer number of bytes of memory which a SQUARE type object occupies. (Each memory cell has a data capacity of 1 byte).";
    output &lt;&lt; "\nsizeof(SQUARE *) = " &lt;&lt; sizeof(SQUARE *) &lt;&lt; ". // The sizeof() operation returns the nonnegative integer number of bytes of memory which a pointer-to-SQUARE type variable occupies. (Each memory cell has a data capacity of 1 byte).";
    output &lt;&lt; "\nsizeof(SQUARE **) = " &lt;&lt; sizeof(SQUARE **) &lt;&lt; ". // The sizeof() operation returns the nonnegative integer number of bytes of memory which a pointer-to-pointer-to-SQUARE type variable occupies. (Each memory cell has a data capacity of 1 byte).";
    output &lt;&lt; "\ncategory = " &lt;&lt; category &lt;&lt; ". // This is an immutable string type value which is a data member of the caller RECTANGLE object.";
    output &lt;&lt; "\ncolor = " &lt;&lt; color &lt;&lt; ". // This is a string type value which is a data member of the caller RECTANGLE object.";
    output &lt;&lt; "\nA = POINT(" &lt;&lt; A.get_X() &lt;&lt; "," &lt;&lt; A.get_Y() &lt;&lt; "). // A represents a point (which is neither B nor C nor D) plotted on a two-dimensional Cartesian grid (such that the X value represents a real whole number position along the horizontal axis of the Cartesian grid while Y represents a real whole number position along the vertical axis of the same Cartesian grid).";
    output &lt;&lt; "\nB = POINT(" &lt;&lt; B.get_X() &lt;&lt; "," &lt;&lt; B.get_Y() &lt;&lt; "). // B represents a point (which is neither A nor C nor D) plotted on a two-dimensional Cartesian grid (such that the X value represents a real whole number position along the horizontal axis of the Cartesian grid while Y represents a real whole number position along the vertical axis of the same Cartesian grid).";
    output &lt;&lt; "\nC = POINT(" &lt;&lt; C.get_X() &lt;&lt; "," &lt;&lt; C.get_Y() &lt;&lt; "). // C represents a point (which is neither A nor B nor D) plotted on a two-dimensional Cartesian grid (such that the X value represents a real whole number position along the horizontal axis of the Cartesian grid while Y represents a real whole number position along the vertical axis of the same Cartesian grid).";
    output &lt;&lt; "\nD = POINT(" &lt;&lt; D.get_X() &lt;&lt; "," &lt;&lt; D.get_Y() &lt;&lt; "). // D represents a point (which is neither A nor B nor C) plotted on a two-dimensional Cartesian grid (such that the X value represents a real whole number position along the horizontal axis of the Cartesian grid while Y represents a real whole number position along the vertical axis of the same Cartesian grid).";
    output &lt;&lt; "\na = B.get_distance_from(C) = " &lt;&lt; B.get_distance_from(C) &lt;&lt; ". // The method returns the approximate nonnegative real number of Cartesian grid unit lengths which span the length of the shortest path between points B and C.";
    output &lt;&lt; "\nb = C.get_distance_from(D) = " &lt;&lt; C.get_distance_from(D) &lt;&lt; ". // The method returns the approximate nonnegative real number of Cartesian grid unit lengths which span the length of the shortest path between points C and D.";
    output &lt;&lt; "\nc = D.get_distance_from(A) = " &lt;&lt; D.get_distance_from(A) &lt;&lt; ". // The method returns the approximate nonnegative real number of Cartesian grid unit lengths which span the length of the shortest path between points D and A.";
    output &lt;&lt; "\nd = A.get_distance_from(B) = " &lt;&lt; A.get_distance_from(B) &lt;&lt; ". // The method returns the approximate nonnegative real number of Cartesian grid unit lengths which span the length of the shortest path between points A and B.";
    output &lt;&lt; "\nA.get_slope_of_line_to(B) = " &lt;&lt; A.get_slope_of_line_to(B) &lt;&lt; ". // The method returns the approximate nonnegative real number which represents the slope of the line which intersects points A and B.";
    output &lt;&lt; "\nB.get_slope_of_line_to(C) = " &lt;&lt; B.get_slope_of_line_to(C) &lt;&lt; ". // The method returns the approximate nonnegative real number which represents the slope of the line which intersects points B and C.";
    output &lt;&lt; "\nC.get_slope_of_line_to(D) = " &lt;&lt; C.get_slope_of_line_to(D) &lt;&lt; ". // The method returns the approximate nonnegative real number which represents the slope of the line which intersects points C and D.";
    output &lt;&lt; "\nD.get_slope_of_line_to(A) = " &lt;&lt; D.get_slope_of_line_to(A) &lt;&lt; ". // The method returns the approximate nonnegative real number which represents the slope of the line which intersects points B and C.";
    output &lt;&lt; "\ninterior_angle_DAB = interior_angle_of_A = " &lt;&lt; interior_angle_of_A &lt;&lt; ". // The value represents the approximate nonnegative real number angle measurement of the acute or else right angle formed by the intersection of the line segment whose endpoints are D and A with the line segment whose endpoints are A and B such that those two line segments intersect at A (and the angle measurement is in degrees and not in radians).";
    output &lt;&lt; "\ninterior_angle_ABC = interior_angle_of_B = " &lt;&lt; interior_angle_of_B &lt;&lt; ". // The method returns the approximate nonnegative real number angle measurement of the acute or else right angle formed by the intersection of the line segment whose endpoints are A and B with the line segment whose endpoints are B and C such that those two line segments intersect at B (and the angle measurement is in degrees and not in radians).";
    output &lt;&lt; "\ninterior_angle_BCD = interior_angle_of_C = " &lt;&lt; interior_angle_of_C &lt;&lt; ". // The method returns the approximate nonnegative real number angle measurement of the acute or else right angle formed by the intersection of the line segment whose endpoints are B and C with the line segment whose endpoints are C and D such that those two line segments intersect at C (and the angle measurement is in degrees and not in radians).";
    output &lt;&lt; "\ninterior_angle_CDA = interior_angle_of_D = " &lt;&lt; interior_angle_of_D &lt;&lt; ". // The method returns the approximate nonnegative real number angle measurement of the acute or else right angle formed by the intersection of the line segment whose endpoints are C and D with the line segment whose endpoints are D and A such that those two line segments intersect at D (and the angle measurement is in degrees and not in radians).";
    output &lt;&lt; "\ninterior_angle_of_A + interior_angle_of_B + interior_angle_of_C + interior_angle_of_D = " &lt;&lt; interior_angle_of_A + interior_angle_of_B + interior_angle_of_C + interior_angle_of_D &lt;&lt; ". // sum of all four approximate interior angle measurements of the quadrilateral represented by the caller QUADRILATERAL object (in degrees and not in radians)";
    output &lt;&lt; "\nget_perimeter() = a + b + c + d = " &lt;&lt; get_perimeter() &lt;&lt; ". // The method returns the sum of the four approximated side lengths of the rectangle which the caller RECTANGLE object represents.";
    output &lt;&lt; "\nget_area() = " &lt;&lt; get_area() &lt;&lt; ". // The method returns the approximate nonnegative real number of Cartesian grid unit squares which are enclosed inside of the two-dimensional region formed by the four line segments which connect points A to B, B to C, C to D, and D to A.";
    output &lt;&lt; "\n--------------------------------------------------------------------------------------------------";
}
    
/**
 * The friend function is an alternative to the print method.
 * The friend function overloads the ostream operator (i.e. &lt;&lt;).
 * 
 * The friend function is not a member of the SQUARE class,
 * but the friend function does have access to the private and protected members of the SQUARE class as though
 * the friend function was a member of the SQUARE class.
 */
std::ostream &amp; operator &lt;&lt; (std::ostream &amp; output, SQUARE &amp; square)
{
    square.print(output);
    return output;
}

/**
 * The destructor method of the SQUARE class de-allocates memory which was used to 
 * instantiate the SQUARE object which is calling this function.
 * 
 * The destructor method of the SQUARE class is automatically called when 
 * the program scope in which the caller SQUARE object was instantiated terminates.
 */
SQUARE::~SQUARE()
{
    std::cout &lt;&lt; "\n\nDeleting the SQUARE type object whose memory address is " &lt;&lt; this &lt;&lt; "...";
}
</pre>
<hr />
<p><strong>TRILATERAL_CLASS_HEADER</strong></p>
<hr />
<p>The following header file contains the preprocessing directives and function prototypes of the TRILATERAL class.</p>
<p>C++_header_file: <a style="background: #000000;color: #00ff00" href="https://raw.githubusercontent.com/karlinarayberinger/KARLINA_OBJECT_summer_2023_starter_pack/main/trilateral.h" target="_blank" rel="noopener">https://raw.githubusercontent.com/karlinarayberinger/KARLINA_OBJECT_summer_2023_starter_pack/main/trilateral.h</a></p>
<hr />
<pre>/**
 * file: trilateral.h
 * type: C++ (header file)
 * date: 07_JULY_2023
 * author: karbytes
 * license: PUBLIC_DOMAIN
 */

// If trilateral.h has not already been linked to a source file (.cpp), then link this header file to the source file(s) which include this header file.
#ifndef TRILATERAL_H 
#define TRILATERAL_H

// Include the C++ header file which contains preprocessing directives, variable declarations, and function prototypes for the POLYGON class.
#include "polygon.h" 

/**
 * TRILATERAL is a class which inherits the protected and public data
 * attributes and methods of POLYGON (and POLYGON is an abstract class).
 * 
 * A TRILATERAL object represents an instance in which three unique POINT instances exist 
 * such that each one of those three POINT instances represents a unique coordinate pair within the tuple of three POINT instances 
 * (such that each coordinate pair represents exactly one two-dimensional point, POINT(X,Y), on a Cartesian grid).
 * 
 * Each TRILATERAL object represents a specific three-sided polygon whose area is a positive real number.
 * 
 * (A synonym for "trilateral" is "triangle").
 * 
 * Class members which are set to the protected access specifier
 * are accessible to the base class and to derived classes.
 * 
 * Class members which are set to the private access specifier
 * are only accessible to the base class.
 * 
 * Class members which are set to the public access specifier
 * are accessible to any scope within the program where
 * the base class and its derived classes are implemented.
 */
class TRILATERAL: public POLYGON
{
protected:

    /**
     * category is a description of the POLYGON instance.
     * category is set to a constant (i.e. immutable) string type value.
     */
    const std::string category = "POLYGON/TRILATERAL";

    /**
     * POINT type objects A, B, and C represent points on a Cartesian plane.
     * Each POINT type object has two int type variables for representing a two-dimensional whole number coordinate pair.
     * The X data attribute of a POINT object represents a whole number position on the horizontal axis (i.e. x-axis) of a Cartesian plane.
     * The Y data attribute of a POINT object represents a whole number position on the vertical axis (i.e. y-axis) of the same Cartesian plane.
     */
    POINT A, B, C;

    /**
     * If each of the three whole number coordinate pairs represented by the POINT type input values named _A, _B, and _C are unique whole number coordinate pairs, 
     * return true. 
     * Otherwise, return false.
     */
    bool points_represent_unique_coordinate_pairs(POINT _A, POINT _B, POINT _C);

    /**
     * The getter method of the TRILATERAL class named get_interior_angle_ABC() returns the approximate angle measurement in degrees of the angle
     * formed by connecting points A, B, anc C in the order specified by this sentence.
     * 
     * The function below uses the Law of Cosines to compute the measurement of an interior angle of a triangle 
     * using that triangle's three side lengths as function inputs to output some nonnegative real number of degrees.
     */
    double get_interior_angle_ABC();

    /**
     * The getter method of the TRILATERAL class named get_interior_angle_BCA() returns the approximate angle measurement in degrees of the angle
     * formed by connecting points B, C, and A in the order specified by this sentence.
     * 
     * The function below uses the Law of Cosines to compute the measurement of an interior angle of a triangle 
     * using that triangle's three side lengths as function inputs to output some nonnegative real number of degrees.
     */
    double get_interior_angle_BCA();

    /**
     * The getter method of the TRILATERAL class named get_interior_angle_CAB() returns the approximate angle measurement in degrees of the angle
     * formed by connecting points C, A, and B in the order specified by this sentence.
     * 
     * The function below uses Law of Cosines to compute the measurement of an interior angle of a triangle 
     * using that triangle's three side lengths as function inputs to output some nonnegative real number of degrees.
     */   
    double get_interior_angle_CAB();

    /**
     * If sum of the interior angle measurements of the quadrilateral which the caller TRILATERAL object represents add up to approximately 180 degrees, 
     * return true.
     * Otherwise, return false.
     */
    bool interior_angles_add_up_to_180_degrees();
    
public:
    
    /**
     * The default constructor of the TRILATERAL class calls the constructor of the POLYGON class and
     * sets the POINT type data member of the TRILATERAL object returned by this function named A to POINT(0,0), 
     * sets the POINT type data member of the TRILATERAL object returned by this function named B to POINT(4,3), and
     * sets the POINT type data member of the TRILATERAL object returned by this function named C to POINT(4,0).
     */
    TRILATERAL();
    
    /**
     * The normal constructor of TRILATERAL attempts to set
     * the string type data member of this to the input string type value named color and
     * the POINT type data member of this named A to the input POINT type value named A and
     * the POINT type data member of this named B to the input POINT type value named B and
     * the POINT type data member of this named C to the input POINT type value named C.
     * 
     * (The keyword this refers to the TRILATERAL object which is returned by this function).
     * 
     * If A, B, and C represent unique points on a Cartesian plane,
     * if the interior angles of the trilatreal which those points would represent add up to 180 degrees, and
     * if the area of the trilateral which those points represents is larger than zero,
     */
    TRILATERAL(std::string color, POINT A, POINT B, POINT C);

    /**
     * The copy constructor method of the TRILATERAL class 
     * instantiates TRILATERAL type objects 
     * whose A value is set to the A value of the input TRILATERAL object,
     * whose B value is set to the B value of the input TRILATERAL object, and
     * whose C value is set to the C value of the input TRILATERAL object.
     */
    TRILATERAL(TRILATERAL &amp; trilateral);

    /**
     * The TRILATERAL class implements the virtual get_area() method of the POLYGON class.
     * 
     * The getter method returns the approximate area of the two-dimensional space whose bounds are 
     * the shortest paths between points A, B, and C of the triangle which the caller TRILATERAL object represents.
     * This function uses Heron's Formula to compute the area of a triangle using that triangle's side lengths as formula inputs.
     */
    double get_area();

    /**
     * The TRILATERAL class implements the virtual get_perimeter() method of the POLYGON class.
     * 
     * The getter method returns the perimeter of the trilateral represented by the caller TRILATERAL object
     * by adding up the three side lengths of that trilateral.
     * 
     * Let AB be the length of the line segment whose endpoints are A and B.
     * Let BC be the length of the line segment whose endpoints are B and C.
     * Let CA be the length of the line segment whose endpoints are C and A.
     * 
     * Then return the sum of AB, BC, and CA.
     */
    double get_perimeter();
    
    /** 
     * This method overrides the POLYGON class's print method.
     * 
     * The descriptor method prints a description of the caller TRILATERAL instance to the output stream.
     * 
     * If no function input is supplied, output is set to the command line terminal.
     */
    void print(std::ostream &amp; output = std::cout);
    
    /**
     * The friend function is an alternative to the print method.
     * The friend function overloads the ostream operator (i.e. &lt;&lt;).
     * 
     * The friend function is not a member of the TRILATERAL class,
     * but the friend function does have access to the private and protected members of the TRILATERAL class as though
     * the friend function was a member of the TRILATERAL class.
     */
    friend std::ostream &amp; operator &lt;&lt; (std::ostream &amp; output, TRILATERAL &amp; trilateral);

    /**
     * The destructor method of the TRILATERAL class de-allocates memory which was used to 
     * instantiate the TRILATERAL object which is calling this function.
     * 
     * The destructor method of the TRILATERAL class is automatically called when 
     * the program scope in which the caller TRILATERAL object was instantiated terminates.
     */
    ~TRILATERAL();
};

/* preprocessing directives */
#endif // Terminate the conditional preprocessing directives code block in this header file.
</pre>
<hr />
<p><strong>TRILATERAL_CLASS_SOURCE_CODE</strong></p>
<hr />
<p>The following source code defines the functions of the TRILATERAL class.</p>
<p>C++_source_file: <a style="background: #000000;color: #00ff00" href="https://raw.githubusercontent.com/karlinarayberinger/KARLINA_OBJECT_summer_2023_starter_pack/main/trilateral.cpp" target="_blank" rel="noopener">https://raw.githubusercontent.com/KARLINA_OBJECT_summer_2023_starter_pack/main/trilateral.cpp</a></p>
<hr />
<pre>/**
 * file: trilateral.cpp
 * type: C++ (source file)
 * date: 07_JULY_2023
 * author: karbytes
 * license: PUBLIC_DOMAIN
 */

// Include the C++ header file which contains preprocessing directives, variable declarations, and function prototypes for the TRILATERAL class.
#include "trilateral.h" 

/**
 * If each of the three whole number coordinate pairs represented by the POINT type input values named _A, _B, and _C are unique whole number coordinate pairs, 
 * return true. 
 * Otherwise, return false.
 */
bool TRILATERAL::points_represent_unique_coordinate_pairs(POINT _A, POINT _B, POINT _C)
{
    if ((_A.get_X() == _B.get_X()) &amp;&amp; (_A.get_Y() == _B.get_Y())) return false;
    if ((_A.get_X() == _C.get_X()) &amp;&amp; (_A.get_Y() == _C.get_Y())) return false;
    if ((_B.get_X() == _C.get_X()) &amp;&amp; (_B.get_Y() == _C.get_Y())) return false;
    return true;
}

/**
 * The getter method of the TRILATERAL class named get_interior_angle_ABC() returns the approximate angle measurement in degrees of the angle
 * formed by connecting points A, B, anc C in the order specified by this sentence.
 * 
 * The function below uses the Law of Cosines to compute the measurement of an interior angle of a triangle 
 * using that triangle's three side lengths as function inputs to output some nonnegative real number of degrees.
 */
double TRILATERAL::get_interior_angle_ABC()
{
    double a = 0.0, b = 0.0, c = 0.0, angle_opposite_of_a = 0.0, angle_opposite_of_b = 0.0, angle_opposite_of_c = 0.0;
    a = B.get_distance_from(C); // a represents the length of the line segment whose endpoints are B and C.
    b = C.get_distance_from(A); // b represents the length of the line segment whose endpoints are C and A.
    c = A.get_distance_from(B); // c represents the length of the line segment whose endpoints are A and B.
    angle_opposite_of_a = acos(((b * b) + (c * c) - (a * a)) / (2 * b * c)) * (180 / PI);
    angle_opposite_of_b = acos(((a * a) + (c * c) - (b * b)) / (2 * a * c)) * (180 / PI);
    angle_opposite_of_c = acos(((a * a) + (b * b) - (c * c)) / (2 * a * b)) * (180 / PI);
    return angle_opposite_of_b;
}

/**
 * The getter method of the TRILATERAL class named get_interior_angle_BCA() returns the approximate angle measurement in degrees of the angle
 * formed by connecting points B, C, and A in the order specified by this sentence.
 * 
 * The function below uses the Law of Cosines to compute the measurement of an interior angle of a triangle 
 * using that triangle's three side lengths as function inputs to output some nonnegative real number of degrees.
 */
double TRILATERAL::get_interior_angle_BCA()
{
    double a = 0.0, b = 0.0, c = 0.0, angle_opposite_of_a = 0.0, angle_opposite_of_b = 0.0, angle_opposite_of_c = 0.0;
    a = B.get_distance_from(C); // a represents the length of the line segment whose endpoints are B and C.
    b = C.get_distance_from(A); // b represents the length of the line segment whose endpoints are C and A.
    c = A.get_distance_from(B); // c represents the length of the line segment whose endpoints are A and B.
    angle_opposite_of_a = acos(((b * b) + (c * c) - (a * a)) / (2 * b * c)) * (180 / PI);
    angle_opposite_of_b = acos(((a * a) + (c * c) - (b * b)) / (2 * a * c)) * (180 / PI);
    angle_opposite_of_c = acos(((a * a) + (b * b) - (c * c)) / (2 * a * b)) * (180 / PI);
    return angle_opposite_of_c;
}

/**
 * The getter method of the TRILATERAL class named get_interior_angle_CAB() returns the approximate angle measurement in degrees of the angle
 * formed by connecting points C, A, and B in the order specified by this sentence.
 * 
 * The function below uses Law of Cosines to compute the measurement of an interior angle of a triangle 
 * using that triangle's three side lengths as function inputs to output some nonnegative real number of degrees.
 */   
double TRILATERAL::get_interior_angle_CAB()
{
    double a = 0.0, b = 0.0, c = 0.0, angle_opposite_of_a = 0.0, angle_opposite_of_b = 0.0, angle_opposite_of_c = 0.0;
    a = B.get_distance_from(C); // a represents the length of the line segment whose endpoints are B and C (and which are points of the caller TRIANGLE object of this function represents).
    b = C.get_distance_from(A); // b represents the length of the line segment whose endpoints are C and A (and which are points of the caller TRIANGLE object of this function represents).
    c = A.get_distance_from(B); // c represents the length of the line segment whose endpoints are A and B (and which are points of the caller TRIANGLE object of this function represents).
    angle_opposite_of_a = acos(((b * b) + (c * c) - (a * a)) / (2 * b * c)) * (180 / PI);
    angle_opposite_of_b = acos(((a * a) + (c * c) - (b * b)) / (2 * a * c)) * (180 / PI);
    angle_opposite_of_c = acos(((a * a) + (b * b) - (c * c)) / (2 * a * b)) * (180 / PI);
    return angle_opposite_of_a;
}

/**
 * If sum of the interior angle measurements of the quadrilateral which the caller TRILATERAL object represents add up to approximately 180 degrees, 
 * return true.
 * Otherwise, return false.
 */
bool TRILATERAL::interior_angles_add_up_to_180_degrees()
{
    return floor(get_interior_angle_ABC()) + floor(get_interior_angle_BCA()) + floor(get_interior_angle_CAB());
}
    
/**
 * The default constructor of the TRILATERAL class calls the constructor of the POLYGON class and
 * sets the POINT type data member of the TRILATERAL object returned by this function named A to POINT(0,0), 
 * sets the POINT type data member of the TRILATERAL object returned by this function named B to POINT(4,3), and
 * sets the POINT type data member of the TRILATERAL object returned by this function named C to POINT(4,0).
 */
TRILATERAL::TRILATERAL()
{
    std::cout &lt;&lt; "\n\nCreating the TRILATERAL type object whose memory address is " &lt;&lt; this &lt;&lt; "...";
    A = POINT(0,0);
    B = POINT(4,3);
    C = POINT(4,0);
}
    
/**
 * The normal constructor of TRILATERAL attempts to set
 * the string type data member of this to the input string type value named color and
 * the POINT type data member of this named A to the input POINT type value named A and
 * the POINT type data member of this named B to the input POINT type value named B and
 * the POINT type data member of this named C to the input POINT type value named C.
 *
 * (The keyword this refers to the TRILATERAL object which is returned by this function).
 * 
 * If A, B, and C represent unique points on a Cartesian plane,
 * if the interior angles of the trilatreal which those points would represent add up to 180 degrees, and
 * if the area of the trilateral which those points represents is larger than zero,
 * use the input POINT values as the POINT values for the TRILATERAL object which is returned by this function.
 */
TRILATERAL::TRILATERAL(std::string color, POINT A, POINT B, POINT C)
{
    std::cout &lt;&lt; "\n\nCreating the TRILATERAL type object whose memory address is " &lt;&lt; this &lt;&lt; "...";
    TRILATERAL test_trilateral;
    test_trilateral.A.set_X(A.get_X());
    test_trilateral.A.set_Y(A.get_Y());
    test_trilateral.B.set_X(B.get_X());
    test_trilateral.B.set_Y(B.get_Y());
    test_trilateral.C.set_X(C.get_X());
    test_trilateral.C.set_Y(C.get_Y());
    if (test_trilateral.interior_angles_add_up_to_180_degrees() &amp;&amp; (test_trilateral.get_area() &gt; 0))
    {
        this -&gt; A = A;
        this -&gt; B = B;
        this -&gt; C = C;
    }
    else
    {
        this -&gt; A = POINT(0,0);
        this -&gt; B = POINT(4,3);
        this -&gt; C = POINT(4,0);
    }
    this -&gt; color = color;
}

/**
 * The copy constructor method of the TRILATERAL class 
 * instantiates TRILATERAL type objects 
 * whose A value is set to the A value of the input TRILATERAL object,
 * whose B value is set to the B value of the input TRILATERAL object, and
 * whose C value is set to the C value of the input TRILATERAL object.
 */
TRILATERAL::TRILATERAL(TRILATERAL &amp; trilateral)
{
    std::cout &lt;&lt; "\n\nCreating the TRILATERAL type object whose memory address is " &lt;&lt; this &lt;&lt; "...";
    A = trilateral.A;
    B = trilateral.B;
    C = trilateral.C;
    color = trilateral.color;
}

/**
 * The TRILATERAL class implements the virtual get_area() method of the POLYGON class.
 * 
 * The getter method returns the approximate area of the two-dimensional space whose bounds are 
 * the shortest paths between points A, B, and C of the triangle which the caller TRILATERAL object represents
 * This function uses Heron's Formula to compute the area of a triangle using that triangle's side lengths as formula inputs.
 */
double TRILATERAL::get_area()
{
    double s = 0.0, a = 0.0, b = 0.0, c = 0.0;
    s = get_perimeter() / 2; // s is technically referred to as the semiperimter of the triangle which the caller TRIANGLE object of this function represents.
    a = B.get_distance_from(C); // a represents the length of the line segment whose endpoints are B and C (and which are points of the caller TRIANGLE object of this function represents).
    b = C.get_distance_from(A); // b represents the length of the line segment whose endpoints are C and A (and which are points of the caller TRIANGLE object of this function represents).
    c = A.get_distance_from(B); // c represents the length of the line segment whose endpoints are A and B (and which are points of the caller TRIANGLE object of this function represents).
    return sqrt(s * (s - a) * (s - b) * (s - c)); // Use Heron's Formula to compute the area of the triangle whose points are A, B, and C (and which are points of the caller TRIANGLE object of this function represents).
}

/**
 * The TRILATERAL class implements the virtual get_perimeter() method of the POLYGON class.
 * 
 * The getter method returns the perimeter of the trilateral represented by the caller TRILATERAL object
 * by adding up the three side lengths of that trilateral.
 * 
 * Let AB be the length of the line segment whose endpoints are A and B.
 * Let BC be the length of the line segment whose endpoints are B and C.
 * Let CA be the length of the line segment whose endpoints are C and A.
 * 
 * Then return the sum of AB, BC, and CA.
 */
double TRILATERAL::get_perimeter()
{
    return A.get_distance_from(B) + B.get_distance_from(C) + C.get_distance_from(A);
}
    
/** 
 * This method overrides the POLYGON class's print method.
 * 
 * The descriptor method prints a description of the caller TRILATERAL instance to the output stream.
 * 
 * If no function input is supplied, output is set to the command line terminal.
 */
void TRILATERAL::print(std::ostream &amp; output)
{
    output &lt;&lt; "\n\n--------------------------------------------------------------------------------------------------";
    output &lt;&lt; "\nthis = " &lt;&lt; this &lt;&lt; ". // The keyword named this is a pointer which stores the memory address of the first memory cell of a TRILATERAL sized chunk of contiguous memory cells which are allocated to the caller TRILATERAL object.";
    output &lt;&lt; "\n&amp;category = " &lt;&lt; &amp;category &lt;&lt; ". // The reference operation returns the memory address of the first memory cell of a string sized chunk of contiguous memory cells which are allocated to the string data attribute named category.";
    output &lt;&lt; "\n&amp;color = " &lt;&lt; &amp;color &lt;&lt; ". // The reference operation returns the memory address of the first memory cell of a string sized chunk of contiguous memory cells which are allocated to the string data attribute named color..";
    output &lt;&lt; "\n&amp;A = " &lt;&lt; &amp;A &lt;&lt; ". // The reference operation returns the memory address of the first memory cell of a POINT sized chunk of contiguous memory cells which are allocated to the POINT data attribute named A.";
    output &lt;&lt; "\n&amp;B = " &lt;&lt; &amp;B &lt;&lt; ". // The reference operation returns the memory address of the first memory cell of a POINT sized chunk of contiguous memory cells which are allocated to the POINT data attribute named B.";
    output &lt;&lt; "\n&amp;C = " &lt;&lt; &amp;C &lt;&lt; ". // The reference operation returns the memory address of the first memory cell of a POINT sized chunk of contiguous memory cells which are allocated to the POINT data attribute named C.";
    output &lt;&lt; "\nsizeof(int) = " &lt;&lt; sizeof(int) &lt;&lt; ". // The sizeof() operation returns the nonnegative integer number of bytes of memory which an int type variable occupies. (Each memory cell has a data capacity of 1 byte).";
    output &lt;&lt; "\nsizeof(int *) = " &lt;&lt; sizeof(int *) &lt;&lt; ". // The sizeof() operation returns the nonnegative integer number of bytes of memory which a pointer-to-int type variable occupies. (Each memory cell has a data capacity of 1 byte).";
    output &lt;&lt; "\nsizeof(int **) = " &lt;&lt; sizeof(int **) &lt;&lt; ". // The sizeof() operation returns the nonnegative integer number of bytes of memory which an pointer-to-pointer-to-int type variable occupies. (Each memory cell has a data capacity of 1 byte).";
    output &lt;&lt; "\nsizeof(std::string) = " &lt;&lt; sizeof(std::string) &lt;&lt; ". // The sizeof() operation returns the nonnegative integer number of bytes of memory which a string type variable occupies. (Each memory cell has a data capacity of 1 byte).";
    output &lt;&lt; "\nsizeof(std::string *) = " &lt;&lt; sizeof(std::string *) &lt;&lt; ". // The sizeof() operation returns the nonnegative integer number of bytes of memory which a pointer-to-string type variable occupies. (Each memory cell has a data capacity of 1 byte).";
    output &lt;&lt; "\nsizeof(std::string **) = " &lt;&lt; sizeof(std::string **) &lt;&lt; ". // The sizeof() operation returns the nonnegative integer number of bytes of memory which a pointer-to-pointer-to-string type variable occupies. (Each memory cell has a data capacity of 1 byte).";
    output &lt;&lt; "\nsizeof(POINT) = " &lt;&lt; sizeof(POINT) &lt;&lt; ". // The sizeof() operation returns the nonnegative integer number of bytes of memory which a POINT type object occupies. (Each memory cell has a data capacity of 1 byte).";
    output &lt;&lt; "\nsizeof(POINT *) = " &lt;&lt; sizeof(POINT *) &lt;&lt; ". // The sizeof() operation returns the nonnegative integer number of bytes of memory which a pointer-to-POINT type variable occupies. (Each memory cell has a data capacity of 1 byte).";
    output &lt;&lt; "\nsizeof(POINT **) = " &lt;&lt; sizeof(POINT **) &lt;&lt; ". // The sizeof() operation returns the nonnegative integer number of bytes of memory which a pointer-to-pointer-to-POINT type variable occupies. (Each memory cell has a data capacity of 1 byte).";
    output &lt;&lt; "\nsizeof(POLYGON) = " &lt;&lt; sizeof(POLYGON) &lt;&lt; ". // The sizeof() operation returns the nonnegative integer number of bytes of memory which a POLYGON type object occupies. (Each memory cell has a data capacity of 1 byte).";
    output &lt;&lt; "\nsizeof(POLYGON *) = " &lt;&lt; sizeof(POLYGON *) &lt;&lt; ". // The sizeof() operation returns the nonnegative integer number of bytes of memory which a pointer-to-POLYGON type variable occupies. (Each memory cell has a data capacity of 1 byte).";
    output &lt;&lt; "\nsizeof(POLYGON **) = " &lt;&lt; sizeof(POLYGON **) &lt;&lt; ". // The sizeof() operation returns the nonnegative integer number of bytes of memory which a pointer-to-pointer-to-POLYGON type variable occupies. (Each memory cell has a data capacity of 1 byte).";
    output &lt;&lt; "\nsizeof(TRILATERAL) = " &lt;&lt; sizeof(TRILATERAL) &lt;&lt; ". // The sizeof() operation returns the nonnegative integer number of bytes of memory which a TRILATERAL type object occupies. (Each memory cell has a data capacity of 1 byte).";
    output &lt;&lt; "\nsizeof(TRILATERAL *) = " &lt;&lt; sizeof(TRILATERAL *) &lt;&lt; ". // The sizeof() operation returns the nonnegative integer number of bytes of memory which a pointer-to-TRILATERAL type variable occupies. (Each memory cell has a data capacity of 1 byte).";
    output &lt;&lt; "\nsizeof(TRILATERAL **) = " &lt;&lt; sizeof(TRILATERAL **) &lt;&lt; ". // The sizeof() operation returns the nonnegative integer number of bytes of memory which a pointer-to-pointer-to-TRILATERAL type variable occupies. (Each memory cell has a data capacity of 1 byte).";
    output &lt;&lt; "\ncategory = " &lt;&lt; category &lt;&lt; ". // This is an immutable string type value which is a data member of the caller TRILATERAL object.";
    output &lt;&lt; "\ncolor = " &lt;&lt; color &lt;&lt; ". // This is a string type value which is a data member of the caller TRILATERAL object.";
    output &lt;&lt; "\nA = POINT(" &lt;&lt; A.get_X() &lt;&lt; "," &lt;&lt; A.get_Y() &lt;&lt; "). // A represents a point (which is neither B nor C nor D) plotted on a two-dimensional Cartesian grid (such that the X value represents a real whole number position along the horizontal axis of the Cartesian grid while Y represents a real whole number position along the vertical axis of the same Cartesian grid).";
    output &lt;&lt; "\nB = POINT(" &lt;&lt; B.get_X() &lt;&lt; "," &lt;&lt; B.get_Y() &lt;&lt; "). // B represents a point (which is neither A nor C nor D) plotted on a two-dimensional Cartesian grid (such that the X value represents a real whole number position along the horizontal axis of the Cartesian grid while Y represents a real whole number position along the vertical axis of the same Cartesian grid).";
    output &lt;&lt; "\nC = POINT(" &lt;&lt; C.get_X() &lt;&lt; "," &lt;&lt; C.get_Y() &lt;&lt; "). // C represents a point (which is neither A nor B nor D) plotted on a two-dimensional Cartesian grid (such that the X value represents a real whole number position along the horizontal axis of the Cartesian grid while Y represents a real whole number position along the vertical axis of the same Cartesian grid).";
    output &lt;&lt; "\na = B.get_distance_from(C) = " &lt;&lt; B.get_distance_from(C) &lt;&lt; ". // The method returns the approximate nonnegative real number of Cartesian grid unit lengths which span the length of the shortest path between points B and C.";
    output &lt;&lt; "\nb = C.get_distance_from(A) = " &lt;&lt; C.get_distance_from(A) &lt;&lt; ". // The method returns the approximate nonnegative real number of Cartesian grid unit lengths which span the length of the shortest path between points C and A.";
    output &lt;&lt; "\nc = A.get_distance_from(B) = " &lt;&lt; A.get_distance_from(B) &lt;&lt; ". // The method returns the approximate nonnegative real number of Cartesian grid unit lengths which span the length of the shortest path between points A and B.";
    output &lt;&lt; "\nslope_of_side_a = B.get_slope_of_line_to(C) = " &lt;&lt; B.get_slope_of_line_to(C) &lt;&lt; ". // The method returns the approximate nonnegative real number which represents the slope of the line which intersects points B and C.";
    output &lt;&lt; "\nslope_of_side_b = C.get_slope_of_line_to(A) = " &lt;&lt; C.get_slope_of_line_to(A) &lt;&lt; ". // The method returns the approximate nonnegative real number which represents the slope of the line which intersects points C and A.";
    output &lt;&lt; "\nslope_of_side_c = A.get_slope_of_line_to(B) = " &lt;&lt; A.get_slope_of_line_to(B) &lt;&lt; ". // The method returns the approximate nonnegative real number which represents the slope of the line which intersects points A and B.";
    output &lt;&lt; "\ninterior_angle_of_A = get_interior_angle_CAB() = " &lt;&lt; get_interior_angle_CAB() &lt;&lt; ". // The value represents the approximate nonnegative real number angle measurement of the acute or else right angle formed by the intersection of the line segment whose endpoints are C and A with the line segment whose endpoints are A and B such that those two line segments intersect at A (and the angle measurement is in degrees and not in radians).";
    output &lt;&lt; "\ninterior_angle_of_B = get_interior_angle_ABC() = " &lt;&lt; get_interior_angle_ABC() &lt;&lt; ". // The method returns the approximate nonnegative real number angle measurement of the acute or else right angle formed by the intersection of the line segment whose endpoints are A and B with the line segment whose endpoints are B and C such that those two line segments intersect at B (and the angle measurement is in degrees and not in radians).";
    output &lt;&lt; "\ninterior_angle_of_C = get_interior_angle_BCA() = " &lt;&lt; get_interior_angle_BCA() &lt;&lt; ". // The method returns the approximate nonnegative real number angle measurement of the acute or else right angle formed by the intersection of the line segment whose endpoints are B and C with the line segment whose endpoints are C and A such that those two line segments intersect at C (and the angle measurement is in degrees and not in radians).";
    output &lt;&lt; "\ninterior_angle_of_A + interior_angle_of_B + interior_angle_of_C = " &lt;&lt; get_interior_angle_CAB() + get_interior_angle_ABC() + get_interior_angle_BCA() &lt;&lt; ". // sum of all three approximate interior angle measurements of the trilateral represented by the caller TRILATERAL object (in degrees and not in radians)";
    output &lt;&lt; "\nget_perimeter() = a + b + c = " &lt;&lt; get_perimeter() &lt;&lt; ". // The method returns the sum of the three approximated side lengths of the trilateral which the caller TRILATERAL object represents.";
    output &lt;&lt; "\nget_area() = " &lt;&lt; get_area() &lt;&lt; ". // The method returns the approximate nonnegative real number of Cartesian grid unit squares which are enclosed inside of the two-dimensional region formed by the three line segments which connect points A to B, B to C, and C to A.";
    output &lt;&lt; "\n--------------------------------------------------------------------------------------------------";
}
    
/**
 * The friend function is an alternative to the print method.
 * The friend function overloads the ostream operator (i.e. &lt;&lt;).
 * 
 * The friend function is not a member of the TRILATERAL class,
 * but the friend function does have access to the private and protected members of the TRILATERAL class as though
 * the friend function was a member of the TRILATERAL class.
 */
std::ostream &amp; operator &lt;&lt; (std::ostream &amp; output, TRILATERAL &amp; trilateral)
{
    trilateral.print(output);
    return output;
}

/**
 * The destructor method of the TRILATERAL class de-allocates memory which was used to 
 * instantiate the TRILATERAL object which is calling this function.
 * 
 * The destructor method of the TRILATERAL class is automatically called when 
 * the program scope in which the caller TRILATERAL object was instantiated terminates.
 */
TRILATERAL::~TRILATERAL()
{
    std::cout &lt;&lt; "\n\nDeleting the TRILATERAL type object whose memory address is " &lt;&lt; this &lt;&lt; "...";  
}
</pre>
<hr />
<p><strong>RIGHT_TRILATERAL_CLASS_HEADER</strong></p>
<hr />
<p>The following header file contains the preprocessing directives and function prototypes of the RIGHT_TRILATREAL class.</p>
<p>C++_header_file: <a style="background: #000000;color: #00ff00" href="https://raw.githubusercontent.com/karlinarayberinger/KARLINA_OBJECT_summer_2023_starter_pack/main/right_trilateral.h" target="_blank" rel="noopener">https://raw.githubusercontent.com/karlinarayberinger/KARLINA_OBJECT_summer_2023_starter_pack/main/right_trilateral.h</a></p>
<hr />
<pre>/**
 * file: right_trilateral.h
 * type: C++ (header file)
 * date: 07_JULY_2023
 * author: karbytes
 * license: PUBLIC_DOMAIN
 */

// If right_trilateral.h has not already been linked to a source file (.cpp), then link this header file to the source file(s) which include this header file.
#ifndef RIGHT_TRILATERAL_H 
#define RIGHT_TRILATERAL_H

// Include the C++ header file which contains preprocessing directives, variable declarations, and function prototypes for the TRILATERAL class.
#include "trilateral.h" 

/**
 * RIGHT_TRILATERAL is a class which inherits the protected and public data
 * attributes and methods of TRILATERAL.
 * 
 * A RIGHT_TRILATERAL object represents an instance in which three unique POINT instances exist 
 * such that each one of those three POINT instances represents a unique coordinate pair within the tuple of three POINT instances 
 * (such that each coordinate pair represents exactly one two-dimensional point, POINT(X,Y), on a Cartesian grid) and
 * such that exactly one interior angle of the triangle which that RIGHT_TRILATERAL object represents is 90 degrees.
 * 
 * Each RIGHT_TRILATERAL object represents a specific three-sided polygon whose area is a positive real number.
 * 
 * (A synonym for "trilateral" is "triangle").
 * 
 * Class members which are set to the protected access specifier
 * are accessible to the base class and to derived classes.
 * 
 * Class members which are set to the private access specifier
 * are only accessible to the base class.
 * 
 * Class members which are set to the public access specifier
 * are accessible to any scope within the program where
 * the base class and its derived classes are implemented.
 */
class RIGHT_TRILATERAL: public TRILATERAL
{
protected:

    /**
     * category is a description of the POLYGON instance.
     * category is set to a constant (i.e. immutable) string type value.
     */
    const std::string category = "POLYGON/TRILATERAL/RIGHT_TRILATERAL";
    
public:
    
    /**
     * The default constructor of the RIGHT_TRILATERAL class calls the constructor of the TRILATERAL class and
     * sets the POINT type data member of the RIGHT_TRILATERAL object returned by this function named A to POINT(0,0), 
     * sets the POINT type data member of the RIGHT_TRILATERAL object returned by this function named B to POINT(0,1), and
     * sets the POINT type data member of the RIGHT_TRILATERAL object returned by this function named C to POINT(1,0).
     */
    RIGHT_TRILATERAL();
    
    /**
     * The normal constructor of RIGHT_TRILATERAL attempts to set
     * the string type data member of this to the input string type value named color and
     * the POINT type data member of this named A to the input POINT type value named A and
     * the POINT type data member of this named B to the input POINT type value named B and
     * the POINT type data member of this named C to the input POINT type value named C.
     * 
     * (The keyword this refers to the RIGHT_TRILATERAL object which is returned by this function).
     * 
     * If A, B, and C represent unique points on a Cartesian plane,
     * if the interior angles of the trilatreal which those points would represent add up to 180 degrees, 
     * if the area of the trilateral which those points represents is larger than zero, and
     * if one of the interior angles which the trilateral those points represnts is 90 degrees,
     * use the input POINT values as the POINT values for the RIGHT_TRILATERAL object which is returned by this function.
     */
    RIGHT_TRILATERAL(std::string color, POINT A, POINT B, POINT C);

    /**
     * The copy constructor method of the RIGHT_TRILATERAL class 
     * instantiates RIGHT_TRILATERAL type objects 
     * whose A value is set to the A value of the input RIGHT_TRILATERAL object,
     * whose B value is set to the B value of the input RIGHT_TRILATERAL object, and
     * whose C value is set to the C value of the input RIGHT_TRILATERAL object.
     */
    RIGHT_TRILATERAL(RIGHT_TRILATERAL &amp; right_trilateral);
    
    /** 
     * This method overrides the TRILATERAL class's print method.
     * 
     * The descriptor method prints a description of the caller RIGHT_TRILATERAL instance to the output stream.
     * 
     * If no function input is supplied, output is set to the command line terminal.
     */
    void print(std::ostream &amp; output = std::cout);
    
    /**
     * The friend function is an alternative to the print method.
     * The friend function overloads the ostream operator (i.e. &lt;&lt;).
     * 
     * The friend function is not a member of the RIGHT_TRILATERAL class,
     * but the friend function does have access to the private and protected members of the RIGHT_TRILATERAL class as though
     * the friend function was a member of the RIGHT_TRILATERAL class.
     */
    friend std::ostream &amp; operator &lt;&lt; (std::ostream &amp; output, RIGHT_TRILATERAL &amp; right_trilateral);

    /**
     * The destructor method of the RIGHT_TRILATERAL class de-allocates memory which was used to 
     * instantiate the RIGHT_TRILATERAL object which is calling this function.
     * 
     * The destructor method of the RIGHT_TRILATERAL class is automatically called when 
     * the program scope in which the caller RIGHT_TRILATERAL object was instantiated terminates.
     */
    ~RIGHT_TRILATERAL();
};

/* preprocessing directives */
#endif // Terminate the conditional preprocessing directives code block in this header file.
</pre>
<hr />
<p><strong>RIGHT_TRILATERAL_CLASS_SOURCE_CODE</strong></p>
<hr />
<p>The following source code defines the functions of the RIGHT_TRILATERAL class.</p>
<p>C++_source_file: <a style="background: #000000;color: #00ff00" href="https://raw.githubusercontent.com/karlinarayberinger/KARLINA_OBJECT_summer_2023_starter_pack/main/right_trilateral.cpp" target="_blank" rel="noopener">https://raw.githubusercontent.com/karlinarayberinger/KARLINA_OBJECT_summer_2023_starter_pack/main/right_trilateral.cpp</a></p>
<hr />
<pre>/**
 * file: right_trilateral.cpp
 * type: C++ (source file)
 * date: 07_JULY_2023
 * author: karbytes
 * license: PUBLIC_DOMAIN
 */

// Include the C++ header file which contains preprocessing directives, variable declarations, and function prototypes for the RIGHT_TRILATERAL class.
#include "right_trilateral.h" 

/**
 * The default constructor of the RIGHT_TRILATERAL class calls the constructor of the TRILATERAL class and
 * sets the POINT type data member of the RIGHT_TRILATERAL object returned by this function named A to POINT(0,0), 
 * sets the POINT type data member of the RIGHT_TRILATERAL object returned by this function named B to POINT(0,1), and
 * sets the POINT type data member of the RIGHT_TRILATERAL object returned by this function named C to POINT(1,0).
 */
RIGHT_TRILATERAL::RIGHT_TRILATERAL()
{
    std::cout &lt;&lt; "\n\nCreating the RIGHT_TRILATERAL type object whose memory address is " &lt;&lt; this &lt;&lt; "...";
    A = POINT(0,0);
    B = POINT(0,1);
    C = POINT(1,0);
}
    
/**
 * The normal constructor of RIGHT_TRILATERAL attempts to set
 * the string type data member of this to the input string type value named color and
 * the POINT type data member of this named A to the input POINT type value named A and
 * the POINT type data member of this named B to the input POINT type value named B and
 * the POINT type data member of this named C to the input POINT type value named C.
 * 
 * (The keyword this refers to the RIGHT_TRILATERAL object which is returned by this function).
 * 
 * If A, B, and C represent unique points on a Cartesian plane,
 * if the interior angles of the trilatreal which those points would represent add up to 180 degrees, 
 * if the area of the trilateral which those points represents is larger than zero, and
 * if one of the interior angles which the trilateral those points represnts is 90 degrees,
 * use the input POINT values as the POINT values for the RIGHT_TRILATERAL object which is returned by this function.
 */
RIGHT_TRILATERAL::RIGHT_TRILATERAL(std::string color, POINT A, POINT B, POINT C)
{
    bool is_right_triangle = false;
    int test_interior_angle_A = 0.0, test_interior_angle_B = 0.0, test_interior_angle_C = 0.0;
    std::cout &lt;&lt; "\n\nCreating the RIGHT_TRILATERAL type object whose memory address is " &lt;&lt; this &lt;&lt; "...";
    RIGHT_TRILATERAL test_right_trilateral;
    test_right_trilateral.A.set_X(A.get_X());
    test_right_trilateral.A.set_Y(A.get_Y());
    test_right_trilateral.B.set_X(B.get_X());
    test_right_trilateral.B.set_Y(B.get_Y());
    test_right_trilateral.C.set_X(C.get_X());
    test_right_trilateral.C.set_Y(C.get_Y());
    test_interior_angle_A = (int) floor(test_right_trilateral.get_interior_angle_CAB()); // coerce the data type to be int
    test_interior_angle_B = (int) floor(test_right_trilateral.get_interior_angle_ABC()); // coerce the data type to be int
    test_interior_angle_C = (int) floor(test_right_trilateral.get_interior_angle_BCA()); // coerce the data type to be int
    if ((test_interior_angle_A == 90) &amp;&amp; (test_interior_angle_B &lt; 90) &amp;&amp; (test_interior_angle_C &lt; 90)) is_right_triangle = true;
    if ((test_interior_angle_B == 90) &amp;&amp; (test_interior_angle_A &lt; 90) &amp;&amp; (test_interior_angle_C &lt; 90)) is_right_triangle = true;
    if ((test_interior_angle_C == 90) &amp;&amp; (test_interior_angle_A &lt; 90) &amp;&amp; (test_interior_angle_B &lt; 90)) is_right_triangle = true;
    if (test_right_trilateral.interior_angles_add_up_to_180_degrees() &amp;&amp; (test_right_trilateral.get_area() &gt; 0) &amp;&amp; (is_right_triangle))
    {
        this -&gt; A = A;
        this -&gt; B = B;
        this -&gt; C = C;
    }
    else
    {
        this -&gt; A = POINT(0,0);
        this -&gt; B = POINT(0,1);
        this -&gt; C = POINT(1,0);
    }
    this -&gt; color = color;
}

/**
 * The copy constructor method of the RIGHT_TRILATERAL class 
 * instantiates RIGHT_TRILATERAL type objects 
 * whose A value is set to the A value of the input RIGHT_TRILATERAL object,
 * whose B value is set to the B value of the input RIGHT_TRILATERAL object, and
 * whose C value is set to the C value of the input RIGHT_TRILATERAL object.
 */
RIGHT_TRILATERAL::RIGHT_TRILATERAL(RIGHT_TRILATERAL &amp; right_trilateral)
{
    std::cout &lt;&lt; "\n\nCreating the RIGHT_TRILATERAL type object whose memory address is " &lt;&lt; this &lt;&lt; "...";
    A = right_trilateral.A;
    B = right_trilateral.B;
    C = right_trilateral.C;
    color = right_trilateral.color;
}
    
/** 
 * This method overrides the TRILATERAL class's print method.
 * 
 * The descriptor method prints a description of the caller RIGHT_TRILATERAL instance to the output stream.
 * 
 * If no function input is supplied, output is set to the command line terminal.
 */
void RIGHT_TRILATERAL::print(std::ostream &amp; output)
{
    output &lt;&lt; "\n\n--------------------------------------------------------------------------------------------------";
    output &lt;&lt; "\nthis = " &lt;&lt; this &lt;&lt; ". // The keyword named this is a pointer which stores the memory address of the first memory cell of a RIGHT_TRILATERAL sized chunk of contiguous memory cells which are allocated to the caller RIGHT_TRILATERAL object.";
    output &lt;&lt; "\n&amp;category = " &lt;&lt; &amp;category &lt;&lt; ". // The reference operation returns the memory address of the first memory cell of a string sized chunk of contiguous memory cells which are allocated to the string data attribute named category.";
    output &lt;&lt; "\n&amp;color = " &lt;&lt; &amp;color &lt;&lt; ". // The reference operation returns the memory address of the first memory cell of a string sized chunk of contiguous memory cells which are allocated to the string data attribute named color..";
    output &lt;&lt; "\n&amp;A = " &lt;&lt; &amp;A &lt;&lt; ". // The reference operation returns the memory address of the first memory cell of a POINT sized chunk of contiguous memory cells which are allocated to the POINT data attribute named A.";
    output &lt;&lt; "\n&amp;B = " &lt;&lt; &amp;B &lt;&lt; ". // The reference operation returns the memory address of the first memory cell of a POINT sized chunk of contiguous memory cells which are allocated to the POINT data attribute named B.";
    output &lt;&lt; "\n&amp;C = " &lt;&lt; &amp;C &lt;&lt; ". // The reference operation returns the memory address of the first memory cell of a POINT sized chunk of contiguous memory cells which are allocated to the POINT data attribute named C.";
    output &lt;&lt; "\nsizeof(int) = " &lt;&lt; sizeof(int) &lt;&lt; ". // The sizeof() operation returns the nonnegative integer number of bytes of memory which an int type variable occupies. (Each memory cell has a data capacity of 1 byte).";
    output &lt;&lt; "\nsizeof(int *) = " &lt;&lt; sizeof(int *) &lt;&lt; ". // The sizeof() operation returns the nonnegative integer number of bytes of memory which a pointer-to-int type variable occupies. (Each memory cell has a data capacity of 1 byte).";
    output &lt;&lt; "\nsizeof(int **) = " &lt;&lt; sizeof(int **) &lt;&lt; ". // The sizeof() operation returns the nonnegative integer number of bytes of memory which an pointer-to-pointer-to-int type variable occupies. (Each memory cell has a data capacity of 1 byte).";
    output &lt;&lt; "\nsizeof(std::string) = " &lt;&lt; sizeof(std::string) &lt;&lt; ". // The sizeof() operation returns the nonnegative integer number of bytes of memory which a string type variable occupies. (Each memory cell has a data capacity of 1 byte).";
    output &lt;&lt; "\nsizeof(std::string *) = " &lt;&lt; sizeof(std::string *) &lt;&lt; ". // The sizeof() operation returns the nonnegative integer number of bytes of memory which a pointer-to-string type variable occupies. (Each memory cell has a data capacity of 1 byte).";
    output &lt;&lt; "\nsizeof(std::string **) = " &lt;&lt; sizeof(std::string **) &lt;&lt; ". // The sizeof() operation returns the nonnegative integer number of bytes of memory which a pointer-to-pointer-to-string type variable occupies. (Each memory cell has a data capacity of 1 byte).";
    output &lt;&lt; "\nsizeof(POINT) = " &lt;&lt; sizeof(POINT) &lt;&lt; ". // The sizeof() operation returns the nonnegative integer number of bytes of memory which a POINT type object occupies. (Each memory cell has a data capacity of 1 byte).";
    output &lt;&lt; "\nsizeof(POINT *) = " &lt;&lt; sizeof(POINT *) &lt;&lt; ". // The sizeof() operation returns the nonnegative integer number of bytes of memory which a pointer-to-POINT type variable occupies. (Each memory cell has a data capacity of 1 byte).";
    output &lt;&lt; "\nsizeof(POINT **) = " &lt;&lt; sizeof(POINT **) &lt;&lt; ". // The sizeof() operation returns the nonnegative integer number of bytes of memory which a pointer-to-pointer-to-POINT type variable occupies. (Each memory cell has a data capacity of 1 byte).";
    output &lt;&lt; "\nsizeof(POLYGON) = " &lt;&lt; sizeof(POLYGON) &lt;&lt; ". // The sizeof() operation returns the nonnegative integer number of bytes of memory which a POLYGON type object occupies. (Each memory cell has a data capacity of 1 byte).";
    output &lt;&lt; "\nsizeof(POLYGON *) = " &lt;&lt; sizeof(POLYGON *) &lt;&lt; ". // The sizeof() operation returns the nonnegative integer number of bytes of memory which a pointer-to-POLYGON type variable occupies. (Each memory cell has a data capacity of 1 byte).";
    output &lt;&lt; "\nsizeof(POLYGON **) = " &lt;&lt; sizeof(POLYGON **) &lt;&lt; ". // The sizeof() operation returns the nonnegative integer number of bytes of memory which a pointer-to-pointer-to-POLYGON type variable occupies. (Each memory cell has a data capacity of 1 byte).";
    output &lt;&lt; "\nsizeof(TRILATERAL) = " &lt;&lt; sizeof(TRILATERAL) &lt;&lt; ". // The sizeof() operation returns the nonnegative integer number of bytes of memory which a TRILATERAL type object occupies. (Each memory cell has a data capacity of 1 byte).";
    output &lt;&lt; "\nsizeof(TRILATERAL *) = " &lt;&lt; sizeof(TRILATERAL *) &lt;&lt; ". // The sizeof() operation returns the nonnegative integer number of bytes of memory which a pointer-to-TRILATERAL type variable occupies. (Each memory cell has a data capacity of 1 byte).";
    output &lt;&lt; "\nsizeof(TRILATERAL **) = " &lt;&lt; sizeof(TRILATERAL **) &lt;&lt; ". // The sizeof() operation returns the nonnegative integer number of bytes of memory which a pointer-to-pointer-to-TRILATERAL type variable occupies. (Each memory cell has a data capacity of 1 byte).";
    output &lt;&lt; "\nsizeof(RIGHT_TRILATERAL) = " &lt;&lt; sizeof(RIGHT_TRILATERAL) &lt;&lt; ". // The sizeof() operation returns the nonnegative integer number of bytes of memory which a RIGHT_TRILATERAL type object occupies. (Each memory cell has a data capacity of 1 byte).";
    output &lt;&lt; "\nsizeof(RIGHT_TRILATERAL *) = " &lt;&lt; sizeof(RIGHT_TRILATERAL *) &lt;&lt; ". // The sizeof() operation returns the nonnegative integer number of bytes of memory which a pointer-to-RIGHT_TRILATERAL type variable occupies. (Each memory cell has a data capacity of 1 byte).";
    output &lt;&lt; "\nsizeof(RIGHT_TRILATERAL **) = " &lt;&lt; sizeof(RIGHT_TRILATERAL **) &lt;&lt; ". // The sizeof() operation returns the nonnegative integer number of bytes of memory which a pointer-to-pointer-to-RIGHT_TRILATERAL type variable occupies. (Each memory cell has a data capacity of 1 byte).";
    output &lt;&lt; "\ncategory = " &lt;&lt; category &lt;&lt; ". // This is an immutable string type value which is a data member of the caller RIGHT_TRILATERAL object.";
    output &lt;&lt; "\ncolor = " &lt;&lt; color &lt;&lt; ". // This is a string type value which is a data member of the caller RIGHT_TRILATERAL object.";
    output &lt;&lt; "\nA = POINT(" &lt;&lt; A.get_X() &lt;&lt; "," &lt;&lt; A.get_Y() &lt;&lt; "). // A represents a point (which is neither B nor C nor D) plotted on a two-dimensional Cartesian grid (such that the X value represents a real whole number position along the horizontal axis of the Cartesian grid while Y represents a real whole number position along the vertical axis of the same Cartesian grid).";
    output &lt;&lt; "\nB = POINT(" &lt;&lt; B.get_X() &lt;&lt; "," &lt;&lt; B.get_Y() &lt;&lt; "). // B represents a point (which is neither A nor C nor D) plotted on a two-dimensional Cartesian grid (such that the X value represents a real whole number position along the horizontal axis of the Cartesian grid while Y represents a real whole number position along the vertical axis of the same Cartesian grid).";
    output &lt;&lt; "\nC = POINT(" &lt;&lt; C.get_X() &lt;&lt; "," &lt;&lt; C.get_Y() &lt;&lt; "). // C represents a point (which is neither A nor B nor D) plotted on a two-dimensional Cartesian grid (such that the X value represents a real whole number position along the horizontal axis of the Cartesian grid while Y represents a real whole number position along the vertical axis of the same Cartesian grid).";
    output &lt;&lt; "\na = B.get_distance_from(C) = " &lt;&lt; B.get_distance_from(C) &lt;&lt; ". // The method returns the approximate nonnegative real number of Cartesian grid unit lengths which span the length of the shortest path between points B and C.";
    output &lt;&lt; "\nb = C.get_distance_from(A) = " &lt;&lt; C.get_distance_from(A) &lt;&lt; ". // The method returns the approximate nonnegative real number of Cartesian grid unit lengths which span the length of the shortest path between points C and A.";
    output &lt;&lt; "\nc = A.get_distance_from(B) = " &lt;&lt; A.get_distance_from(B) &lt;&lt; ". // The method returns the approximate nonnegative real number of Cartesian grid unit lengths which span the length of the shortest path between points A and B.";
    output &lt;&lt; "\nslope_of_side_a = B.get_slope_of_line_to(C) = " &lt;&lt; B.get_slope_of_line_to(C) &lt;&lt; ". // The method returns the approximate nonnegative real number which represents the slope of the line which intersects points B and C.";
    output &lt;&lt; "\nslope_of_side_b = C.get_slope_of_line_to(A) = " &lt;&lt; C.get_slope_of_line_to(A) &lt;&lt; ". // The method returns the approximate nonnegative real number which represents the slope of the line which intersects points C and A.";
    output &lt;&lt; "\nslope_of_side_c = A.get_slope_of_line_to(B) = " &lt;&lt; A.get_slope_of_line_to(B) &lt;&lt; ". // The method returns the approximate nonnegative real number which represents the slope of the line which intersects points A and B.";
    output &lt;&lt; "\ninterior_angle_of_A = get_interior_angle_CAB() = " &lt;&lt; get_interior_angle_CAB() &lt;&lt; ". // The value represents the approximate nonnegative real number angle measurement of the acute or else right angle formed by the intersection of the line segment whose endpoints are C and A with the line segment whose endpoints are A and B such that those two line segments intersect at A (and the angle measurement is in degrees and not in radians).";
    output &lt;&lt; "\ninterior_angle_of_B = get_interior_angle_ABC() = " &lt;&lt; get_interior_angle_ABC() &lt;&lt; ". // The method returns the approximate nonnegative real number angle measurement of the acute or else right angle formed by the intersection of the line segment whose endpoints are A and B with the line segment whose endpoints are B and C such that those two line segments intersect at B (and the angle measurement is in degrees and not in radians).";
    output &lt;&lt; "\ninterior_angle_of_C = get_interior_angle_BCA() = " &lt;&lt; get_interior_angle_BCA() &lt;&lt; ". // The method returns the approximate nonnegative real number angle measurement of the acute or else right angle formed by the intersection of the line segment whose endpoints are B and C with the line segment whose endpoints are C and A such that those two line segments intersect at C (and the angle measurement is in degrees and not in radians).";
    output &lt;&lt; "\ninterior_angle_of_A + interior_angle_of_B + interior_angle_of_C = " &lt;&lt; get_interior_angle_CAB() + get_interior_angle_ABC() + get_interior_angle_BCA() &lt;&lt; ". // sum of all three approximate interior angle measurements of the trilateral represented by the caller TRILATERAL object (in degrees and not in radians)";
    output &lt;&lt; "\nget_perimeter() = a + b + c = " &lt;&lt; get_perimeter() &lt;&lt; ". // The method returns the sum of the three approximated side lengths of the trilateral which the caller TRILATERAL object represents.";
    output &lt;&lt; "\nget_area() = " &lt;&lt; get_area() &lt;&lt; ". // The method returns the approximate nonnegative real number of Cartesian grid unit squares which are enclosed inside of the two-dimensional region formed by the three line segments which connect points A to B, B to C, and C to A.";
    output &lt;&lt; "\n--------------------------------------------------------------------------------------------------";
}
    
/**
 * The friend function is an alternative to the print method.
 * The friend function overloads the ostream operator (i.e. &lt;&lt;).
 * 
 * The friend function is not a member of the RIGHT_TRILATERAL class,
 * but the friend function does have access to the private and protected members of the RIGHT_TRILATERAL class as though
 * the friend function was a member of the RIGHT_TRILATERAL class.
 */
std::ostream &amp; operator &lt;&lt; (std::ostream &amp; output, RIGHT_TRILATERAL &amp; right_trilateral)
{
    right_trilateral.print(output);
    return output;
}

/**
 * The destructor method of the RIGHT_TRILATERAL class de-allocates memory which was used to 
 * instantiate the RIGHT_TRILATERAL object which is calling this function.
 * 
 * The destructor method of the RIGHT_TRILATERAL class is automatically called when 
 * the program scope in which the caller RIGHT_TRILATERAL object was instantiated terminates.
 */
RIGHT_TRILATERAL::~RIGHT_TRILATERAL()
{
    std::cout &lt;&lt; "\n\nDeleting the RIGHT_TRILATERAL type object whose memory address is " &lt;&lt; this &lt;&lt; "...";  
}
</pre>
<hr />
<p><strong>PROGRAM_SOURCE_CODE</strong></p>
<hr />
<p>The following source code defines the client which implements the POINT class, the POLYGON class, the QUADRILATERAL class, the TRAPEZOID class, the RECTANGLE class, the SQUARE class, the TRILATERAL class, and the RIGHT_TRILATERAL class. The client executes a series of unit tests which demonstrate how the  methods of those classes work.</p>
<p>C++_source_file: <a style="background: #000000;color: #00ff00" href="https://raw.githubusercontent.com/karlinarayberinger/KARLINA_OBJECT_summer_2023_starter_pack/main/polygon_class_inheritance_tester.cpp" target="_blank" rel="noopener">https://raw.githubusercontent.com/karlinarayberinger/KARLINA_OBJECT_summer_2023_starter_pack/main/polygon_class_inheritance_tester.cpp</a></p>
<hr />
<pre>/**
 * file: polygon_class_inheritance_tester.cpp
 * type: C++ (source file)
 * date: 07_JULY_2023
 * author: karbytes
 * license: PUBLIC_DOMAIN 
 */

#include "polygon.h" // Include the C++ header file which contains preprocessing directives, variable declarations, and function prototypes for the POLYGON class.
#include "quadrilateral.h" // Include the C++ header file which contains preprocessing directives, variable declarations, and function prototypes for the QUADRILATERAL class.
#include "trapezoid.h" // Include the C++ header file which contains preprocessing directives, variable declarations, and function prototypes for the TRAPEZOID class.
#include "rectangle.h" // Include the C++ header file which contains preprocessing directives, variable declarations, and function prototypes for the RECTANGLE class.
#include "square.h" // Include the C++ header file which contains preprocessing directives, variable declarations, and function prototypes for the SQUARE class.
#include "trilateral.h" // Include the C++ header file which contains preprocessing directives, variable declarations, and function prototypes for the TRILATERAL class.
#include "right_trilateral.h" // Include the C++ header file which contains preprocessing directives, variable declarations, and function prototypes for the RIGHT_TRILATERAL class.

/* function prototypes */
void unit_test_0(std::ostream &amp; output);
void unit_test_1(std::ostream &amp; output);
void unit_test_2(std::ostream &amp; output);
void unit_test_3(std::ostream &amp; output);
void unit_test_4(std::ostream &amp; output);
void unit_test_5(std::ostream &amp; output);
void unit_test_6(std::ostream &amp; output);
void unit_test_7(std::ostream &amp; output);
void unit_test_8(std::ostream &amp; output);
void unit_test_9(std::ostream &amp; output);
void unit_test_10(std::ostream &amp; output);
void unit_test_11(std::ostream &amp; output);
void unit_test_12(std::ostream &amp; output);
void unit_test_13(std::ostream &amp; output);
void unit_test_14(std::ostream &amp; output);
void unit_test_15(std::ostream &amp; output);
void unit_test_16(std::ostream &amp; output);
void unit_test_17(std::ostream &amp; output);
void unit_test_18(std::ostream &amp; output);
void unit_test_19(std::ostream &amp; output);
void unit_test_20(std::ostream &amp; output);
void unit_test_21(std::ostream &amp; output);
void unit_test_22(std::ostream &amp; output);
void unit_test_23(std::ostream &amp; output);
void unit_test_24(std::ostream &amp; output);
void unit_test_25(std::ostream &amp; output);
void unit_test_26(std::ostream &amp; output);
void unit_test_27(std::ostream &amp; output);
void unit_test_28(std::ostream &amp; output);
void unit_test_29(std::ostream &amp; output);

/**
 * Unit Test # 0: Create a pointer-to-POLYGON type variable to store the memory address of a dynamically allocated QUADRILATERAL instance. 
 * Use that pointer-to-POLYGON type variable to call the print method of the POLYGON class and the getter methods of the POLYGON class.
 */
void unit_test_0(std::ostream &amp; output) 
{
    output &lt;&lt; "\n\n--------------------------------------------------------------------------------------------------";
    output &lt;&lt; "\nUnit Test # 0: Create a pointer-to-POLYGON type variable to store the memory address of a dynamically allocated QUADRILATERAL instance. Use that pointer-to-POLYGON type variable to call the print method of the POLYGON class and the getter methods of the POLYGON class.";
    output &lt;&lt; "\n--------------------------------------------------------------------------------------------------";
    output &lt;&lt; "\n// COMMENTED OUT: POLYGON polygon; // This command does not work because POLYGON is an abstract class.";
    output &lt;&lt; "\nPOLYGON * pointer_to_polygon; // The pointer-to-POLYGON type variable can store the memory address of an object whose data type is a non-abstract derived class of POLYGON such as QUADRILATERAL.";
    output &lt;&lt; "\npointer_to_polygon = new QUADRILATERAL; // Assign memory to a dynamic QUADRILATERAL instance (i.e. and dynamic implies that the variable was created during program runtime instead of program compile time).";
    output &lt;&lt; "\npointer_to_polygon -&gt; print(output); // Indirectly call the POLYGON print method.";
    // COMMENTED OUT: POLYGON polygon; // This command does not work because POLYGON is an abstract class.
    POLYGON * pointer_to_polygon; // The pointer-to-POLYGON type variable can store the memory address of an object whose data type is a non-abstract derived class of POLYGON such as QUADRILATERAL.
    pointer_to_polygon = new QUADRILATERAL; // Assign memory to a dynamic QUADRILATERAL instance (i.e. and dynamic implies that the variable was created during program runtime instead of program compile time).
    pointer_to_polygon -&gt; print(output); // Indirectly call the POLYGON print method.
    output &lt;&lt; "\npointer_to_polygon -&gt; get_area() = " &lt;&lt; pointer_to_polygon -&gt; get_area() &lt;&lt; ". // Indirectly call the POLYGON get_area() method.";
    output &lt;&lt; "\npointer_to_polygon -&gt; get_perimeter() = " &lt;&lt; pointer_to_polygon -&gt; get_perimeter() &lt;&lt; ". // Indirectly call the POLYGON get_permieter() method.";
    output &lt;&lt; "\ndelete pointer_to_polygon; // De-allocate memory which was assigned to the dynamically allocated QUADRILATERAL instance.";
    output &lt;&lt; "\n--------------------------------------------------------------------------------------------------";
    delete pointer_to_polygon; // De-allocate memory which was assigned to the dynamically allocated QUADRILATERAL instance.
}

/**
 * Unit Test # 1: Test the default QUADRILATERAL constructor and the QUADRILATERAL print method.
 */
void unit_test_1(std::ostream &amp; output)
{
    output &lt;&lt; "\n--------------------------------------------------------------------------------------------------";
    output &lt;&lt; "\nUnit Test # 1: Test the default QUADRILATERAL constructor and the QUADRILATERAL print method.";
    output &lt;&lt; "\n--------------------------------------------------------------------------------------------------";
    output &lt;&lt; "\nQUADRILATERAL quadrilateral;";
    output &lt;&lt; "\nquadrilateral.print(); // Test the default argument (which is std::cout).";
    output &lt;&lt; "\nquadrilateral.print(output);";
    output &lt;&lt; "\noutput &lt;&lt; quadrilateral; // overloaded ostream operator as defined in quadrilateral.cpp";
    output &lt;&lt; "\n--------------------------------------------------------------------------------------------------";
    QUADRILATERAL quadrilateral;
    quadrilateral.print(); // Test the default argument (which is std::cout).
    quadrilateral.print(output);
    output &lt;&lt; quadrilateral; // overloaded ostream operator as defined in quadrilateral.cpp
}

/** 
 * Unit Test # 2: Create a pointer-to-POLYGON type variable to store the memory address of a dynamically allocated QUADRILATERAL instance. 
 * Use that pointer-to-POLYGON to call the overloaded ostream operator method of the POLYGON class (and not of the QUADRILATERAL class).
 */
void unit_test_2(std::ostream &amp; output)
{
    output &lt;&lt; "\n--------------------------------------------------------------------------------------------------";
    output &lt;&lt; "\nUnit Test # 2: Create a pointer-to-POLYGON type variable to store the memory address of a dynamically allocated QUADRILATERAL instance. Use that pointer-to-POLYGON to call the overloaded ostream operator method of the POLYGON class (and not of the QUADRILATERAL class).";
    output &lt;&lt; "\n--------------------------------------------------------------------------------------------------";
    output &lt;&lt; "\n// COMMENTED OUT: POLYGON polygon; // This command does not work because POLYGON is an abstract class.";
    output &lt;&lt; "\nPOLYGON * pointer_to_polygon; // The pointer-to-POLYGON type variable can store the memory address of an object whose data type is a non-abstract derived class of POLYGON such as QUADRILATERAL.";
    output &lt;&lt; "\npointer_to_polygon = new QUADRILATERAL; // Assign memory to a dynamic QUADRILATERAL instance (i.e. and dynamic implies that the variable was created during program runtime instead of program compile time).";
    output &lt;&lt; "\noutput &lt;&lt; * pointer_to_polygon; // Use the overloaded ostream operator as defined in polygon.cpp to print the data which is stored at the memory address which pointer_to_polygon stores.";
    output &lt;&lt; "\ndelete pointer_to_polygon; // De-allocate memory which was assigned to the dynamically allocated QUADRILATERAL instance.";
    output &lt;&lt; "\n--------------------------------------------------------------------------------------------------";
    // COMMENTED OUT: POLYGON polygon; // This command does not work because POLYGON is an abstract class.";
    POLYGON * pointer_to_polygon; // The pointer-to-polygon type variable can store the memory address of an object whose data type is a non-abstract derived class of POLYGON such as QUADRILATERAL.
    pointer_to_polygon = new QUADRILATERAL; // Assign memory to a dynamic QUADRILATERAL instance (i.e. and dynamic implies that the variable was created during program runtime instead of program compile time).
    output &lt;&lt; * pointer_to_polygon; // Use the overloaded ostream operator as defined in polygon.cpp to print the data which is stored at the memory address which pointer_to_polygon stores.
    delete pointer_to_polygon; // De-allocate memory which was assigned to the dynamically allocated QUADRILATERAL instance.
}

/** 
 * Unit Test # 3: Unit Test # 3: Create a pointer-to-QUADRILATERAL type variable to store the memory address of a dynamically allocated QUADRILATERAL instance. 
 * Use that pointer-to-QUADRILATERAL to call the overloaded ostream operator method of the QUADRILATERAL class and the public getter methods of the QUADRILATERAL class.
 */
void unit_test_3(std::ostream &amp; output)
{
    output &lt;&lt; "\n--------------------------------------------------------------------------------------------------";
    output &lt;&lt; "\nUnit Test # 3: Create a pointer-to-QUADRILATERAL type variable to store the memory address of a dynamically allocated QUADRILATERAL instance. Use that pointer-to-QUADRILATERAL to call the overloaded ostream operator method of the QUADRILATERAL class and the public getter methods of the QUADRILATERAL class.";
    output &lt;&lt; "\n--------------------------------------------------------------------------------------------------";
    output &lt;&lt; "\nQUADRILATERAL * pointer_to_quadrilateral; // The pointer-to-QUADRILATERAL type variable can store the memory address of an object whose data type is QUADRILATERAL or else a non-abstract derived class of QUADRILATERAL such as TRAPEZOID.";
    output &lt;&lt; "\npointer_to_quadrilateral = new QUADRILATERAL; // Assign memory to a dynamic QUADRILATERAL instance (i.e. and dynamic implies that the variable was created during program runtime instead of program compile time).";
    output &lt;&lt; "\noutput &lt;&lt; * pointer_to_quadrilateral; // Use the overloaded ostream operator as defined in quadrilateral.cpp to print the data which is stored at the memory address which pointer_to_quadrilateral stores.";
    output &lt;&lt; "\ndelete pointer_to_quadrilateral; // De-allocate memory which was assigned to the dynamically allocated QUADRILATERAL instance.";
    output &lt;&lt; "\n--------------------------------------------------------------------------------------------------";
    QUADRILATERAL * pointer_to_quadrilateral; // The pointer-to-QUADRATERAL type variable can store the memory address of an object whose data type is QUADRILATERAL or else a non-abstract derived class of QUADRILATERAL such as TRAPEZOID.
    pointer_to_quadrilateral = new QUADRILATERAL; // Assign memory to a dynamic QUADRILATERAL instance (i.e. and dynamic implies that the variable was created during program runtime instead of program compile time).
    output &lt;&lt; * pointer_to_quadrilateral; // Use the overloaded ostream operator as defined in quadrilateral.cpp to print the data which is stored at the memory address which pointer_to_quadrilateral stores.
    output &lt;&lt; "\n--------------------------------------------------------------------------------------------------";
    output &lt;&lt; "\npointer_to_quadrilateral -&gt; get_area() = " &lt;&lt; pointer_to_quadrilateral -&gt; get_area() &lt;&lt; ". // Indirectly call the get_area() method of the QUADRILATERAL class.";
    output &lt;&lt; "\npointer_to_quadrilateral -&gt; get_perimeter() = " &lt;&lt; pointer_to_quadrilateral -&gt; get_perimeter() &lt;&lt; ". // Indirectly call the get_perimeter() method of the QUADRILATERAL class.";
    delete pointer_to_quadrilateral; // De-allocate memory which was assigned to the dynamically allocated QUADRILATERAL instance.
}

/**
 * Unit Test # 4: Test the normal QUADRILATERAL constructor and QUADRILATERAL copy constructor using valid function inputs and the QUADRILATERAL print method.
 */
void unit_test_4(std::ostream &amp; output)
{
    output &lt;&lt; "\n--------------------------------------------------------------------------------------------------";
    output &lt;&lt; "\nUnit Test # 4: Test the normal QUADRILATERAL constructor and QUADRILATERAL copy constructor using valid function inputs and the QUADRILATERAL print method.";
    output &lt;&lt; "\n--------------------------------------------------------------------------------------------------";
    output &lt;&lt; "\nQUADRILATERAL quadrilateral_0 = QUADRILATERAL(\"green\", POINT(-2,-2), POINT(-2,2), POINT(2,2), POINT(2,-2));";
    output &lt;&lt; "\nquadrilateral_0.print(output);";
    output &lt;&lt; "\nQUADRILATERAL quadrilateral_1 = QUADRILATERAL(\"blue\", POINT(0,0), POINT(3,2), POINT(5,1), POINT(-1,-2));";
    output &lt;&lt; "\nquadrilateral_1.print(output);";
    output &lt;&lt; "\nQUADRILATERAL quadrilateral_2 = QUADRILATERAL(quadrilateral_0);";
    output &lt;&lt; "\nquadrilateral_2.print(output);";
    output &lt;&lt; "\n--------------------------------------------------------------------------------------------------";
    QUADRILATERAL quadrilateral_0 = QUADRILATERAL("green", POINT(-2,-2), POINT(-2,2), POINT(2,2), POINT(2,-2));
    quadrilateral_0.print(output);
    QUADRILATERAL quadrilateral_1 = QUADRILATERAL("blue", POINT(0,0), POINT(3,2), POINT(5,1), POINT(-1,-2));
    quadrilateral_1.print(output);
    QUADRILATERAL quadrilateral_2 = QUADRILATERAL(quadrilateral_0);
    quadrilateral_2.print(output);
}

/**
 * Unit Test # 5: Test the normal QUADRILATERAL constructor using invalid function inputs and the QUADRILATERAL print method.
 */
void unit_test_5(std::ostream &amp; output)
{
    output &lt;&lt; "\n--------------------------------------------------------------------------------------------------";
    output &lt;&lt; "\nUnit Test # 5: Test the normal QUADRILATERAL constructor using invalid function inputs and the QUADRILATERAL print method.";
    output &lt;&lt; "\n--------------------------------------------------------------------------------------------------";
    output &lt;&lt; "\nQUADRILATERAL quadrilateral_0 = QUADRILATERAL(\"red\", POINT(-2,-2), POINT(0,0), POINT(1,1), POINT(2,2)); // A line intersects all four points.";
    output &lt;&lt; "\nquadrilateral_0.print(output);";
    output &lt;&lt; "\nQUADRILATERAL quadrilateral_1 = QUADRILATERAL(\"purple\", POINT(0,0), POINT(3,2), POINT(0,0), POINT(-1,-2)); // Not all point coordinate pairs are unique.";
    output &lt;&lt; "\nquadrilateral_1.print(output);";
    output &lt;&lt; "\nQUADRILATERAL quadrilateral_2 = QUADRILATERAL(\"yellow\", POINT(0,0), POINT(0,2), POINT(4,0), POINT(4,2)); // The points form a bow-tie shaped polygon.";
    output &lt;&lt; "\nquadrilateral_2.print(output);";
    output &lt;&lt; "\n--------------------------------------------------------------------------------------------------";
    QUADRILATERAL quadrilateral_0 = QUADRILATERAL("red", POINT(-2,-2), POINT(0,0), POINT(1,1), POINT(2,2)); // A line intersects all four points.
    quadrilateral_0.print(output);
    QUADRILATERAL quadrilateral_1 = QUADRILATERAL("purple", POINT(0,0), POINT(3,2), POINT(0,0), POINT(-1,-2)); // Not all point coordinate pairs are unique.
    quadrilateral_1.print(output);
    QUADRILATERAL quadrilateral_2 = QUADRILATERAL("yellow", POINT(0,0), POINT(0,2), POINT(4,0), POINT(4,2)); // The points form a bow-tie shaped polygon.
    quadrilateral_2.print(output);
}

/**
 * Unit Test # 6: Test the default TRAPEZOID constructor and the TRAPEZOID print method.
 */
void unit_test_6(std::ostream &amp; output)
{
    output &lt;&lt; "\n--------------------------------------------------------------------------------------------------";
    output &lt;&lt; "\nUnit Test # 6: Test the default TRAPEZOID constructor and the TRAPEZOID print method.";
    output &lt;&lt; "\n--------------------------------------------------------------------------------------------------";
    output &lt;&lt; "\nTRAPEZOID trapezoid;";
    output &lt;&lt; "\ntrapezoid.print(); // Test the default argument (which is std::cout).";
    output &lt;&lt; "\ntrapezoid.print(output);";
    output &lt;&lt; "\noutput &lt;&lt; trapezoid; // overloaded ostream operator as defined in trapezoid.cpp";
    output &lt;&lt; "\n--------------------------------------------------------------------------------------------------";
    TRAPEZOID trapezoid;
    trapezoid.print(); // Test the default argument (which is std::cout).
    trapezoid.print(output);
    output &lt;&lt; trapezoid; // overloaded ostream operator as defined in trapezoid.cpp
}

/**
 * Unit Test # 7: Create a pointer-to-POLYGON type variable to store the memory address of a dynamically allocated TRAPEZOID instance. 
 * Use that pointer-to-POLYGON type variable to call the POLYGON print method and the POLYGON getter methods.
 */
void unit_test_7(std::ostream &amp; output) 
{
    output &lt;&lt; "\n\n--------------------------------------------------------------------------------------------------";
    output &lt;&lt; "\nUnit Test # 7: Create a pointer-to-POLYGON type variable to store the memory address of a dynamically allocated TRAPEZOID instance. Use that pointer-to-POLYGON type variable to call the POLYGON print method and the POLYGON getter methods.";
    output &lt;&lt; "\n--------------------------------------------------------------------------------------------------";
    output &lt;&lt; "\n// COMMENTED OUT: POLYGON polygon; // This command does not work because POLYGON is an abstract class.";
    output &lt;&lt; "\nPOLYGON * pointer_to_polygon; // The pointer-to-POLYGON type variable can store the memory address of an object whose data type is a non-abstract derived class of POLYGON such as TRAPEZOID.";
    output &lt;&lt; "\npointer_to_polygon = new TRAPEZOID; // Assign memory to a dynamic TRAPEZOID instance (i.e. and dynamic implies that the variable was created during program runtime instead of program compile time).";
    output &lt;&lt; "\npointer_to_polygon -&gt; print(output); // Indirectly call the POLYGON print method.";
    // COMMENTED OUT: POLYGON polygon; // This command does not work because POLYGON is an abstract class.
    POLYGON * pointer_to_polygon; // The pointer-to-POLYGON type variable can store the memory address of an object whose data type is a non-abstract derived class of POLYGON such as TRAPEZOID.
    pointer_to_polygon = new TRAPEZOID; // Assign memory to a dynamic TRAPEZOID instance (i.e. and dynamic implies that the variable was created during program runtime instead of program compile time).
    pointer_to_polygon -&gt; print(output); // Indirectly call the POLYGON print method.
    output &lt;&lt; "\npointer_to_polygon -&gt; get_area() = " &lt;&lt; pointer_to_polygon -&gt; get_area() &lt;&lt; ". // Indirectly call the POLYGON get_area() method.";
    output &lt;&lt; "\npointer_to_polygon -&gt; get_perimeter() = " &lt;&lt; pointer_to_polygon -&gt; get_perimeter() &lt;&lt; ". // Indirectly call the POLYGON get_permieter() method.";
    output &lt;&lt; "\ndelete pointer_to_polygon; // De-allocate memory which was assigned to the dynamically allocated TRAPEZOID instance.";
    output &lt;&lt; "\n--------------------------------------------------------------------------------------------------";
    delete pointer_to_polygon; // De-allocate memory which was assigned to the dynamically allocated TRAPEZOID instance.
}

/**
 * Unit Test # 8: Create a pointer-to-QUADRILATERAL type variable to store the memory address of a dynamically allocated TRAPEZOID instance. 
 * Use that pointer-to-QUADRILATERAL type variable to call the QUADRILATERAL print method.
 */
void unit_test_8(std::ostream &amp; output) 
{
    output &lt;&lt; "\n\n--------------------------------------------------------------------------------------------------";
    output &lt;&lt; "\nUnit Test # 8: Create a pointer-to-QUADRILATERAL type variable to store the memory address of a dynamically allocated TRAPEZOID instance. Use that pointer-to-QUADRILATERAL type variable to call the QUADRILATERAL print method.";
    output &lt;&lt; "\n--------------------------------------------------------------------------------------------------";
    output &lt;&lt; "\nQUADRILATERAL * pointer_to_quadrilateral; // The pointer-to-QUADRILATERAL type variable can store the memory address of an object whose data type is a non-abstract derived class of QUADRILATERAL such as TRAPEZOID.";
    output &lt;&lt; "\npointer_to_quadrilateral = new TRAPEZOID; // Assign memory to a dynamic TRAPEZOID instance (i.e. and dynamic implies that the variable was created during program runtime instead of program compile time).";
    output &lt;&lt; "\npointer_to_quadrilateral -&gt; print(output); // Indirectly call the QUADRILATERAL print method.";
    output &lt;&lt; "\ndelete pointer_to_quadrilateral; // De-allocate memory which was assigned to the dynamically allocated TRAPEZOID instance.";
    output &lt;&lt; "\n--------------------------------------------------------------------------------------------------";
    QUADRILATERAL * pointer_to_quadrilateral; // The pointer-to-QUADRILATERAL type variable can store the memory address of an object whose data type is a non-abstract derived class of QUADRILATERAL such as TRAPEZOID.
    pointer_to_quadrilateral = new TRAPEZOID; // Assign memory to a dynamic TRAPEZOID instance (i.e. and dynamic implies that the variable was created during program runtime instead of program compile time).
    pointer_to_quadrilateral -&gt; print(output); // Indirectly call the QUADRILATERAL print method.
    delete pointer_to_quadrilateral; // De-allocate memory which was assigned to the dynamically allocated TRAPEZOID instance.
}

/**
 * Unit Test # 9: Test the normal TRAPEZOID constructor and TRAPEZOID copy constructor using valid function inputs and the TRAPEZOID print method.
 */
void unit_test_9(std::ostream &amp; output)
{
    output &lt;&lt; "\n--------------------------------------------------------------------------------------------------";
    output &lt;&lt; "\nUnit Test # 9: Test the normal TRAPEZOID constructor and TRAPEZOID copy constructor using valid function inputs and the TRAPEZOID print method.";
    output &lt;&lt; "\n--------------------------------------------------------------------------------------------------";
    output &lt;&lt; "\nTRAPEZOID trapezoid_0 = TRAPEZOID(\"pink\", POINT(-5,-10), POINT(0,5), POINT(15,5), POINT(30,-10));";
    output &lt;&lt; "\ntrapezoid_0.print(output);";
    output &lt;&lt; "\nTRAPEZOID trapezoid_1 = TRAPEZOID(\"brown\", POINT(0,0), POINT(4,-5), POINT(15,-5), POINT(45,0));";
    output &lt;&lt; "\ntrapezoid_1.print(output);";
    output &lt;&lt; "\nTRAPEZOID trapezoid_2 = TRAPEZOID(trapezoid_0);";
    output &lt;&lt; "\ntrapezoid_2.print(output);";
    output &lt;&lt; "\n--------------------------------------------------------------------------------------------------";
    TRAPEZOID trapezoid_0 = TRAPEZOID("pink", POINT(-5,-10), POINT(0,5), POINT(15,5), POINT(30,-10));
    trapezoid_0.print(output);
    TRAPEZOID trapezoid_1 = TRAPEZOID("brown", POINT(0,0), POINT(4,-5), POINT(15,-5), POINT(45,0));
    trapezoid_1.print(output);
    TRAPEZOID trapezoid_2 = TRAPEZOID(trapezoid_0);
    trapezoid_2.print(output);
}

/**
 * Unit Test # 10: Test the default RECTANGLE constructor and the RECTANGLE print method.
 */
void unit_test_10(std::ostream &amp; output)
{
    output &lt;&lt; "\n--------------------------------------------------------------------------------------------------";
    output &lt;&lt; "\nUnit Test # 10: Test the default RECTANGLE constructor and the RECTANGLE print method.";
    output &lt;&lt; "\n--------------------------------------------------------------------------------------------------";
    output &lt;&lt; "\nRECTANGLE rectangle;";
    output &lt;&lt; "\nrectangle.print(); // Test the default argument (which is std::cout).";
    output &lt;&lt; "\nrectangle.print(output);";
    output &lt;&lt; "\noutput &lt;&lt; rectangle; // overloaded ostream operator as defined in rectangle.cpp";
    output &lt;&lt; "\n--------------------------------------------------------------------------------------------------";
    RECTANGLE rectangle;
    rectangle.print(); // Test the default argument (which is std::cout).
    rectangle.print(output);
    output &lt;&lt; rectangle; // overloaded ostream operator as defined in rectangle.cpp
}

/**
 * Unit Test # 11: Create a pointer-to-POLYGON type variable to store the memory address of a dynamically allocated RECTANGLE instance. 
 * Use that pointer-to-POLYGON type variable to call the POLYGON print method and the POLYGON getter methods.
 */
void unit_test_11(std::ostream &amp; output) 
{
    output &lt;&lt; "\n\n--------------------------------------------------------------------------------------------------";
    output &lt;&lt; "\nUnit Test # 11: Create a pointer-to-POLYGON type variable to store the memory address of a dynamically allocated RECTANGLE instance. Use that pointer-to-POLYGON type variable to call the POLYGON print method and the POLYGON getter methods.";
    output &lt;&lt; "\n--------------------------------------------------------------------------------------------------";
    output &lt;&lt; "\n// COMMENTED OUT: POLYGON polygon; // This command does not work because POLYGON is an abstract class.";
    output &lt;&lt; "\nPOLYGON * pointer_to_polygon; // The pointer-to-POLYGON type variable can store the memory address of an object whose data type is a non-abstract derived class of POLYGON such as RECTANGLE.";
    output &lt;&lt; "\npointer_to_polygon = new RECTANGLE; // Assign memory to a dynamic RECTANGLE instance (i.e. and dynamic implies that the variable was created during program runtime instead of program compile time).";
    output &lt;&lt; "\npointer_to_polygon -&gt; print(output); // Indirectly call the POLYGON print method.";
    // COMMENTED OUT: POLYGON polygon; // This command does not work because POLYGON is an abstract class.
    POLYGON * pointer_to_polygon; // The pointer-to-POLYGON type variable can store the memory address of an object whose data type is a non-abstract derived class of POLYGON such as RECTANGLE.
    pointer_to_polygon = new RECTANGLE; // Assign memory to a dynamic RECTANGLE instance (i.e. and dynamic implies that the variable was created during program runtime instead of program compile time).
    pointer_to_polygon -&gt; print(output); // Indirectly call the POLYGON print method.
    output &lt;&lt; "\n// COMMENTED OUT (does not work): pointer_to_polygon -&gt; quadrilateral_test(). // Indirectly call the QUADRILATERAL quadrilateral_test() method.";
    output &lt;&lt; "\npointer_to_polygon -&gt; get_area() = " &lt;&lt; pointer_to_polygon -&gt; get_area() &lt;&lt; ". // Indirectly call the POLYGON get_area() method.";
    output &lt;&lt; "\npointer_to_polygon -&gt; get_perimeter() = " &lt;&lt; pointer_to_polygon -&gt; get_perimeter() &lt;&lt; ". // Indirectly call the POLYGON get_permieter() method.";
    output &lt;&lt; "\ndelete pointer_to_polygon; // De-allocate memory which was assigned to the dynamically allocated RECTANGLE instance.";
    output &lt;&lt; "\n--------------------------------------------------------------------------------------------------";
    delete pointer_to_polygon; // De-allocate memory which was assigned to the dynamically allocated TRAPEZOID instance.
}

/**
 * Unit Test # 12: Create a pointer-to-QUADRILATERAL type variable to store the memory address of a dynamically allocated RECTANGLE instance. 
 * Use that pointer-to-QUADRILATERAL type variable to call the QUADRILATERAL print method and the QUADRILATERAL getter methods.
 */
void unit_test_12(std::ostream &amp; output) 
{
    output &lt;&lt; "\n\n--------------------------------------------------------------------------------------------------";
    output &lt;&lt; "\nUnit Test # 12: Create a pointer-to-QUADRILATERAL type variable to store the memory address of a dynamically allocated RECTANGLE instance. Use that pointer-to-QUADRILATERAL type variable to call the POLYGON print method and the QUADRILATERAL getter methods.";
    output &lt;&lt; "\n--------------------------------------------------------------------------------------------------";
    output &lt;&lt; "\nQUADRILATERAL * pointer_to_quadrilateral; // The pointer-to-QUADRILATERAL type variable can store the memory address of an object whose data type is a non-abstract derived class of QUADRILATERAL such as RECTANGLE.";
    output &lt;&lt; "\npointer_to_quadrilateral = new RECTANGLE; // Assign memory to a dynamic RECTANGLE instance (i.e. and dynamic implies that the variable was created during program runtime instead of program compile time).";
    output &lt;&lt; "\npointer_to_quadrilateral -&gt; print(output); // Indirectly call the QUADRILATERAL print method.";
    QUADRILATERAL * pointer_to_quadrilateral; // The pointer-to-QUADRILATERAL type variable can store the memory address of an object whose data type is a non-abstract derived class of QUADRILATERAL such as RECTANGLE.
    pointer_to_quadrilateral = new RECTANGLE; // Assign memory to a dynamic RECTANGLE instance (i.e. and dynamic implies that the variable was created during program runtime instead of program compile time).
    pointer_to_quadrilateral -&gt; print(output); // Indirectly call the POLYGON print method.
    output &lt;&lt; "\n// COMMENTED OUT (does not work): pointer_to_quadrilateral -&gt; rectangle_test(); // Indirectly call the RECTANGLE rectangle_test() method.";
    output &lt;&lt; "\npointer_to_quadrilateral -&gt; get_area() = " &lt;&lt; pointer_to_quadrilateral -&gt; get_area() &lt;&lt; ". // Indirectly call the QUADRILATERAL get_area() method.";
    output &lt;&lt; "\npointer_to_quadrilateral -&gt; get_perimeter() = " &lt;&lt; pointer_to_quadrilateral -&gt; get_perimeter() &lt;&lt; ". // Indirectly call the QUADRILATERAL get_permieter() method.";
    output &lt;&lt; "\ndelete pointer_to_quadrilateral; // De-allocate memory which was assigned to the dynamically allocated RECTANGLE instance.";
    output &lt;&lt; "\n--------------------------------------------------------------------------------------------------";
    delete pointer_to_quadrilateral; // De-allocate memory which was assigned to the dynamically allocated RECTANGLE instance.
}

/**
 * Unit Test # 13: Test the normal RECTANGLE constructor and RECTANGLE copy constructor using valid function inputs and the RECTANGLE print method.
 */
void unit_test_13(std::ostream &amp; output)
{
    output &lt;&lt; "\n--------------------------------------------------------------------------------------------------";
    output &lt;&lt; "\nUnit Test # 13: Test the normal RECTANGLE constructor and RECTANGLE copy constructor using valid function inputs and the RECTANGLE print method.";
    output &lt;&lt; "\n--------------------------------------------------------------------------------------------------";
    output &lt;&lt; "\nRECTANGLE rectangle_0 = RECTANGLE(\"gray\", POINT(9,10), POINT(9,5), POINT(3,5), POINT(3,10));";
    output &lt;&lt; "\nrectangle_0.print(output);";
    output &lt;&lt; "\nRECTANGLE rectangle_1 = RECTANGLE(\"black\", POINT(0,0), POINT(0,1), POINT(1,1), POINT(1,0));";
    output &lt;&lt; "\nrectangle_1.print(output);";
    output &lt;&lt; "\nRECTANGLE rectangle_2 = RECTANGLE(rectangle_0);";
    output &lt;&lt; "\nrectangle_2.print(output);";
    output &lt;&lt; "\n--------------------------------------------------------------------------------------------------";
    RECTANGLE rectangle_0 = RECTANGLE("gray", POINT(9,10), POINT(9,5), POINT(3,5), POINT(3,10));
    rectangle_0.print(output);
    RECTANGLE rectangle_1 = RECTANGLE("black", POINT(0,0), POINT(0,1), POINT(1,1), POINT(1,0));
    rectangle_1.print(output);
    RECTANGLE rectangle_2 = RECTANGLE(rectangle_0);
    rectangle_2.print(output);
}

/**
 * Unit Test # 14: Test the normal RECTANGLE constructor using invalid function inputs and the RECTANGLE print method.
 */
void unit_test_14(std::ostream &amp; output)
{
    output &lt;&lt; "\n--------------------------------------------------------------------------------------------------";
    output &lt;&lt; "\nUnit Test # 14: Test the normal RECTANGLE constructor using invalid function inputs and the RECTANGLE print method.";
    output &lt;&lt; "\n--------------------------------------------------------------------------------------------------";
    output &lt;&lt; "\nRECTANGLE rectangle_0 = RECTANGLE(\"red\", POINT(-1,-1), POINT(0,0), POINT(1,1), POINT(2,2));";
    output &lt;&lt; "\nrectangle_0.print(output);";
    output &lt;&lt; "\nRECTANGLE rectangle_1 = RECTANGLE(\"green\", POINT(-5,-10), POINT(0,5), POINT(15,5), POINT(30,-10));";
    output &lt;&lt; "\nrectangle_1.print(output);";
    output &lt;&lt; "\nRECTANGLE rectangle_2 = RECTANGLE(\"blue\", POINT(-5,-5), POINT(0,0), POINT(-5,-5), POINT(0,0));";
    output &lt;&lt; "\nrectangle_2.print(output);";
    output &lt;&lt; "\n--------------------------------------------------------------------------------------------------";
    RECTANGLE rectangle_0 = RECTANGLE("red", POINT(-1,-1), POINT(0,0), POINT(1,1), POINT(2,2));
    rectangle_0.print(output);
    RECTANGLE rectangle_1 = RECTANGLE("green", POINT(-5,-10), POINT(0,5), POINT(15,5), POINT(30,-10));
    rectangle_1.print(output);
    RECTANGLE rectangle_2 = RECTANGLE("blue", POINT(-5,-5), POINT(0,0), POINT(-5,-5), POINT(0,0));
    rectangle_2.print(output);
}

/**
 * Unit Test # 15: Create a pointer-to-POLYGON type variable to store the memory address of a dynamically allocated SQUARE instance. 
 * Use that pointer-to-POLYGON type variable to call the print method of the POLYGON class and the getter methods of the POLYGON class.
 */
void unit_test_15(std::ostream &amp; output) 
{
    output &lt;&lt; "\n\n--------------------------------------------------------------------------------------------------";
    output &lt;&lt; "\nUnit Test # 15: Create a pointer-to-POLYGON type variable to store the memory address of a dynamically allocated SQUARE instance. Use that pointer-to-POLYGON type variable to call the print method of the POLYGON class and the getter methods of the POLYGON class.";
    output &lt;&lt; "\n--------------------------------------------------------------------------------------------------";
    output &lt;&lt; "\n// COMMENTED OUT: POLYGON polygon; // This command does not work because POLYGON is an abstract class.";
    output &lt;&lt; "\nPOLYGON * pointer_to_polygon; // The pointer-to-POLYGON type variable can store the memory address of an object whose data type is a non-abstract derived class of POLYGON such as SQUARE.";
    output &lt;&lt; "\npointer_to_polygon = new SQUARE; // Assign memory to a dynamic SQUARE instance (i.e. and dynamic implies that the variable was created during program runtime instead of program compile time).";
    output &lt;&lt; "\npointer_to_polygon -&gt; print(output); // Indirectly call the POLYGON print method.";
    // COMMENTED OUT: POLYGON polygon; // This command does not work because POLYGON is an abstract class.
    POLYGON * pointer_to_polygon; // The pointer-to-POLYGON type variable can store the memory address of an object whose data type is a non-abstract derived class of POLYGON such as SQUARE.
    pointer_to_polygon = new SQUARE; // Assign memory to a dynamic SQUARE instance (i.e. and dynamic implies that the variable was created during program runtime instead of program compile time).
    pointer_to_polygon -&gt; print(output); // Indirectly call the POLYGON print method.
    output &lt;&lt; "\npointer_to_polygon -&gt; get_area() = " &lt;&lt; pointer_to_polygon -&gt; get_area() &lt;&lt; ". // Indirectly call the POLYGON get_area() method.";
    output &lt;&lt; "\npointer_to_polygon -&gt; get_perimeter() = " &lt;&lt; pointer_to_polygon -&gt; get_perimeter() &lt;&lt; ". // Indirectly call the POLYGON get_permieter() method.";
    output &lt;&lt; "\ndelete pointer_to_polygon; // De-allocate memory which was assigned to the dynamically allocated SQUARE instance.";
    output &lt;&lt; "\n--------------------------------------------------------------------------------------------------";
    delete pointer_to_polygon; // De-allocate memory which was assigned to the dynamically allocated SQUARE instance.
}

/**
 * Unit Test # 16: Test the default SQUARE constructor and the SQUARE print method.
 */
void unit_test_16(std::ostream &amp; output)
{
    output &lt;&lt; "\n--------------------------------------------------------------------------------------------------";
    output &lt;&lt; "\nUnit Test # 16: Test the default SQUARE constructor and the SQUARE print method.";
    output &lt;&lt; "\n--------------------------------------------------------------------------------------------------";
    output &lt;&lt; "\nSQUARE square;";
    output &lt;&lt; "\nsquare.print(); // Test the default argument (which is std::cout).";
    output &lt;&lt; "\nsquare.print(output);";
    output &lt;&lt; "\noutput &lt;&lt; square; // overloaded ostream operator as defined in square.cpp";
    output &lt;&lt; "\n--------------------------------------------------------------------------------------------------";
    SQUARE square;
    square.print(); // Test the default argument (which is std::cout).
    square.print(output);
    output &lt;&lt; square; // overloaded ostream operator as defined in square.cpp
}

/**
 * Unit Test # 17: Create a pointer-to-QUADRILATERAL type variable to store the memory address of a dynamically allocated SQUARE instance. 
 * Use that pointer-to-QUADRILATERAL type variable to call the QUADRILATERAL print method and the QUADRILATERAL getter methods.
 */
void unit_test_17(std::ostream &amp; output) 
{
    output &lt;&lt; "\n\n--------------------------------------------------------------------------------------------------";
    output &lt;&lt; "\nUnit Test # 17: Create a pointer-to-QUADRILATERAL type variable to store the memory address of a dynamically allocated SQUARE instance. Use that pointer-to-QUADRILATERAL type variable to call the QUADRILATERAL print method and the QUADRILATERAL getter methods.";
    output &lt;&lt; "\n--------------------------------------------------------------------------------------------------";
    output &lt;&lt; "\nQUADRILATERAL * pointer_to_quadrilateral; // The pointer-to-QUADRILATERAL type variable can store the memory address of an object whose data type is a non-abstract derived class of QUADRILATERAL such as SQUARE.";
    output &lt;&lt; "\npointer_to_quadrilateral = new SQUARE; // Assign memory to a dynamic SQUARE instance (i.e. and dynamic implies that the variable was created during program runtime instead of program compile time).";
    output &lt;&lt; "\npointer_to_quadrilateral -&gt; print(output); // Indirectly call the QUADRILATERAL print method.";
    QUADRILATERAL * pointer_to_quadrilateral; // The pointer-to-QUADRILATERAL type variable can store the memory address of an object whose data type is a non-abstract derived class of QUADRILATERAL such as SQUARE.
    pointer_to_quadrilateral = new SQUARE; // Assign memory to a dynamic SQUARE instance (i.e. and dynamic implies that the variable was created during program runtime instead of program compile time).
    pointer_to_quadrilateral -&gt; print(output); // Indirectly call the POLYGON print method.
    output &lt;&lt; "\npointer_to_quadrilateral -&gt; get_area() = " &lt;&lt; pointer_to_quadrilateral -&gt; get_area() &lt;&lt; ". // Indirectly call the QUADRILATERAL get_area() method.";
    output &lt;&lt; "\npointer_to_quadrilateral -&gt; get_perimeter() = " &lt;&lt; pointer_to_quadrilateral -&gt; get_perimeter() &lt;&lt; ". // Indirectly call the QUADRILATERAL get_permieter() method.";
    output &lt;&lt; "\ndelete pointer_to_quadrilateral; // De-allocate memory which was assigned to the dynamically allocated SQUARE instance.";
    output &lt;&lt; "\n--------------------------------------------------------------------------------------------------";
    delete pointer_to_quadrilateral; // De-allocate memory which was assigned to the dynamically allocated SQUARE instance.
}

/**
 * Unit Test # 18: Create a pointer-to-RECTANGLE type variable to store the memory address of a dynamically allocated SQUARE instance. 
 * Use that pointer-to-RECTANGLE type variable to call the RECTANGLE print method and the RECTANGLE getter methods.
 */
void unit_test_18(std::ostream &amp; output) 
{
    output &lt;&lt; "\n\n--------------------------------------------------------------------------------------------------";
    output &lt;&lt; "\nUnit Test # 18: Create a pointer-to-RECTANGLE type variable to store the memory address of a dynamically allocated SQUARE instance. Use that pointer-to-RECTANGLE type variable to call the RECTANGLE print method and the RECTANGLE getter methods.";
    output &lt;&lt; "\n--------------------------------------------------------------------------------------------------";
    output &lt;&lt; "\nRECTANGLE * pointer_to_rectangle; // The pointer-to-RECTANGLE type variable can store the memory address of an object whose data type is a non-abstract derived class of RECTANGLE such as SQUARE.";
    output &lt;&lt; "\npointer_to_rectangle = new SQUARE; // Assign memory to a dynamic SQUARE instance (i.e. and dynamic implies that the variable was created during program runtime instead of program compile time).";
    output &lt;&lt; "\npointer_to_rectangle -&gt; print(output); // Indirectly call the RECTANGLE print method.";
    RECTANGLE * pointer_to_rectangle; // The pointer-to-RECTANGLE type variable can store the memory address of an object whose data type is a non-abstract derived class of RECTANGLE such as SQUARE.
    pointer_to_rectangle = new SQUARE; // Assign memory to a dynamic SQUARE instance (i.e. and dynamic implies that the variable was created during program runtime instead of program compile time).
    pointer_to_rectangle -&gt; print(output); // Indirectly call the RECTANGLE print method.
    output &lt;&lt; "\npointer_to_rectangle -&gt; get_area() = " &lt;&lt; pointer_to_rectangle -&gt; get_area() &lt;&lt; ". // Indirectly call the RECTANGLE get_area() method.";
    output &lt;&lt; "\npointer_to_rectangle -&gt; get_perimeter() = " &lt;&lt; pointer_to_rectangle -&gt; get_perimeter() &lt;&lt; ". // Indirectly call the RECTANGLE get_permieter() method.";
    output &lt;&lt; "\ndelete pointer_to_rectangle; // De-allocate memory which was assigned to the dynamically allocated SQUARE instance.";
    output &lt;&lt; "\n--------------------------------------------------------------------------------------------------";
    delete pointer_to_rectangle; // De-allocate memory which was assigned to the dynamically allocated SQUARE instance.
}

/**
 * Unit Test # 19: Test the normal SQUARE constructor and SQUARE copy constructor using valid function inputs and the SQUARE print method.
 */
void unit_test_19(std::ostream &amp; output)
{
    output &lt;&lt; "\n--------------------------------------------------------------------------------------------------";
    output &lt;&lt; "\nUnit Test # 19: Test the normal SQUARE constructor and SQUARE copy constructor using valid function inputs and the SQUARE print method.";
    output &lt;&lt; "\n--------------------------------------------------------------------------------------------------";
    output &lt;&lt; "\nSQUARE square_0 = SQUARE(\"yellow\", POINT(-3,-3), POINT(-3,0), POINT(0,0), POINT(0,-3));";
    output &lt;&lt; "\nsquare_0.print(output);";
    output &lt;&lt; "\nSQUARE square_1 = SQUARE(\"white\", POINT(-1,-1), POINT(-1,1), POINT(1,1), POINT(1,-1));";
    output &lt;&lt; "\nsquare_1.print(output);";
    output &lt;&lt; "\nSQUARE square_2 = SQUARE(square_0);";
    output &lt;&lt; "\nsquare_2.print(output);";
    output &lt;&lt; "\n--------------------------------------------------------------------------------------------------";
    SQUARE square_0 = SQUARE("yellow", POINT(-3,-3), POINT(-3,0), POINT(0,0), POINT(0,-3));
    square_0.print(output);
    SQUARE square_1 = SQUARE("white", POINT(-1,-1), POINT(-1,1), POINT(1,1), POINT(1,-1));
    square_1.print(output);
    SQUARE square_2 = SQUARE(square_0);
    square_2.print(output);
}

/**
 * Unit Test # 20: Test the normal SQUARE constructor using invalid function inputs and the SQUARE print method.
 */
void unit_test_20(std::ostream &amp; output)
{
    output &lt;&lt; "\n--------------------------------------------------------------------------------------------------";
    output &lt;&lt; "\nUnit Test # 20: Test the normal SQUARE constructor using invalid function inputs and the SQUARE print method.";
    output &lt;&lt; "\n--------------------------------------------------------------------------------------------------";
    output &lt;&lt; "\nSQUARE square_0 = SQUARE(\"red\", POINT(0,0), POINT(0,1), POINT(0,2), POINT(0,3));";
    output &lt;&lt; "\nsquare_0.print(output);";
    output &lt;&lt; "\nSQUARE square_1 = SQUARE(\"green\", POINT(0,0), POINT(0,1), POINT(5,1), POINT(5,0));";
    output &lt;&lt; "\nsquare_1.print(output);";
    output &lt;&lt; "\nSQUARE square_2 = SQUARE(\"blue\", POINT(0,0), POINT(0,1), POINT(1,1), POINT(0,0));";
    output &lt;&lt; "\nsquare_2.print(output);";
    output &lt;&lt; "\n--------------------------------------------------------------------------------------------------";
    SQUARE square_0 = SQUARE("red", POINT(0,0), POINT(0,1), POINT(0,2), POINT(0,3));
    square_0.print(output);
    SQUARE square_1 = SQUARE("green", POINT(0,0), POINT(0,1), POINT(5,1), POINT(5,0));
    square_1.print(output);
    SQUARE square_2 = SQUARE("blue", POINT(0,0), POINT(0,1), POINT(1,1), POINT(0,0));
    square_2.print(output);
}

/**
 * Unit Test # 21: Create a pointer-to-POLYGON type variable to store the memory address of a dynamically allocated TRILATERAL instance. 
 * Use that pointer-to-POLYGON type variable to call the print method of the POLYGON class and the getter methods of the POLYGON class.
 */
void unit_test_21(std::ostream &amp; output) 
{
    output &lt;&lt; "\n\n--------------------------------------------------------------------------------------------------";
    output &lt;&lt; "\nUnit Test # 21: Create a pointer-to-POLYGON type variable to store the memory address of a dynamically allocated TRILATERAL instance. Use that pointer-to-POLYGON type variable to call the print method of the POLYGON class and the getter methods of the POLYGON class.";
    output &lt;&lt; "\n--------------------------------------------------------------------------------------------------";
    output &lt;&lt; "\n// COMMENTED OUT: POLYGON polygon; // This command does not work because POLYGON is an abstract class.";
    output &lt;&lt; "\nPOLYGON * pointer_to_polygon; // The pointer-to-POLYGON type variable can store the memory address of an object whose data type is a non-abstract derived class of POLYGON such as TRILATERAL.";
    output &lt;&lt; "\npointer_to_polygon = new TRILATERAL; // Assign memory to a dynamic TRILATERAL instance (i.e. and dynamic implies that the variable was created during program runtime instead of program compile time).";
    output &lt;&lt; "\npointer_to_polygon -&gt; print(output); // Indirectly call the POLYGON print method.";
    // COMMENTED OUT: POLYGON polygon; // This command does not work because POLYGON is an abstract class.
    POLYGON * pointer_to_polygon; // The pointer-to-POLYGON type variable can store the memory address of an object whose data type is a non-abstract derived class of POLYGON such as SQUARE.
    pointer_to_polygon = new TRILATERAL; // Assign memory to a dynamic TRILATERAL instance (i.e. and dynamic implies that the variable was created during program runtime instead of program compile time).
    pointer_to_polygon -&gt; print(output); // Indirectly call the POLYGON print method.
    output &lt;&lt; "\npointer_to_polygon -&gt; get_area() = " &lt;&lt; pointer_to_polygon -&gt; get_area() &lt;&lt; ". // Indirectly call the POLYGON get_area() method.";
    output &lt;&lt; "\npointer_to_polygon -&gt; get_perimeter() = " &lt;&lt; pointer_to_polygon -&gt; get_perimeter() &lt;&lt; ". // Indirectly call the POLYGON get_permieter() method.";
    output &lt;&lt; "\ndelete pointer_to_polygon; // De-allocate memory which was assigned to the dynamically allocated TRILATERAL instance.";
    output &lt;&lt; "\n--------------------------------------------------------------------------------------------------";
    delete pointer_to_polygon; // De-allocate memory which was assigned to the dynamically allocated TRILATERAL instance.
}

/**
 * Unit Test # 22: Test the default TRILATERAL constructor and the TRILATERAL print method.
 */
void unit_test_22(std::ostream &amp; output)
{
    output &lt;&lt; "\n--------------------------------------------------------------------------------------------------";
    output &lt;&lt; "\nUnit Test # 22: Test the default TRILATERAL constructor and the TRILATERAL print method.";
    output &lt;&lt; "\n--------------------------------------------------------------------------------------------------";
    output &lt;&lt; "\nTRILATERAL trilateral;";
    output &lt;&lt; "\ntrilateral.print(); // Test the default argument (which is std::cout).";
    output &lt;&lt; "\ntrilateral.print(output);";
    output &lt;&lt; "\noutput &lt;&lt; trilateral; // overloaded ostream operator as defined in trilateral.cpp";
    output &lt;&lt; "\n--------------------------------------------------------------------------------------------------";
    TRILATERAL trilateral;
    trilateral.print(); // Test the default argument (which is std::cout).
    trilateral.print(output);
    output &lt;&lt; trilateral; // overloaded ostream operator as defined in trilateral.cpp
}

/**
 * Unit Test # 23: Test the normal TRILATERAL constructor and TRILATERAL copy constructor using valid function inputs and the TRILATERAL print method.
 */
void unit_test_23(std::ostream &amp; output)
{
    output &lt;&lt; "\n--------------------------------------------------------------------------------------------------";
    output &lt;&lt; "\nUnit Test # 23: Test the normal TRILATERAL constructor and TRILATREAL copy constructor using valid function inputs and the TRILATERAL print method.";
    output &lt;&lt; "\n--------------------------------------------------------------------------------------------------";
    output &lt;&lt; "\nTRILATERAL trilateral_0 = TRILATERAL(\"purple\", POINT(0,0), POINT(10,0), POINT(10,-10));";
    output &lt;&lt; "\ntrilateral_0.print(output);";
    output &lt;&lt; "\nTRILATERAL trilateral_1 = TRILATERAL(\"green\", POINT(-1,-1), POINT(4,4), POINT(7,-18);";
    output &lt;&lt; "\ntrilateral_1.print(output);";
    output &lt;&lt; "\nTRILATERAL trilateral_2 = TRILATERAL(trilateral_0);";
    output &lt;&lt; "\ntrilateral_2.print(output);";
    output &lt;&lt; "\n--------------------------------------------------------------------------------------------------";
    TRILATERAL trilateral_0 = TRILATERAL("purple", POINT(0,0), POINT(10,0), POINT(10,-10));
    trilateral_0.print(output);
    TRILATERAL trilateral_1 = TRILATERAL("green", POINT(-1,-1), POINT(4,4), POINT(7,-18));
    trilateral_1.print(output);
    TRILATERAL trilateral_2 = TRILATERAL(trilateral_0);
    trilateral_2.print(output);
}

/**
 * Unit Test # 24: Test the normal SQUARE constructor using invalid function inputs and the SQUARE print method.
 */
void unit_test_24(std::ostream &amp; output)
{
    output &lt;&lt; "\n--------------------------------------------------------------------------------------------------";
    output &lt;&lt; "\nUnit Test # 24: Test the normal TRILATERAL constructor using invalid function inputs and the TRILATERAL print method.";
    output &lt;&lt; "\n--------------------------------------------------------------------------------------------------";
    output &lt;&lt; "\nTRILATERAL trilateral_0 = TRILATERAL(\"red\", POINT(-1,-1), POINT(0,0), POINT(1,1));";
    output &lt;&lt; "\ntrilateral_0.print(output);";
    output &lt;&lt; "\nTRILATERAL trilateral_1 = TRILATERAL(\"green\", POINT(5,0), POINT(5,1), POINT(5,0));";
    output &lt;&lt; "\ntrilateral_1.print(output);";
    output &lt;&lt; "\n--------------------------------------------------------------------------------------------------";
    TRILATERAL trilateral_0 = TRILATERAL("red", POINT(-1,-1), POINT(0,0), POINT(1,1));
    trilateral_0.print(output);
    TRILATERAL trilateral_1 = TRILATERAL("green", POINT(5,0), POINT(5,1), POINT(5,0));
    trilateral_1.print(output);
}

/**
 * Unit Test # 25: Create a pointer-to-POLYGON type variable to store the memory address of a dynamically allocated RIGHT_TRILATERAL instance. 
 * Use that pointer-to-POLYGON type variable to call the print method of the POLYGON class and the getter methods of the POLYGON class.
 */
void unit_test_25(std::ostream &amp; output) 
{
    output &lt;&lt; "\n\n--------------------------------------------------------------------------------------------------";
    output &lt;&lt; "\nUnit Test # 25: Create a pointer-to-POLYGON type variable to store the memory address of a dynamically allocated RIGHT_TRILATERAL instance. Use that pointer-to-POLYGON type variable to call the print method of the POLYGON class and the getter methods of the POLYGON class.";
    output &lt;&lt; "\n--------------------------------------------------------------------------------------------------";
    output &lt;&lt; "\n// COMMENTED OUT: POLYGON polygon; // This command does not work because POLYGON is an abstract class.";
    output &lt;&lt; "\nPOLYGON * pointer_to_polygon; // The pointer-to-POLYGON type variable can store the memory address of an object whose data type is a non-abstract derived class of POLYGON such as RIGHT_TRILATERAL.";
    output &lt;&lt; "\npointer_to_polygon = new RIGHT_TRILATERAL; // Assign memory to a dynamic RIGHT_TRILATERAL instance (i.e. and dynamic implies that the variable was created during program runtime instead of program compile time).";
    output &lt;&lt; "\npointer_to_polygon -&gt; print(output); // Indirectly call the POLYGON print method.";
    // COMMENTED OUT: POLYGON polygon; // This command does not work because POLYGON is an abstract class.
    POLYGON * pointer_to_polygon; // The pointer-to-POLYGON type variable can store the memory address of an object whose data type is a non-abstract derived class of POLYGON such as RIGHT_TRILATERAL.
    pointer_to_polygon = new RIGHT_TRILATERAL; // Assign memory to a dynamic RIGHT_TRILATERAL instance (i.e. and dynamic implies that the variable was created during program runtime instead of program compile time).
    pointer_to_polygon -&gt; print(output); // Indirectly call the POLYGON print method.
    output &lt;&lt; "\npointer_to_polygon -&gt; get_area() = " &lt;&lt; pointer_to_polygon -&gt; get_area() &lt;&lt; ". // Indirectly call the POLYGON get_area() method.";
    output &lt;&lt; "\npointer_to_polygon -&gt; get_perimeter() = " &lt;&lt; pointer_to_polygon -&gt; get_perimeter() &lt;&lt; ". // Indirectly call the POLYGON get_permieter() method.";
    output &lt;&lt; "\ndelete pointer_to_polygon; // De-allocate memory which was assigned to the dynamically allocated RIGHT_TRILATERAL instance.";
    output &lt;&lt; "\n--------------------------------------------------------------------------------------------------";
    delete pointer_to_polygon; // De-allocate memory which was assigned to the dynamically allocated RIGHT_TRILATERAL instance.
}

/**
 * Unit Test # 26: Create a pointer-to-TRILATERAL type variable to store the memory address of a dynamically allocated RIGHT_TRILATERAL instance. 
 * Use that pointer-to-TRILATERAL type variable to call the print method of the TRILATERAL class and the getter methods of the TRILATERAL class.
 */
void unit_test_26(std::ostream &amp; output) 
{
    output &lt;&lt; "\n\n--------------------------------------------------------------------------------------------------";
    output &lt;&lt; "\nUnit Test # 25: Create a pointer-to-TRILATERAL type variable to store the memory address of a dynamically allocated RIGHT_TRILATERAL instance. Use that pointer-to-TRILATERAL type variable to call the print method of the TRILATERAL class and the getter methods of the TRILATERAL class.";
    output &lt;&lt; "\n--------------------------------------------------------------------------------------------------";
    output &lt;&lt; "\nTRILATERAL * pointer_to_trilateral; // The pointer-to-TRILATERAL type variable can store the memory address of an object whose data type is a non-abstract derived class of TRILATERAL such as RIGHT_TRILATERAL.";
    output &lt;&lt; "\npointer_to_trilateral = new RIGHT_TRILATERAL; // Assign memory to a dynamic RIGHT_TRILATERAL instance (i.e. and dynamic implies that the variable was created during program runtime instead of program compile time).";
    output &lt;&lt; "\npointer_to_trilateral -&gt; print(output); // Indirectly call the TRILATERAL print method.";

    TRILATERAL * pointer_to_trilateral; // The pointer-to-TRILATERAL type variable can store the memory address of an object whose data type is a non-abstract derived class of TRILATERAL such as RIGHT_TRILATERAL.
    pointer_to_trilateral = new RIGHT_TRILATERAL; // Assign memory to a dynamic RIGHT_TRILATERAL instance (i.e. and dynamic implies that the variable was created during program runtime instead of program compile time).
    pointer_to_trilateral -&gt; print(output); // Indirectly call the TRILATERAL print method.
    output &lt;&lt; "\npointer_to_trilateral -&gt; get_area() = " &lt;&lt; pointer_to_trilateral -&gt; get_area() &lt;&lt; ". // Indirectly call the TRILATERAL get_area() method.";
    output &lt;&lt; "\npointer_to_trilateral -&gt; get_perimeter() = " &lt;&lt; pointer_to_trilateral -&gt; get_perimeter() &lt;&lt; ". // Indirectly call the TRILATERAL get_permieter() method.";
    output &lt;&lt; "\ndelete pointer_to_trilateral; // De-allocate memory which was assigned to the dynamically allocated RIGHT_TRILATERAL instance.";
    output &lt;&lt; "\n--------------------------------------------------------------------------------------------------";
    delete pointer_to_trilateral; // De-allocate memory which was assigned to the dynamically allocated RIGHT_TRILATERAL instance.
}

/**
 * Unit Test # 27: Test the default TRILATERAL constructor and the TRILATERAL print method.
 */
void unit_test_27(std::ostream &amp; output)
{
    output &lt;&lt; "\n--------------------------------------------------------------------------------------------------";
    output &lt;&lt; "\nUnit Test # 27: Test the default RIGHT_TRILATERAL constructor and the RIGHT_TRILATERAL print method.";
    output &lt;&lt; "\n--------------------------------------------------------------------------------------------------";
    output &lt;&lt; "\nRIGHT_TRILATERAL right_trilateral;";
    output &lt;&lt; "\nright_trilateral.print(); // Test the default argument (which is std::cout).";
    output &lt;&lt; "\nright_trilateral.print(output);";
    output &lt;&lt; "\noutput &lt;&lt; right_trilateral; // overloaded ostream operator as defined in right_trilateral.cpp";
    output &lt;&lt; "\n--------------------------------------------------------------------------------------------------";
    RIGHT_TRILATERAL right_trilateral;
    right_trilateral.print(); // Test the default argument (which is std::cout).
    right_trilateral.print(output);
    output &lt;&lt; right_trilateral; // overloaded ostream operator as defined in right_trilateral.cpp
}

/**
 * Unit Test # 28: Test the normal RIGHT_TRILATERAL constructor and RIGHT_TRILATERAL copy constructor using valid function inputs and the RIGHT_TRILATERAL print method.
 */
void unit_test_28(std::ostream &amp; output)
{
    output &lt;&lt; "\n--------------------------------------------------------------------------------------------------";
    output &lt;&lt; "\nUnit Test # 28: Test the normal RIGHT_TRILATERAL constructor and RIGHT_TRILATERAL copy constructor using valid function inputs and the RIGHT_TRILATERAL print method.";
    output &lt;&lt; "\n--------------------------------------------------------------------------------------------------";
    output &lt;&lt; "\nRIGHT_TRILATERAL right_trilateral_0 = RIGHT_TRILATERAL(\"purple\", POINT(0,0), POINT(0,100), POINT(100,0));";
    output &lt;&lt; "\nright_trilateral_0.print(output);";
    output &lt;&lt; "\nRIGHT_TRILATERAL right_trilateral_1 = RIGHT_TRILATERAL(\"green\", POINT(-3,0), POINT(0,-4), POINT(0,0);";
    output &lt;&lt; "\nright_trilateral_1.print(output);";
    output &lt;&lt; "\nRIGHT_TRILATERAL right_trilateral_2 = RIGHT_TRILATERAL(right_trilateral_0);";
    output &lt;&lt; "\nright_trilateral_2.print(output);";
    output &lt;&lt; "\n--------------------------------------------------------------------------------------------------";
    RIGHT_TRILATERAL right_trilateral_0 = RIGHT_TRILATERAL("purple", POINT(0,0), POINT(0,100), POINT(100,0));
    right_trilateral_0.print(output);
    RIGHT_TRILATERAL right_trilateral_1 = RIGHT_TRILATERAL("green", POINT(-3,0), POINT(0,-4), POINT(0,0));
    right_trilateral_1.print(output);
    RIGHT_TRILATERAL right_trilateral_2 = RIGHT_TRILATERAL(right_trilateral_0);
    right_trilateral_2.print(output);
}

/**
 * Unit Test # 29: Test the normal RIGHT_TRILATERAL constructor using invalid function inputs and the RIGHT_TRILATERAL print method.
 */
void unit_test_29(std::ostream &amp; output)
{
    output &lt;&lt; "\n--------------------------------------------------------------------------------------------------";
    output &lt;&lt; "\nUnit Test # 29: Test the normal RIGHT_TRILATERAL constructor using invalid function inputs and the RIGHT_TRILATERAL print method.";
    output &lt;&lt; "\n--------------------------------------------------------------------------------------------------";
    output &lt;&lt; "\nRIGHT_TRILATERAL right_trilateral_0 = RIGHT_TRILATERAL(\"red\", POINT(-2,-2), POINT(0,0), POINT(4,4));";
    output &lt;&lt; "\nright_trilateral_0.print(output);";
    output &lt;&lt; "\nRIGHT_TRILATERAL right_trilateral_1 = RIGHT_TRILATERAL(\"green\", POINT(0,0), POINT(4,5), POINT(9,-3));";
    output &lt;&lt; "\nright_trilateral_1.print(output);";
    output &lt;&lt; "\nRIGHT_TRILATERAL right_trilateral_2 = RIGHT_TRILATERAL(\"blue\", POINT(0,0), POINT(4,5), POINT(0,0));";
    output &lt;&lt; "\nright_trilateral_2.print(output);";
    output &lt;&lt; "\n--------------------------------------------------------------------------------------------------";
    RIGHT_TRILATERAL right_trilateral_0 = RIGHT_TRILATERAL("red", POINT(-2,-2), POINT(0,0), POINT(4,4));
    right_trilateral_0.print(output);
    RIGHT_TRILATERAL right_trilateral_1 = RIGHT_TRILATERAL("green", POINT(0,0), POINT(4,5), POINT(9,-3));
    right_trilateral_1.print(output);
    RIGHT_TRILATERAL right_trilateral_2 = RIGHT_TRILATERAL("blue", POINT(0,0), POINT(4,5), POINT(0,0));
    right_trilateral_2.print(output);
}

/* program entry point */
int main()
{
    // Declare a file output stream object.
    std::ofstream file;

    // Set the number of digits of floating-point numbers which are printed to the command line terminal to 100 digits.
    std::cout.precision(100);

    // Set the number of digits of floating-point numbers which are printed to the file output stream to 100 digits.
    file.precision(100);

    /**
     * If polygon_class_inheritance_tester_output.txt does not already exist in the same directory as polygon_class_inheritance_tester.cpp, 
     * create a new file named polygon_class_inheritance_tester_output.txt.
     * 
     * Open the plain-text file named polygon_class_inheritance_tester_output.txt 
     * and set that file to be overwritten with program data.
     */
    file.open("polygon_class_inheritance_tester_output.txt");

    // Print an opening message to the command line terminal.
    std::cout &lt;&lt; "\n\n--------------------------------";
    std::cout &lt;&lt; "\nStart Of Program";
    std::cout &lt;&lt; "\n--------------------------------";

    // Print an opening message to the file output stream.
    file &lt;&lt; "--------------------------------";
    file &lt;&lt; "\nStart Of Program";
    file &lt;&lt; "\n--------------------------------";

    // Implement a series of unit tests which demonstrate the functionality of POLYGON class variables.
    unit_test_0(std::cout);
    unit_test_0(file);
    unit_test_1(std::cout);
    unit_test_1(file);
    unit_test_2(std::cout);
    unit_test_2(file);
    unit_test_3(std::cout);
    unit_test_3(file);
    unit_test_4(std::cout);
    unit_test_4(file);
    unit_test_5(std::cout);
    unit_test_5(file);
    unit_test_6(std::cout);
    unit_test_6(file);
    unit_test_7(std::cout);
    unit_test_7(file);
    unit_test_8(std::cout);
    unit_test_8(file);
    unit_test_9(std::cout);
    unit_test_9(file);
    unit_test_10(std::cout);
    unit_test_10(file);
    unit_test_11(std::cout);
    unit_test_11(file);
    unit_test_12(std::cout);
    unit_test_12(file);
    unit_test_13(std::cout);
    unit_test_13(file);
    unit_test_14(std::cout);
    unit_test_14(file);
    unit_test_15(std::cout);
    unit_test_15(file);
    unit_test_16(std::cout);
    unit_test_16(file);
    unit_test_17(std::cout);
    unit_test_17(file);
    unit_test_18(std::cout);
    unit_test_18(file);
    unit_test_19(std::cout);
    unit_test_19(file);
    unit_test_20(std::cout);
    unit_test_20(file);
    unit_test_21(std::cout);
    unit_test_21(file);
    unit_test_22(std::cout);
    unit_test_22(file);
    unit_test_23(std::cout);
    unit_test_23(file);
    unit_test_24(std::cout);
    unit_test_24(file);
    unit_test_25(std::cout);
    unit_test_25(file);
    unit_test_26(std::cout);
    unit_test_26(file);
    unit_test_27(std::cout);
    unit_test_27(file);
    unit_test_28(std::cout);
    unit_test_28(file);
    unit_test_29(std::cout);
    unit_test_29(file);

    // Print a closing message to the command line terminal.
    std::cout &lt;&lt; "\n\n--------------------------------";
    std::cout &lt;&lt; "\nEnd Of Program";
    std::cout &lt;&lt; "\n--------------------------------\n\n";

    // Print a closing message to the file output stream.
    file &lt;&lt; "\n\n--------------------------------";
    file &lt;&lt; "\nEnd Of Program";
    file &lt;&lt; "\n--------------------------------";

    // Close the file output stream.
    file.close();

    // Exit the program.
    return 0;
}
</pre>
<hr />
<p><strong>SAMPLE_PROGRAM_OUTPUT</strong></p>
<hr />
<p>The text in the preformatted text box below was generated by one use case of the C++ program featured in this <a style="background: #ff9000;color: #000000" href="https://en.wikipedia.org/wiki/Computer_programming" target="_blank" rel="noopener">computer programming</a> tutorial web page.</p>
<p>plain-text_file: <a style="background: #000000;color: #ff9000" href="https://raw.githubusercontent.com/karlinarayberinger/KARLINA_OBJECT_summer_2023_starter_pack/main/polygon_class_inheritance_tester_output.txt" target="_blank" rel="noopener">https://raw.githubusercontent.com/karlinarayberinger/KARLINA_OBJECT_summer_2023_starter_pack/main/polygon_class_inheritance_tester_output.txt</a></p>
<hr />
<pre>--------------------------------
Start Of Program
--------------------------------

--------------------------------------------------------------------------------------------------
Unit Test # 0: Create a pointer-to-POLYGON type variable to store the memory address of a dynamically allocated QUADRILATERAL instance. Use that pointer-to-POLYGON type variable to call the print method of the POLYGON class and the getter methods of the POLYGON class.
--------------------------------------------------------------------------------------------------
// COMMENTED OUT: POLYGON polygon; // This command does not work because POLYGON is an abstract class.
POLYGON * pointer_to_polygon; // The pointer-to-POLYGON type variable can store the memory address of an object whose data type is a non-abstract derived class of POLYGON such as QUADRILATERAL.
pointer_to_polygon = new QUADRILATERAL; // Assign memory to a dynamic QUADRILATERAL instance (i.e. and dynamic implies that the variable was created during program runtime instead of program compile time).
pointer_to_polygon -&gt; print(output); // Indirectly call the POLYGON print method.

--------------------------------------------------------------------------------------------------
memory_address = 0x562bfd0084b0.
category = POLYGON.
color = orange.
&amp;category = 0x562bfd0084b8.
&amp;color = 0x562bfd0084d8.
--------------------------------------------------------------------------------------------------
pointer_to_polygon -&gt; get_area() = 20. // Indirectly call the POLYGON get_area() method.
pointer_to_polygon -&gt; get_perimeter() = 18. // Indirectly call the POLYGON get_permieter() method.
delete pointer_to_polygon; // De-allocate memory which was assigned to the dynamically allocated QUADRILATERAL instance.
--------------------------------------------------------------------------------------------------
--------------------------------------------------------------------------------------------------
Unit Test # 1: Test the default QUADRILATERAL constructor and the QUADRILATERAL print method.
--------------------------------------------------------------------------------------------------
QUADRILATERAL quadrilateral;
quadrilateral.print(); // Test the default argument (which is std::cout).
quadrilateral.print(output);
output &lt;&lt; quadrilateral; // overloaded ostream operator as defined in quadrilateral.cpp
--------------------------------------------------------------------------------------------------

--------------------------------------------------------------------------------------------------
this = 0x7ffe7c17e640. // The keyword named this is a pointer which stores the memory address of the first memory cell of a QUADRILATERAL sized chunk of contiguous memory cells which are allocated to the caller TRIANGLE object.
&amp;category = 0x7ffe7c17e688. // The reference operation returns the memory address of the first memory cell of a string sized chunk of contiguous memory cells which are allocated to the string data attribute named category.
&amp;color = 0x7ffe7c17e668. // The reference operation returns the memory address of the first memory cell of a string sized chunk of contiguous memory cells which are allocated to the string data attribute named color..
&amp;A = 0x7ffe7c17e6a8. // The reference operation returns the memory address of the first memory cell of a POINT sized chunk of contiguous memory cells which are allocated to the POINT data attribute named A.
&amp;B = 0x7ffe7c17e6b0. // The reference operation returns the memory address of the first memory cell of a POINT sized chunk of contiguous memory cells which are allocated to the POINT data attribute named B.
&amp;C = 0x7ffe7c17e6b8. // The reference operation returns the memory address of the first memory cell of a POINT sized chunk of contiguous memory cells which are allocated to the POINT data attribute named C.
&amp;D = 0x7ffe7c17e6c0. // The reference operation returns the memory address of the first memory cell of a POINT sized chunk of contiguous memory cells which are allocated to the POINT data attribute named D.
sizeof(int) = 4. // The sizeof() operation returns the nonnegative integer number of bytes of memory which an int type variable occupies. (Each memory cell has a data capacity of 1 byte).
sizeof(int *) = 8. // The sizeof() operation returns the nonnegative integer number of bytes of memory which a pointer-to-int type variable occupies. (Each memory cell has a data capacity of 1 byte).
sizeof(int **) = 8. // The sizeof() operation returns the nonnegative integer number of bytes of memory which an pointer-to-pointer-to-int type variable occupies. (Each memory cell has a data capacity of 1 byte).
sizeof(std::string) = 32. // The sizeof() operation returns the nonnegative integer number of bytes of memory which a string type variable occupies. (Each memory cell has a data capacity of 1 byte).
sizeof(std::string *) = 8. // The sizeof() operation returns the nonnegative integer number of bytes of memory which a pointer-to-string type variable occupies. (Each memory cell has a data capacity of 1 byte).
sizeof(std::string **) = 8. // The sizeof() operation returns the nonnegative integer number of bytes of memory which a pointer-to-pointer-to-string type variable occupies. (Each memory cell has a data capacity of 1 byte).
sizeof(POINT) = 8. // The sizeof() operation returns the nonnegative integer number of bytes of memory which a POINT type object occupies. (Each memory cell has a data capacity of 1 byte).
sizeof(POINT *) = 8. // The sizeof() operation returns the nonnegative integer number of bytes of memory which a pointer-to-POINT type variable occupies. (Each memory cell has a data capacity of 1 byte).
sizeof(POINT **) = 8. // The sizeof() operation returns the nonnegative integer number of bytes of memory which a pointer-to-pointer-to-POINT type variable occupies. (Each memory cell has a data capacity of 1 byte).
sizeof(POLYGON) = 72. // The sizeof() operation returns the nonnegative integer number of bytes of memory which a POLYGON type object occupies. (Each memory cell has a data capacity of 1 byte).
sizeof(POLYGON *) = 8. // The sizeof() operation returns the nonnegative integer number of bytes of memory which a pointer-to-POLYGON type variable occupies. (Each memory cell has a data capacity of 1 byte).
sizeof(POLYGON **) = 8. // The sizeof() operation returns the nonnegative integer number of bytes of memory which a pointer-to-pointer-to-POLYGON type variable occupies. (Each memory cell has a data capacity of 1 byte).
sizeof(QUADRILATERAL) = 136. // The sizeof() operation returns the nonnegative integer number of bytes of memory which a QUADRILATERAL type object occupies. (Each memory cell has a data capacity of 1 byte).
sizeof(QUADRILATERAL *) = 8. // The sizeof() operation returns the nonnegative integer number of bytes of memory which a pointer-to-QUADRILATERAL type variable occupies. (Each memory cell has a data capacity of 1 byte).
sizeof(QUADRILATERAL **) = 8. // The sizeof() operation returns the nonnegative integer number of bytes of memory which a pointer-to-pointer-to-QUADRILATERAL type variable occupies. (Each memory cell has a data capacity of 1 byte).
category = POLYGON/QUADRILATERAL. // This is an immutable string type value which is a data member of the caller QUADRILATERAL object.
color = orange. // This is a string type value which is a data member of the caller QUADRILATERAL object.
A = POINT(0,0). // A represents a point (which is neither B nor C nor D) plotted on a two-dimensional Cartesian grid (such that the X value represents a real whole number position along the horizontal axis of the Cartesian grid while Y represents a real whole number position along the vertical axis of the same Cartesian grid).
B = POINT(0,5). // B represents a point (which is neither A nor C nor D) plotted on a two-dimensional Cartesian grid (such that the X value represents a real whole number position along the horizontal axis of the Cartesian grid while Y represents a real whole number position along the vertical axis of the same Cartesian grid).
C = POINT(4,5). // C represents a point (which is neither A nor B nor D) plotted on a two-dimensional Cartesian grid (such that the X value represents a real whole number position along the horizontal axis of the Cartesian grid while Y represents a real whole number position along the vertical axis of the same Cartesian grid).
D = POINT(4,0). // D represents a point (which is neither A nor B nor C) plotted on a two-dimensional Cartesian grid (such that the X value represents a real whole number position along the horizontal axis of the Cartesian grid while Y represents a real whole number position along the vertical axis of the same Cartesian grid).
a = B.get_distance_from(C) = 4. // The method returns the approximate nonnegative real number of Cartesian grid unit lengths which span the length of the shortest path between points B and C.
b = C.get_distance_from(D) = 5. // The method returns the approximate nonnegative real number of Cartesian grid unit lengths which span the length of the shortest path between points C and D.
c = D.get_distance_from(A) = 4. // The method returns the approximate nonnegative real number of Cartesian grid unit lengths which span the length of the shortest path between points D and A.
d = A.get_distance_from(B) = 5. // The method returns the approximate nonnegative real number of Cartesian grid unit lengths which span the length of the shortest path between points A and B.
A.get_slope_of_line_to(B) = inf. // The method returns the approximate nonnegative real number which represents the slope of the line which intersects points A and B.
B.get_slope_of_line_to(C) = 0. // The method returns the approximate nonnegative real number which represents the slope of the line which intersects points B and C.
C.get_slope_of_line_to(D) = -inf. // The method returns the approximate nonnegative real number which represents the slope of the line which intersects points C and D.
D.get_slope_of_line_to(A) = 0. // The method returns the approximate nonnegative real number which represents the slope of the line which intersects points B and C.
interior_angle_DAB = interior_angle_of_A = 90.00007601981207017161068506538867950439453125. // The value represents the approximate nonnegative real number angle measurement of the acute or else right angle formed by the intersection of the line segment whose endpoints are D and A with the line segment whose endpoints are A and B such that those two line segments intersect at A (and the angle measurement is in degrees and not in radians).
interior_angle_ABC = interior_angle_of_B = 90.0000760198120559607559698633849620819091796875. // The method returns the approximate nonnegative real number angle measurement of the acute or else right angle formed by the intersection of the line segment whose endpoints are A and B with the line segment whose endpoints are B and C such that those two line segments intersect at B (and the angle measurement is in degrees and not in radians).
interior_angle_BCD = interior_angle_of_C = 90.00007601981207017161068506538867950439453125. // The method returns the approximate nonnegative real number angle measurement of the acute or else right angle formed by the intersection of the line segment whose endpoints are B and C with the line segment whose endpoints are C and D such that those two line segments intersect at C (and the angle measurement is in degrees and not in radians).
interior_angle_CDA = interior_angle_of_D = 90.0000760198120559607559698633849620819091796875. // The method returns the approximate nonnegative real number angle measurement of the acute or else right angle formed by the intersection of the line segment whose endpoints are C and D with the line segment whose endpoints are D and A such that those two line segments intersect at D (and the angle measurement is in degrees and not in radians).
interior_angle_of_A + interior_angle_of_B + interior_angle_of_C + interior_angle_of_D = 360.000304079248280686442740261554718017578125. // sum of all four approximate interior angle measurements of the quadrilateral represented by the caller QUADRILATERAL object (in degrees and not in radians)
get_perimeter() = a + b + c + d = 18. // The method returns the sum of the four approximated side lengths of the quadrilateral which the caller QUADRILATERAL object represents.
get_area() = 20. // The method returns the approximate nonnegative real number of Cartesian grid unit squares which are enclosed inside of the two-dimensional region formed by the four line segments which connect points A to B, B to C, C to D, and D to A.
--------------------------------------------------------------------------------------------------

--------------------------------------------------------------------------------------------------
this = 0x7ffe7c17e640. // The keyword named this is a pointer which stores the memory address of the first memory cell of a QUADRILATERAL sized chunk of contiguous memory cells which are allocated to the caller TRIANGLE object.
&amp;category = 0x7ffe7c17e688. // The reference operation returns the memory address of the first memory cell of a string sized chunk of contiguous memory cells which are allocated to the string data attribute named category.
&amp;color = 0x7ffe7c17e668. // The reference operation returns the memory address of the first memory cell of a string sized chunk of contiguous memory cells which are allocated to the string data attribute named color..
&amp;A = 0x7ffe7c17e6a8. // The reference operation returns the memory address of the first memory cell of a POINT sized chunk of contiguous memory cells which are allocated to the POINT data attribute named A.
&amp;B = 0x7ffe7c17e6b0. // The reference operation returns the memory address of the first memory cell of a POINT sized chunk of contiguous memory cells which are allocated to the POINT data attribute named B.
&amp;C = 0x7ffe7c17e6b8. // The reference operation returns the memory address of the first memory cell of a POINT sized chunk of contiguous memory cells which are allocated to the POINT data attribute named C.
&amp;D = 0x7ffe7c17e6c0. // The reference operation returns the memory address of the first memory cell of a POINT sized chunk of contiguous memory cells which are allocated to the POINT data attribute named D.
sizeof(int) = 4. // The sizeof() operation returns the nonnegative integer number of bytes of memory which an int type variable occupies. (Each memory cell has a data capacity of 1 byte).
sizeof(int *) = 8. // The sizeof() operation returns the nonnegative integer number of bytes of memory which a pointer-to-int type variable occupies. (Each memory cell has a data capacity of 1 byte).
sizeof(int **) = 8. // The sizeof() operation returns the nonnegative integer number of bytes of memory which an pointer-to-pointer-to-int type variable occupies. (Each memory cell has a data capacity of 1 byte).
sizeof(std::string) = 32. // The sizeof() operation returns the nonnegative integer number of bytes of memory which a string type variable occupies. (Each memory cell has a data capacity of 1 byte).
sizeof(std::string *) = 8. // The sizeof() operation returns the nonnegative integer number of bytes of memory which a pointer-to-string type variable occupies. (Each memory cell has a data capacity of 1 byte).
sizeof(std::string **) = 8. // The sizeof() operation returns the nonnegative integer number of bytes of memory which a pointer-to-pointer-to-string type variable occupies. (Each memory cell has a data capacity of 1 byte).
sizeof(POINT) = 8. // The sizeof() operation returns the nonnegative integer number of bytes of memory which a POINT type object occupies. (Each memory cell has a data capacity of 1 byte).
sizeof(POINT *) = 8. // The sizeof() operation returns the nonnegative integer number of bytes of memory which a pointer-to-POINT type variable occupies. (Each memory cell has a data capacity of 1 byte).
sizeof(POINT **) = 8. // The sizeof() operation returns the nonnegative integer number of bytes of memory which a pointer-to-pointer-to-POINT type variable occupies. (Each memory cell has a data capacity of 1 byte).
sizeof(POLYGON) = 72. // The sizeof() operation returns the nonnegative integer number of bytes of memory which a POLYGON type object occupies. (Each memory cell has a data capacity of 1 byte).
sizeof(POLYGON *) = 8. // The sizeof() operation returns the nonnegative integer number of bytes of memory which a pointer-to-POLYGON type variable occupies. (Each memory cell has a data capacity of 1 byte).
sizeof(POLYGON **) = 8. // The sizeof() operation returns the nonnegative integer number of bytes of memory which a pointer-to-pointer-to-POLYGON type variable occupies. (Each memory cell has a data capacity of 1 byte).
sizeof(QUADRILATERAL) = 136. // The sizeof() operation returns the nonnegative integer number of bytes of memory which a QUADRILATERAL type object occupies. (Each memory cell has a data capacity of 1 byte).
sizeof(QUADRILATERAL *) = 8. // The sizeof() operation returns the nonnegative integer number of bytes of memory which a pointer-to-QUADRILATERAL type variable occupies. (Each memory cell has a data capacity of 1 byte).
sizeof(QUADRILATERAL **) = 8. // The sizeof() operation returns the nonnegative integer number of bytes of memory which a pointer-to-pointer-to-QUADRILATERAL type variable occupies. (Each memory cell has a data capacity of 1 byte).
category = POLYGON/QUADRILATERAL. // This is an immutable string type value which is a data member of the caller QUADRILATERAL object.
color = orange. // This is a string type value which is a data member of the caller QUADRILATERAL object.
A = POINT(0,0). // A represents a point (which is neither B nor C nor D) plotted on a two-dimensional Cartesian grid (such that the X value represents a real whole number position along the horizontal axis of the Cartesian grid while Y represents a real whole number position along the vertical axis of the same Cartesian grid).
B = POINT(0,5). // B represents a point (which is neither A nor C nor D) plotted on a two-dimensional Cartesian grid (such that the X value represents a real whole number position along the horizontal axis of the Cartesian grid while Y represents a real whole number position along the vertical axis of the same Cartesian grid).
C = POINT(4,5). // C represents a point (which is neither A nor B nor D) plotted on a two-dimensional Cartesian grid (such that the X value represents a real whole number position along the horizontal axis of the Cartesian grid while Y represents a real whole number position along the vertical axis of the same Cartesian grid).
D = POINT(4,0). // D represents a point (which is neither A nor B nor C) plotted on a two-dimensional Cartesian grid (such that the X value represents a real whole number position along the horizontal axis of the Cartesian grid while Y represents a real whole number position along the vertical axis of the same Cartesian grid).
a = B.get_distance_from(C) = 4. // The method returns the approximate nonnegative real number of Cartesian grid unit lengths which span the length of the shortest path between points B and C.
b = C.get_distance_from(D) = 5. // The method returns the approximate nonnegative real number of Cartesian grid unit lengths which span the length of the shortest path between points C and D.
c = D.get_distance_from(A) = 4. // The method returns the approximate nonnegative real number of Cartesian grid unit lengths which span the length of the shortest path between points D and A.
d = A.get_distance_from(B) = 5. // The method returns the approximate nonnegative real number of Cartesian grid unit lengths which span the length of the shortest path between points A and B.
A.get_slope_of_line_to(B) = inf. // The method returns the approximate nonnegative real number which represents the slope of the line which intersects points A and B.
B.get_slope_of_line_to(C) = 0. // The method returns the approximate nonnegative real number which represents the slope of the line which intersects points B and C.
C.get_slope_of_line_to(D) = -inf. // The method returns the approximate nonnegative real number which represents the slope of the line which intersects points C and D.
D.get_slope_of_line_to(A) = 0. // The method returns the approximate nonnegative real number which represents the slope of the line which intersects points B and C.
interior_angle_DAB = interior_angle_of_A = 90.00007601981207017161068506538867950439453125. // The value represents the approximate nonnegative real number angle measurement of the acute or else right angle formed by the intersection of the line segment whose endpoints are D and A with the line segment whose endpoints are A and B such that those two line segments intersect at A (and the angle measurement is in degrees and not in radians).
interior_angle_ABC = interior_angle_of_B = 90.0000760198120559607559698633849620819091796875. // The method returns the approximate nonnegative real number angle measurement of the acute or else right angle formed by the intersection of the line segment whose endpoints are A and B with the line segment whose endpoints are B and C such that those two line segments intersect at B (and the angle measurement is in degrees and not in radians).
interior_angle_BCD = interior_angle_of_C = 90.00007601981207017161068506538867950439453125. // The method returns the approximate nonnegative real number angle measurement of the acute or else right angle formed by the intersection of the line segment whose endpoints are B and C with the line segment whose endpoints are C and D such that those two line segments intersect at C (and the angle measurement is in degrees and not in radians).
interior_angle_CDA = interior_angle_of_D = 90.0000760198120559607559698633849620819091796875. // The method returns the approximate nonnegative real number angle measurement of the acute or else right angle formed by the intersection of the line segment whose endpoints are C and D with the line segment whose endpoints are D and A such that those two line segments intersect at D (and the angle measurement is in degrees and not in radians).
interior_angle_of_A + interior_angle_of_B + interior_angle_of_C + interior_angle_of_D = 360.000304079248280686442740261554718017578125. // sum of all four approximate interior angle measurements of the quadrilateral represented by the caller QUADRILATERAL object (in degrees and not in radians)
get_perimeter() = a + b + c + d = 18. // The method returns the sum of the four approximated side lengths of the quadrilateral which the caller QUADRILATERAL object represents.
get_area() = 20. // The method returns the approximate nonnegative real number of Cartesian grid unit squares which are enclosed inside of the two-dimensional region formed by the four line segments which connect points A to B, B to C, C to D, and D to A.
--------------------------------------------------------------------------------------------------
--------------------------------------------------------------------------------------------------
Unit Test # 2: Create a pointer-to-POLYGON type variable to store the memory address of a dynamically allocated QUADRILATERAL instance. Use that pointer-to-POLYGON to call the overloaded ostream operator method of the POLYGON class (and not of the QUADRILATERAL class).
--------------------------------------------------------------------------------------------------
// COMMENTED OUT: POLYGON polygon; // This command does not work because POLYGON is an abstract class.
POLYGON * pointer_to_polygon; // The pointer-to-POLYGON type variable can store the memory address of an object whose data type is a non-abstract derived class of POLYGON such as QUADRILATERAL.
pointer_to_polygon = new QUADRILATERAL; // Assign memory to a dynamic QUADRILATERAL instance (i.e. and dynamic implies that the variable was created during program runtime instead of program compile time).
output &lt;&lt; * pointer_to_polygon; // Use the overloaded ostream operator as defined in polygon.cpp to print the data which is stored at the memory address which pointer_to_polygon stores.
delete pointer_to_polygon; // De-allocate memory which was assigned to the dynamically allocated QUADRILATERAL instance.
--------------------------------------------------------------------------------------------------

--------------------------------------------------------------------------------------------------
memory_address = 0x562bfd0084b0.
category = POLYGON.
color = orange.
&amp;category = 0x562bfd0084b8.
&amp;color = 0x562bfd0084d8.
--------------------------------------------------------------------------------------------------
--------------------------------------------------------------------------------------------------
Unit Test # 3: Create a pointer-to-QUADRILATERAL type variable to store the memory address of a dynamically allocated QUADRILATERAL instance. Use that pointer-to-QUADRILATERAL to call the overloaded ostream operator method of the QUADRILATERAL class and the public getter methods of the QUADRILATERAL class.
--------------------------------------------------------------------------------------------------
QUADRILATERAL * pointer_to_quadrilateral; // The pointer-to-QUADRILATERAL type variable can store the memory address of an object whose data type is QUADRILATERAL or else a non-abstract derived class of QUADRILATERAL such as TRAPEZOID.
pointer_to_quadrilateral = new QUADRILATERAL; // Assign memory to a dynamic QUADRILATERAL instance (i.e. and dynamic implies that the variable was created during program runtime instead of program compile time).
output &lt; get_area() = 20. // Indirectly call the get_area() method of the QUADRILATERAL class.
pointer_to_quadrilateral -&gt; get_perimeter() = 18. // Indirectly call the get_perimeter() method of the QUADRILATERAL class.
--------------------------------------------------------------------------------------------------
Unit Test # 4: Test the normal QUADRILATERAL constructor and QUADRILATERAL copy constructor using valid function inputs and the QUADRILATERAL print method.
--------------------------------------------------------------------------------------------------
QUADRILATERAL quadrilateral_0 = QUADRILATERAL("green", POINT(-2,-2), POINT(-2,2), POINT(2,2), POINT(2,-2));
quadrilateral_0.print(output);
QUADRILATERAL quadrilateral_1 = QUADRILATERAL("blue", POINT(0,0), POINT(3,2), POINT(5,1), POINT(-1,-2));
quadrilateral_1.print(output);
QUADRILATERAL quadrilateral_2 = QUADRILATERAL(quadrilateral_0);
quadrilateral_2.print(output);
--------------------------------------------------------------------------------------------------

--------------------------------------------------------------------------------------------------
this = 0x7ffe7c17e520. // The keyword named this is a pointer which stores the memory address of the first memory cell of a QUADRILATERAL sized chunk of contiguous memory cells which are allocated to the caller TRIANGLE object.
&amp;category = 0x7ffe7c17e568. // The reference operation returns the memory address of the first memory cell of a string sized chunk of contiguous memory cells which are allocated to the string data attribute named category.
&amp;color = 0x7ffe7c17e548. // The reference operation returns the memory address of the first memory cell of a string sized chunk of contiguous memory cells which are allocated to the string data attribute named color..
&amp;A = 0x7ffe7c17e588. // The reference operation returns the memory address of the first memory cell of a POINT sized chunk of contiguous memory cells which are allocated to the POINT data attribute named A.
&amp;B = 0x7ffe7c17e590. // The reference operation returns the memory address of the first memory cell of a POINT sized chunk of contiguous memory cells which are allocated to the POINT data attribute named B.
&amp;C = 0x7ffe7c17e598. // The reference operation returns the memory address of the first memory cell of a POINT sized chunk of contiguous memory cells which are allocated to the POINT data attribute named C.
&amp;D = 0x7ffe7c17e5a0. // The reference operation returns the memory address of the first memory cell of a POINT sized chunk of contiguous memory cells which are allocated to the POINT data attribute named D.
sizeof(int) = 4. // The sizeof() operation returns the nonnegative integer number of bytes of memory which an int type variable occupies. (Each memory cell has a data capacity of 1 byte).
sizeof(int *) = 8. // The sizeof() operation returns the nonnegative integer number of bytes of memory which a pointer-to-int type variable occupies. (Each memory cell has a data capacity of 1 byte).
sizeof(int **) = 8. // The sizeof() operation returns the nonnegative integer number of bytes of memory which an pointer-to-pointer-to-int type variable occupies. (Each memory cell has a data capacity of 1 byte).
sizeof(std::string) = 32. // The sizeof() operation returns the nonnegative integer number of bytes of memory which a string type variable occupies. (Each memory cell has a data capacity of 1 byte).
sizeof(std::string *) = 8. // The sizeof() operation returns the nonnegative integer number of bytes of memory which a pointer-to-string type variable occupies. (Each memory cell has a data capacity of 1 byte).
sizeof(std::string **) = 8. // The sizeof() operation returns the nonnegative integer number of bytes of memory which a pointer-to-pointer-to-string type variable occupies. (Each memory cell has a data capacity of 1 byte).
sizeof(POINT) = 8. // The sizeof() operation returns the nonnegative integer number of bytes of memory which a POINT type object occupies. (Each memory cell has a data capacity of 1 byte).
sizeof(POINT *) = 8. // The sizeof() operation returns the nonnegative integer number of bytes of memory which a pointer-to-POINT type variable occupies. (Each memory cell has a data capacity of 1 byte).
sizeof(POINT **) = 8. // The sizeof() operation returns the nonnegative integer number of bytes of memory which a pointer-to-pointer-to-POINT type variable occupies. (Each memory cell has a data capacity of 1 byte).
sizeof(POLYGON) = 72. // The sizeof() operation returns the nonnegative integer number of bytes of memory which a POLYGON type object occupies. (Each memory cell has a data capacity of 1 byte).
sizeof(POLYGON *) = 8. // The sizeof() operation returns the nonnegative integer number of bytes of memory which a pointer-to-POLYGON type variable occupies. (Each memory cell has a data capacity of 1 byte).
sizeof(POLYGON **) = 8. // The sizeof() operation returns the nonnegative integer number of bytes of memory which a pointer-to-pointer-to-POLYGON type variable occupies. (Each memory cell has a data capacity of 1 byte).
sizeof(QUADRILATERAL) = 136. // The sizeof() operation returns the nonnegative integer number of bytes of memory which a QUADRILATERAL type object occupies. (Each memory cell has a data capacity of 1 byte).
sizeof(QUADRILATERAL *) = 8. // The sizeof() operation returns the nonnegative integer number of bytes of memory which a pointer-to-QUADRILATERAL type variable occupies. (Each memory cell has a data capacity of 1 byte).
sizeof(QUADRILATERAL **) = 8. // The sizeof() operation returns the nonnegative integer number of bytes of memory which a pointer-to-pointer-to-QUADRILATERAL type variable occupies. (Each memory cell has a data capacity of 1 byte).
category = POLYGON/QUADRILATERAL. // This is an immutable string type value which is a data member of the caller QUADRILATERAL object.
color = green. // This is a string type value which is a data member of the caller QUADRILATERAL object.
A = POINT(-2,-2). // A represents a point (which is neither B nor C nor D) plotted on a two-dimensional Cartesian grid (such that the X value represents a real whole number position along the horizontal axis of the Cartesian grid while Y represents a real whole number position along the vertical axis of the same Cartesian grid).
B = POINT(-2,2). // B represents a point (which is neither A nor C nor D) plotted on a two-dimensional Cartesian grid (such that the X value represents a real whole number position along the horizontal axis of the Cartesian grid while Y represents a real whole number position along the vertical axis of the same Cartesian grid).
C = POINT(2,2). // C represents a point (which is neither A nor B nor D) plotted on a two-dimensional Cartesian grid (such that the X value represents a real whole number position along the horizontal axis of the Cartesian grid while Y represents a real whole number position along the vertical axis of the same Cartesian grid).
D = POINT(2,-2). // D represents a point (which is neither A nor B nor C) plotted on a two-dimensional Cartesian grid (such that the X value represents a real whole number position along the horizontal axis of the Cartesian grid while Y represents a real whole number position along the vertical axis of the same Cartesian grid).
a = B.get_distance_from(C) = 4. // The method returns the approximate nonnegative real number of Cartesian grid unit lengths which span the length of the shortest path between points B and C.
b = C.get_distance_from(D) = 4. // The method returns the approximate nonnegative real number of Cartesian grid unit lengths which span the length of the shortest path between points C and D.
c = D.get_distance_from(A) = 4. // The method returns the approximate nonnegative real number of Cartesian grid unit lengths which span the length of the shortest path between points D and A.
d = A.get_distance_from(B) = 4. // The method returns the approximate nonnegative real number of Cartesian grid unit lengths which span the length of the shortest path between points A and B.
A.get_slope_of_line_to(B) = inf. // The method returns the approximate nonnegative real number which represents the slope of the line which intersects points A and B.
B.get_slope_of_line_to(C) = 0. // The method returns the approximate nonnegative real number which represents the slope of the line which intersects points B and C.
C.get_slope_of_line_to(D) = -inf. // The method returns the approximate nonnegative real number which represents the slope of the line which intersects points C and D.
D.get_slope_of_line_to(A) = 0. // The method returns the approximate nonnegative real number which represents the slope of the line which intersects points B and C.
interior_angle_DAB = interior_angle_of_A = 90.0000760198120843824654002673923969268798828125. // The value represents the approximate nonnegative real number angle measurement of the acute or else right angle formed by the intersection of the line segment whose endpoints are D and A with the line segment whose endpoints are A and B such that those two line segments intersect at A (and the angle measurement is in degrees and not in radians).
interior_angle_ABC = interior_angle_of_B = 90.000076019812041749901254661381244659423828125. // The method returns the approximate nonnegative real number angle measurement of the acute or else right angle formed by the intersection of the line segment whose endpoints are A and B with the line segment whose endpoints are B and C such that those two line segments intersect at B (and the angle measurement is in degrees and not in radians).
interior_angle_BCD = interior_angle_of_C = 90.0000760198120843824654002673923969268798828125. // The method returns the approximate nonnegative real number angle measurement of the acute or else right angle formed by the intersection of the line segment whose endpoints are B and C with the line segment whose endpoints are C and D such that those two line segments intersect at C (and the angle measurement is in degrees and not in radians).
interior_angle_CDA = interior_angle_of_D = 90.000076019812041749901254661381244659423828125. // The method returns the approximate nonnegative real number angle measurement of the acute or else right angle formed by the intersection of the line segment whose endpoints are C and D with the line segment whose endpoints are D and A such that those two line segments intersect at D (and the angle measurement is in degrees and not in radians).
interior_angle_of_A + interior_angle_of_B + interior_angle_of_C + interior_angle_of_D = 360.000304079248280686442740261554718017578125. // sum of all four approximate interior angle measurements of the quadrilateral represented by the caller QUADRILATERAL object (in degrees and not in radians)
get_perimeter() = a + b + c + d = 16. // The method returns the sum of the four approximated side lengths of the quadrilateral which the caller QUADRILATERAL object represents.
get_area() = 15.99999999999999289457264239899814128875732421875. // The method returns the approximate nonnegative real number of Cartesian grid unit squares which are enclosed inside of the two-dimensional region formed by the four line segments which connect points A to B, B to C, C to D, and D to A.
--------------------------------------------------------------------------------------------------

--------------------------------------------------------------------------------------------------
this = 0x7ffe7c17e5b0. // The keyword named this is a pointer which stores the memory address of the first memory cell of a QUADRILATERAL sized chunk of contiguous memory cells which are allocated to the caller TRIANGLE object.
&amp;category = 0x7ffe7c17e5f8. // The reference operation returns the memory address of the first memory cell of a string sized chunk of contiguous memory cells which are allocated to the string data attribute named category.
&amp;color = 0x7ffe7c17e5d8. // The reference operation returns the memory address of the first memory cell of a string sized chunk of contiguous memory cells which are allocated to the string data attribute named color..
&amp;A = 0x7ffe7c17e618. // The reference operation returns the memory address of the first memory cell of a POINT sized chunk of contiguous memory cells which are allocated to the POINT data attribute named A.
&amp;B = 0x7ffe7c17e620. // The reference operation returns the memory address of the first memory cell of a POINT sized chunk of contiguous memory cells which are allocated to the POINT data attribute named B.
&amp;C = 0x7ffe7c17e628. // The reference operation returns the memory address of the first memory cell of a POINT sized chunk of contiguous memory cells which are allocated to the POINT data attribute named C.
&amp;D = 0x7ffe7c17e630. // The reference operation returns the memory address of the first memory cell of a POINT sized chunk of contiguous memory cells which are allocated to the POINT data attribute named D.
sizeof(int) = 4. // The sizeof() operation returns the nonnegative integer number of bytes of memory which an int type variable occupies. (Each memory cell has a data capacity of 1 byte).
sizeof(int *) = 8. // The sizeof() operation returns the nonnegative integer number of bytes of memory which a pointer-to-int type variable occupies. (Each memory cell has a data capacity of 1 byte).
sizeof(int **) = 8. // The sizeof() operation returns the nonnegative integer number of bytes of memory which an pointer-to-pointer-to-int type variable occupies. (Each memory cell has a data capacity of 1 byte).
sizeof(std::string) = 32. // The sizeof() operation returns the nonnegative integer number of bytes of memory which a string type variable occupies. (Each memory cell has a data capacity of 1 byte).
sizeof(std::string *) = 8. // The sizeof() operation returns the nonnegative integer number of bytes of memory which a pointer-to-string type variable occupies. (Each memory cell has a data capacity of 1 byte).
sizeof(std::string **) = 8. // The sizeof() operation returns the nonnegative integer number of bytes of memory which a pointer-to-pointer-to-string type variable occupies. (Each memory cell has a data capacity of 1 byte).
sizeof(POINT) = 8. // The sizeof() operation returns the nonnegative integer number of bytes of memory which a POINT type object occupies. (Each memory cell has a data capacity of 1 byte).
sizeof(POINT *) = 8. // The sizeof() operation returns the nonnegative integer number of bytes of memory which a pointer-to-POINT type variable occupies. (Each memory cell has a data capacity of 1 byte).
sizeof(POINT **) = 8. // The sizeof() operation returns the nonnegative integer number of bytes of memory which a pointer-to-pointer-to-POINT type variable occupies. (Each memory cell has a data capacity of 1 byte).
sizeof(POLYGON) = 72. // The sizeof() operation returns the nonnegative integer number of bytes of memory which a POLYGON type object occupies. (Each memory cell has a data capacity of 1 byte).
sizeof(POLYGON *) = 8. // The sizeof() operation returns the nonnegative integer number of bytes of memory which a pointer-to-POLYGON type variable occupies. (Each memory cell has a data capacity of 1 byte).
sizeof(POLYGON **) = 8. // The sizeof() operation returns the nonnegative integer number of bytes of memory which a pointer-to-pointer-to-POLYGON type variable occupies. (Each memory cell has a data capacity of 1 byte).
sizeof(QUADRILATERAL) = 136. // The sizeof() operation returns the nonnegative integer number of bytes of memory which a QUADRILATERAL type object occupies. (Each memory cell has a data capacity of 1 byte).
sizeof(QUADRILATERAL *) = 8. // The sizeof() operation returns the nonnegative integer number of bytes of memory which a pointer-to-QUADRILATERAL type variable occupies. (Each memory cell has a data capacity of 1 byte).
sizeof(QUADRILATERAL **) = 8. // The sizeof() operation returns the nonnegative integer number of bytes of memory which a pointer-to-pointer-to-QUADRILATERAL type variable occupies. (Each memory cell has a data capacity of 1 byte).
category = POLYGON/QUADRILATERAL. // This is an immutable string type value which is a data member of the caller QUADRILATERAL object.
color = blue. // This is a string type value which is a data member of the caller QUADRILATERAL object.
A = POINT(0,0). // A represents a point (which is neither B nor C nor D) plotted on a two-dimensional Cartesian grid (such that the X value represents a real whole number position along the horizontal axis of the Cartesian grid while Y represents a real whole number position along the vertical axis of the same Cartesian grid).
B = POINT(3,2). // B represents a point (which is neither A nor C nor D) plotted on a two-dimensional Cartesian grid (such that the X value represents a real whole number position along the horizontal axis of the Cartesian grid while Y represents a real whole number position along the vertical axis of the same Cartesian grid).
C = POINT(5,1). // C represents a point (which is neither A nor B nor D) plotted on a two-dimensional Cartesian grid (such that the X value represents a real whole number position along the horizontal axis of the Cartesian grid while Y represents a real whole number position along the vertical axis of the same Cartesian grid).
D = POINT(-1,-2). // D represents a point (which is neither A nor B nor C) plotted on a two-dimensional Cartesian grid (such that the X value represents a real whole number position along the horizontal axis of the Cartesian grid while Y represents a real whole number position along the vertical axis of the same Cartesian grid).
a = B.get_distance_from(C) = 2.236067977499789805051477742381393909454345703125. // The method returns the approximate nonnegative real number of Cartesian grid unit lengths which span the length of the shortest path between points B and C.
b = C.get_distance_from(D) = 6.708203932499369415154433227144181728363037109375. // The method returns the approximate nonnegative real number of Cartesian grid unit lengths which span the length of the shortest path between points C and D.
c = D.get_distance_from(A) = 2.236067977499789805051477742381393909454345703125. // The method returns the approximate nonnegative real number of Cartesian grid unit lengths which span the length of the shortest path between points D and A.
d = A.get_distance_from(B) = 3.605551275463989124858699142350815236568450927734375. // The method returns the approximate nonnegative real number of Cartesian grid unit lengths which span the length of the shortest path between points A and B.
A.get_slope_of_line_to(B) = 0.66666666666666662965923251249478198587894439697265625. // The method returns the approximate nonnegative real number which represents the slope of the line which intersects points A and B.
B.get_slope_of_line_to(C) = -0.5. // The method returns the approximate nonnegative real number which represents the slope of the line which intersects points B and C.
C.get_slope_of_line_to(D) = 0.5. // The method returns the approximate nonnegative real number which represents the slope of the line which intersects points C and D.
D.get_slope_of_line_to(A) = 2. // The method returns the approximate nonnegative real number which represents the slope of the line which intersects points B and C.
interior_angle_DAB = interior_angle_of_A = 150.25524561823436897611827589571475982666015625. // The value represents the approximate nonnegative real number angle measurement of the acute or else right angle formed by the intersection of the line segment whose endpoints are D and A with the line segment whose endpoints are A and B such that those two line segments intersect at A (and the angle measurement is in degrees and not in radians).
interior_angle_ABC = interior_angle_of_B = 119.7449824412019125929873553104698657989501953125. // The method returns the approximate nonnegative real number angle measurement of the acute or else right angle formed by the intersection of the line segment whose endpoints are A and B with the line segment whose endpoints are B and C such that those two line segments intersect at B (and the angle measurement is in degrees and not in radians).
interior_angle_BCD = interior_angle_of_C = 53.1301472312714935242183855734765529632568359375. // The method returns the approximate nonnegative real number angle measurement of the acute or else right angle formed by the intersection of the line segment whose endpoints are B and C with the line segment whose endpoints are C and D such that those two line segments intersect at C (and the angle measurement is in degrees and not in radians).
interior_angle_CDA = interior_angle_of_D = 36.8699287885405482256828690879046916961669921875. // The method returns the approximate nonnegative real number angle measurement of the acute or else right angle formed by the intersection of the line segment whose endpoints are C and D with the line segment whose endpoints are D and A such that those two line segments intersect at D (and the angle measurement is in degrees and not in radians).
interior_angle_of_A + interior_angle_of_B + interior_angle_of_C + interior_angle_of_D = 360.00030407924833752986160106956958770751953125. // sum of all four approximate interior angle measurements of the quadrilateral represented by the caller QUADRILATERAL object (in degrees and not in radians)
get_perimeter() = a + b + c + d = 14.7858911629629385942052977043204009532928466796875. // The method returns the sum of the four approximated side lengths of the quadrilateral which the caller QUADRILATERAL object represents.
get_area() = 8. // The method returns the approximate nonnegative real number of Cartesian grid unit squares which are enclosed inside of the two-dimensional region formed by the four line segments which connect points A to B, B to C, C to D, and D to A.
--------------------------------------------------------------------------------------------------

--------------------------------------------------------------------------------------------------
this = 0x7ffe7c17e640. // The keyword named this is a pointer which stores the memory address of the first memory cell of a QUADRILATERAL sized chunk of contiguous memory cells which are allocated to the caller TRIANGLE object.
&amp;category = 0x7ffe7c17e688. // The reference operation returns the memory address of the first memory cell of a string sized chunk of contiguous memory cells which are allocated to the string data attribute named category.
&amp;color = 0x7ffe7c17e668. // The reference operation returns the memory address of the first memory cell of a string sized chunk of contiguous memory cells which are allocated to the string data attribute named color..
&amp;A = 0x7ffe7c17e6a8. // The reference operation returns the memory address of the first memory cell of a POINT sized chunk of contiguous memory cells which are allocated to the POINT data attribute named A.
&amp;B = 0x7ffe7c17e6b0. // The reference operation returns the memory address of the first memory cell of a POINT sized chunk of contiguous memory cells which are allocated to the POINT data attribute named B.
&amp;C = 0x7ffe7c17e6b8. // The reference operation returns the memory address of the first memory cell of a POINT sized chunk of contiguous memory cells which are allocated to the POINT data attribute named C.
&amp;D = 0x7ffe7c17e6c0. // The reference operation returns the memory address of the first memory cell of a POINT sized chunk of contiguous memory cells which are allocated to the POINT data attribute named D.
sizeof(int) = 4. // The sizeof() operation returns the nonnegative integer number of bytes of memory which an int type variable occupies. (Each memory cell has a data capacity of 1 byte).
sizeof(int *) = 8. // The sizeof() operation returns the nonnegative integer number of bytes of memory which a pointer-to-int type variable occupies. (Each memory cell has a data capacity of 1 byte).
sizeof(int **) = 8. // The sizeof() operation returns the nonnegative integer number of bytes of memory which an pointer-to-pointer-to-int type variable occupies. (Each memory cell has a data capacity of 1 byte).
sizeof(std::string) = 32. // The sizeof() operation returns the nonnegative integer number of bytes of memory which a string type variable occupies. (Each memory cell has a data capacity of 1 byte).
sizeof(std::string *) = 8. // The sizeof() operation returns the nonnegative integer number of bytes of memory which a pointer-to-string type variable occupies. (Each memory cell has a data capacity of 1 byte).
sizeof(std::string **) = 8. // The sizeof() operation returns the nonnegative integer number of bytes of memory which a pointer-to-pointer-to-string type variable occupies. (Each memory cell has a data capacity of 1 byte).
sizeof(POINT) = 8. // The sizeof() operation returns the nonnegative integer number of bytes of memory which a POINT type object occupies. (Each memory cell has a data capacity of 1 byte).
sizeof(POINT *) = 8. // The sizeof() operation returns the nonnegative integer number of bytes of memory which a pointer-to-POINT type variable occupies. (Each memory cell has a data capacity of 1 byte).
sizeof(POINT **) = 8. // The sizeof() operation returns the nonnegative integer number of bytes of memory which a pointer-to-pointer-to-POINT type variable occupies. (Each memory cell has a data capacity of 1 byte).
sizeof(POLYGON) = 72. // The sizeof() operation returns the nonnegative integer number of bytes of memory which a POLYGON type object occupies. (Each memory cell has a data capacity of 1 byte).
sizeof(POLYGON *) = 8. // The sizeof() operation returns the nonnegative integer number of bytes of memory which a pointer-to-POLYGON type variable occupies. (Each memory cell has a data capacity of 1 byte).
sizeof(POLYGON **) = 8. // The sizeof() operation returns the nonnegative integer number of bytes of memory which a pointer-to-pointer-to-POLYGON type variable occupies. (Each memory cell has a data capacity of 1 byte).
sizeof(QUADRILATERAL) = 136. // The sizeof() operation returns the nonnegative integer number of bytes of memory which a QUADRILATERAL type object occupies. (Each memory cell has a data capacity of 1 byte).
sizeof(QUADRILATERAL *) = 8. // The sizeof() operation returns the nonnegative integer number of bytes of memory which a pointer-to-QUADRILATERAL type variable occupies. (Each memory cell has a data capacity of 1 byte).
sizeof(QUADRILATERAL **) = 8. // The sizeof() operation returns the nonnegative integer number of bytes of memory which a pointer-to-pointer-to-QUADRILATERAL type variable occupies. (Each memory cell has a data capacity of 1 byte).
category = POLYGON/QUADRILATERAL. // This is an immutable string type value which is a data member of the caller QUADRILATERAL object.
color = green. // This is a string type value which is a data member of the caller QUADRILATERAL object.
A = POINT(-2,-2). // A represents a point (which is neither B nor C nor D) plotted on a two-dimensional Cartesian grid (such that the X value represents a real whole number position along the horizontal axis of the Cartesian grid while Y represents a real whole number position along the vertical axis of the same Cartesian grid).
B = POINT(-2,2). // B represents a point (which is neither A nor C nor D) plotted on a two-dimensional Cartesian grid (such that the X value represents a real whole number position along the horizontal axis of the Cartesian grid while Y represents a real whole number position along the vertical axis of the same Cartesian grid).
C = POINT(2,2). // C represents a point (which is neither A nor B nor D) plotted on a two-dimensional Cartesian grid (such that the X value represents a real whole number position along the horizontal axis of the Cartesian grid while Y represents a real whole number position along the vertical axis of the same Cartesian grid).
D = POINT(2,-2). // D represents a point (which is neither A nor B nor C) plotted on a two-dimensional Cartesian grid (such that the X value represents a real whole number position along the horizontal axis of the Cartesian grid while Y represents a real whole number position along the vertical axis of the same Cartesian grid).
a = B.get_distance_from(C) = 4. // The method returns the approximate nonnegative real number of Cartesian grid unit lengths which span the length of the shortest path between points B and C.
b = C.get_distance_from(D) = 4. // The method returns the approximate nonnegative real number of Cartesian grid unit lengths which span the length of the shortest path between points C and D.
c = D.get_distance_from(A) = 4. // The method returns the approximate nonnegative real number of Cartesian grid unit lengths which span the length of the shortest path between points D and A.
d = A.get_distance_from(B) = 4. // The method returns the approximate nonnegative real number of Cartesian grid unit lengths which span the length of the shortest path between points A and B.
A.get_slope_of_line_to(B) = inf. // The method returns the approximate nonnegative real number which represents the slope of the line which intersects points A and B.
B.get_slope_of_line_to(C) = 0. // The method returns the approximate nonnegative real number which represents the slope of the line which intersects points B and C.
C.get_slope_of_line_to(D) = -inf. // The method returns the approximate nonnegative real number which represents the slope of the line which intersects points C and D.
D.get_slope_of_line_to(A) = 0. // The method returns the approximate nonnegative real number which represents the slope of the line which intersects points B and C.
interior_angle_DAB = interior_angle_of_A = 90.0000760198120843824654002673923969268798828125. // The value represents the approximate nonnegative real number angle measurement of the acute or else right angle formed by the intersection of the line segment whose endpoints are D and A with the line segment whose endpoints are A and B such that those two line segments intersect at A (and the angle measurement is in degrees and not in radians).
interior_angle_ABC = interior_angle_of_B = 90.000076019812041749901254661381244659423828125. // The method returns the approximate nonnegative real number angle measurement of the acute or else right angle formed by the intersection of the line segment whose endpoints are A and B with the line segment whose endpoints are B and C such that those two line segments intersect at B (and the angle measurement is in degrees and not in radians).
interior_angle_BCD = interior_angle_of_C = 90.0000760198120843824654002673923969268798828125. // The method returns the approximate nonnegative real number angle measurement of the acute or else right angle formed by the intersection of the line segment whose endpoints are B and C with the line segment whose endpoints are C and D such that those two line segments intersect at C (and the angle measurement is in degrees and not in radians).
interior_angle_CDA = interior_angle_of_D = 90.000076019812041749901254661381244659423828125. // The method returns the approximate nonnegative real number angle measurement of the acute or else right angle formed by the intersection of the line segment whose endpoints are C and D with the line segment whose endpoints are D and A such that those two line segments intersect at D (and the angle measurement is in degrees and not in radians).
interior_angle_of_A + interior_angle_of_B + interior_angle_of_C + interior_angle_of_D = 360.000304079248280686442740261554718017578125. // sum of all four approximate interior angle measurements of the quadrilateral represented by the caller QUADRILATERAL object (in degrees and not in radians)
get_perimeter() = a + b + c + d = 16. // The method returns the sum of the four approximated side lengths of the quadrilateral which the caller QUADRILATERAL object represents.
get_area() = 15.99999999999999289457264239899814128875732421875. // The method returns the approximate nonnegative real number of Cartesian grid unit squares which are enclosed inside of the two-dimensional region formed by the four line segments which connect points A to B, B to C, C to D, and D to A.
--------------------------------------------------------------------------------------------------
--------------------------------------------------------------------------------------------------
Unit Test # 5: Test the normal QUADRILATERAL constructor using invalid function inputs and the QUADRILATERAL print method.
--------------------------------------------------------------------------------------------------
QUADRILATERAL quadrilateral_0 = QUADRILATERAL("red", POINT(-2,-2), POINT(0,0), POINT(1,1), POINT(2,2)); // A line intersects all four points.
quadrilateral_0.print(output);
QUADRILATERAL quadrilateral_1 = QUADRILATERAL("purple", POINT(0,0), POINT(3,2), POINT(0,0), POINT(-1,-2)); // Not all point coordinate pairs are unique.
quadrilateral_1.print(output);
QUADRILATERAL quadrilateral_2 = QUADRILATERAL("yellow", POINT(0,0), POINT(0,2), POINT(4,0), POINT(4,2)); // The points form a bow-tie shaped polygon.
quadrilateral_2.print(output);
--------------------------------------------------------------------------------------------------

--------------------------------------------------------------------------------------------------
this = 0x7ffe7c17e520. // The keyword named this is a pointer which stores the memory address of the first memory cell of a QUADRILATERAL sized chunk of contiguous memory cells which are allocated to the caller TRIANGLE object.
&amp;category = 0x7ffe7c17e568. // The reference operation returns the memory address of the first memory cell of a string sized chunk of contiguous memory cells which are allocated to the string data attribute named category.
&amp;color = 0x7ffe7c17e548. // The reference operation returns the memory address of the first memory cell of a string sized chunk of contiguous memory cells which are allocated to the string data attribute named color..
&amp;A = 0x7ffe7c17e588. // The reference operation returns the memory address of the first memory cell of a POINT sized chunk of contiguous memory cells which are allocated to the POINT data attribute named A.
&amp;B = 0x7ffe7c17e590. // The reference operation returns the memory address of the first memory cell of a POINT sized chunk of contiguous memory cells which are allocated to the POINT data attribute named B.
&amp;C = 0x7ffe7c17e598. // The reference operation returns the memory address of the first memory cell of a POINT sized chunk of contiguous memory cells which are allocated to the POINT data attribute named C.
&amp;D = 0x7ffe7c17e5a0. // The reference operation returns the memory address of the first memory cell of a POINT sized chunk of contiguous memory cells which are allocated to the POINT data attribute named D.
sizeof(int) = 4. // The sizeof() operation returns the nonnegative integer number of bytes of memory which an int type variable occupies. (Each memory cell has a data capacity of 1 byte).
sizeof(int *) = 8. // The sizeof() operation returns the nonnegative integer number of bytes of memory which a pointer-to-int type variable occupies. (Each memory cell has a data capacity of 1 byte).
sizeof(int **) = 8. // The sizeof() operation returns the nonnegative integer number of bytes of memory which an pointer-to-pointer-to-int type variable occupies. (Each memory cell has a data capacity of 1 byte).
sizeof(std::string) = 32. // The sizeof() operation returns the nonnegative integer number of bytes of memory which a string type variable occupies. (Each memory cell has a data capacity of 1 byte).
sizeof(std::string *) = 8. // The sizeof() operation returns the nonnegative integer number of bytes of memory which a pointer-to-string type variable occupies. (Each memory cell has a data capacity of 1 byte).
sizeof(std::string **) = 8. // The sizeof() operation returns the nonnegative integer number of bytes of memory which a pointer-to-pointer-to-string type variable occupies. (Each memory cell has a data capacity of 1 byte).
sizeof(POINT) = 8. // The sizeof() operation returns the nonnegative integer number of bytes of memory which a POINT type object occupies. (Each memory cell has a data capacity of 1 byte).
sizeof(POINT *) = 8. // The sizeof() operation returns the nonnegative integer number of bytes of memory which a pointer-to-POINT type variable occupies. (Each memory cell has a data capacity of 1 byte).
sizeof(POINT **) = 8. // The sizeof() operation returns the nonnegative integer number of bytes of memory which a pointer-to-pointer-to-POINT type variable occupies. (Each memory cell has a data capacity of 1 byte).
sizeof(POLYGON) = 72. // The sizeof() operation returns the nonnegative integer number of bytes of memory which a POLYGON type object occupies. (Each memory cell has a data capacity of 1 byte).
sizeof(POLYGON *) = 8. // The sizeof() operation returns the nonnegative integer number of bytes of memory which a pointer-to-POLYGON type variable occupies. (Each memory cell has a data capacity of 1 byte).
sizeof(POLYGON **) = 8. // The sizeof() operation returns the nonnegative integer number of bytes of memory which a pointer-to-pointer-to-POLYGON type variable occupies. (Each memory cell has a data capacity of 1 byte).
sizeof(QUADRILATERAL) = 136. // The sizeof() operation returns the nonnegative integer number of bytes of memory which a QUADRILATERAL type object occupies. (Each memory cell has a data capacity of 1 byte).
sizeof(QUADRILATERAL *) = 8. // The sizeof() operation returns the nonnegative integer number of bytes of memory which a pointer-to-QUADRILATERAL type variable occupies. (Each memory cell has a data capacity of 1 byte).
sizeof(QUADRILATERAL **) = 8. // The sizeof() operation returns the nonnegative integer number of bytes of memory which a pointer-to-pointer-to-QUADRILATERAL type variable occupies. (Each memory cell has a data capacity of 1 byte).
category = POLYGON/QUADRILATERAL. // This is an immutable string type value which is a data member of the caller QUADRILATERAL object.
color = red. // This is a string type value which is a data member of the caller QUADRILATERAL object.
A = POINT(0,0). // A represents a point (which is neither B nor C nor D) plotted on a two-dimensional Cartesian grid (such that the X value represents a real whole number position along the horizontal axis of the Cartesian grid while Y represents a real whole number position along the vertical axis of the same Cartesian grid).
B = POINT(0,5). // B represents a point (which is neither A nor C nor D) plotted on a two-dimensional Cartesian grid (such that the X value represents a real whole number position along the horizontal axis of the Cartesian grid while Y represents a real whole number position along the vertical axis of the same Cartesian grid).
C = POINT(4,5). // C represents a point (which is neither A nor B nor D) plotted on a two-dimensional Cartesian grid (such that the X value represents a real whole number position along the horizontal axis of the Cartesian grid while Y represents a real whole number position along the vertical axis of the same Cartesian grid).
D = POINT(4,0). // D represents a point (which is neither A nor B nor C) plotted on a two-dimensional Cartesian grid (such that the X value represents a real whole number position along the horizontal axis of the Cartesian grid while Y represents a real whole number position along the vertical axis of the same Cartesian grid).
a = B.get_distance_from(C) = 4. // The method returns the approximate nonnegative real number of Cartesian grid unit lengths which span the length of the shortest path between points B and C.
b = C.get_distance_from(D) = 5. // The method returns the approximate nonnegative real number of Cartesian grid unit lengths which span the length of the shortest path between points C and D.
c = D.get_distance_from(A) = 4. // The method returns the approximate nonnegative real number of Cartesian grid unit lengths which span the length of the shortest path between points D and A.
d = A.get_distance_from(B) = 5. // The method returns the approximate nonnegative real number of Cartesian grid unit lengths which span the length of the shortest path between points A and B.
A.get_slope_of_line_to(B) = inf. // The method returns the approximate nonnegative real number which represents the slope of the line which intersects points A and B.
B.get_slope_of_line_to(C) = 0. // The method returns the approximate nonnegative real number which represents the slope of the line which intersects points B and C.
C.get_slope_of_line_to(D) = -inf. // The method returns the approximate nonnegative real number which represents the slope of the line which intersects points C and D.
D.get_slope_of_line_to(A) = 0. // The method returns the approximate nonnegative real number which represents the slope of the line which intersects points B and C.
interior_angle_DAB = interior_angle_of_A = 90.00007601981207017161068506538867950439453125. // The value represents the approximate nonnegative real number angle measurement of the acute or else right angle formed by the intersection of the line segment whose endpoints are D and A with the line segment whose endpoints are A and B such that those two line segments intersect at A (and the angle measurement is in degrees and not in radians).
interior_angle_ABC = interior_angle_of_B = 90.0000760198120559607559698633849620819091796875. // The method returns the approximate nonnegative real number angle measurement of the acute or else right angle formed by the intersection of the line segment whose endpoints are A and B with the line segment whose endpoints are B and C such that those two line segments intersect at B (and the angle measurement is in degrees and not in radians).
interior_angle_BCD = interior_angle_of_C = 90.00007601981207017161068506538867950439453125. // The method returns the approximate nonnegative real number angle measurement of the acute or else right angle formed by the intersection of the line segment whose endpoints are B and C with the line segment whose endpoints are C and D such that those two line segments intersect at C (and the angle measurement is in degrees and not in radians).
interior_angle_CDA = interior_angle_of_D = 90.0000760198120559607559698633849620819091796875. // The method returns the approximate nonnegative real number angle measurement of the acute or else right angle formed by the intersection of the line segment whose endpoints are C and D with the line segment whose endpoints are D and A such that those two line segments intersect at D (and the angle measurement is in degrees and not in radians).
interior_angle_of_A + interior_angle_of_B + interior_angle_of_C + interior_angle_of_D = 360.000304079248280686442740261554718017578125. // sum of all four approximate interior angle measurements of the quadrilateral represented by the caller QUADRILATERAL object (in degrees and not in radians)
get_perimeter() = a + b + c + d = 18. // The method returns the sum of the four approximated side lengths of the quadrilateral which the caller QUADRILATERAL object represents.
get_area() = 20. // The method returns the approximate nonnegative real number of Cartesian grid unit squares which are enclosed inside of the two-dimensional region formed by the four line segments which connect points A to B, B to C, C to D, and D to A.
--------------------------------------------------------------------------------------------------

--------------------------------------------------------------------------------------------------
this = 0x7ffe7c17e5b0. // The keyword named this is a pointer which stores the memory address of the first memory cell of a QUADRILATERAL sized chunk of contiguous memory cells which are allocated to the caller TRIANGLE object.
&amp;category = 0x7ffe7c17e5f8. // The reference operation returns the memory address of the first memory cell of a string sized chunk of contiguous memory cells which are allocated to the string data attribute named category.
&amp;color = 0x7ffe7c17e5d8. // The reference operation returns the memory address of the first memory cell of a string sized chunk of contiguous memory cells which are allocated to the string data attribute named color..
&amp;A = 0x7ffe7c17e618. // The reference operation returns the memory address of the first memory cell of a POINT sized chunk of contiguous memory cells which are allocated to the POINT data attribute named A.
&amp;B = 0x7ffe7c17e620. // The reference operation returns the memory address of the first memory cell of a POINT sized chunk of contiguous memory cells which are allocated to the POINT data attribute named B.
&amp;C = 0x7ffe7c17e628. // The reference operation returns the memory address of the first memory cell of a POINT sized chunk of contiguous memory cells which are allocated to the POINT data attribute named C.
&amp;D = 0x7ffe7c17e630. // The reference operation returns the memory address of the first memory cell of a POINT sized chunk of contiguous memory cells which are allocated to the POINT data attribute named D.
sizeof(int) = 4. // The sizeof() operation returns the nonnegative integer number of bytes of memory which an int type variable occupies. (Each memory cell has a data capacity of 1 byte).
sizeof(int *) = 8. // The sizeof() operation returns the nonnegative integer number of bytes of memory which a pointer-to-int type variable occupies. (Each memory cell has a data capacity of 1 byte).
sizeof(int **) = 8. // The sizeof() operation returns the nonnegative integer number of bytes of memory which an pointer-to-pointer-to-int type variable occupies. (Each memory cell has a data capacity of 1 byte).
sizeof(std::string) = 32. // The sizeof() operation returns the nonnegative integer number of bytes of memory which a string type variable occupies. (Each memory cell has a data capacity of 1 byte).
sizeof(std::string *) = 8. // The sizeof() operation returns the nonnegative integer number of bytes of memory which a pointer-to-string type variable occupies. (Each memory cell has a data capacity of 1 byte).
sizeof(std::string **) = 8. // The sizeof() operation returns the nonnegative integer number of bytes of memory which a pointer-to-pointer-to-string type variable occupies. (Each memory cell has a data capacity of 1 byte).
sizeof(POINT) = 8. // The sizeof() operation returns the nonnegative integer number of bytes of memory which a POINT type object occupies. (Each memory cell has a data capacity of 1 byte).
sizeof(POINT *) = 8. // The sizeof() operation returns the nonnegative integer number of bytes of memory which a pointer-to-POINT type variable occupies. (Each memory cell has a data capacity of 1 byte).
sizeof(POINT **) = 8. // The sizeof() operation returns the nonnegative integer number of bytes of memory which a pointer-to-pointer-to-POINT type variable occupies. (Each memory cell has a data capacity of 1 byte).
sizeof(POLYGON) = 72. // The sizeof() operation returns the nonnegative integer number of bytes of memory which a POLYGON type object occupies. (Each memory cell has a data capacity of 1 byte).
sizeof(POLYGON *) = 8. // The sizeof() operation returns the nonnegative integer number of bytes of memory which a pointer-to-POLYGON type variable occupies. (Each memory cell has a data capacity of 1 byte).
sizeof(POLYGON **) = 8. // The sizeof() operation returns the nonnegative integer number of bytes of memory which a pointer-to-pointer-to-POLYGON type variable occupies. (Each memory cell has a data capacity of 1 byte).
sizeof(QUADRILATERAL) = 136. // The sizeof() operation returns the nonnegative integer number of bytes of memory which a QUADRILATERAL type object occupies. (Each memory cell has a data capacity of 1 byte).
sizeof(QUADRILATERAL *) = 8. // The sizeof() operation returns the nonnegative integer number of bytes of memory which a pointer-to-QUADRILATERAL type variable occupies. (Each memory cell has a data capacity of 1 byte).
sizeof(QUADRILATERAL **) = 8. // The sizeof() operation returns the nonnegative integer number of bytes of memory which a pointer-to-pointer-to-QUADRILATERAL type variable occupies. (Each memory cell has a data capacity of 1 byte).
category = POLYGON/QUADRILATERAL. // This is an immutable string type value which is a data member of the caller QUADRILATERAL object.
color = purple. // This is a string type value which is a data member of the caller QUADRILATERAL object.
A = POINT(0,0). // A represents a point (which is neither B nor C nor D) plotted on a two-dimensional Cartesian grid (such that the X value represents a real whole number position along the horizontal axis of the Cartesian grid while Y represents a real whole number position along the vertical axis of the same Cartesian grid).
B = POINT(0,5). // B represents a point (which is neither A nor C nor D) plotted on a two-dimensional Cartesian grid (such that the X value represents a real whole number position along the horizontal axis of the Cartesian grid while Y represents a real whole number position along the vertical axis of the same Cartesian grid).
C = POINT(4,5). // C represents a point (which is neither A nor B nor D) plotted on a two-dimensional Cartesian grid (such that the X value represents a real whole number position along the horizontal axis of the Cartesian grid while Y represents a real whole number position along the vertical axis of the same Cartesian grid).
D = POINT(4,0). // D represents a point (which is neither A nor B nor C) plotted on a two-dimensional Cartesian grid (such that the X value represents a real whole number position along the horizontal axis of the Cartesian grid while Y represents a real whole number position along the vertical axis of the same Cartesian grid).
a = B.get_distance_from(C) = 4. // The method returns the approximate nonnegative real number of Cartesian grid unit lengths which span the length of the shortest path between points B and C.
b = C.get_distance_from(D) = 5. // The method returns the approximate nonnegative real number of Cartesian grid unit lengths which span the length of the shortest path between points C and D.
c = D.get_distance_from(A) = 4. // The method returns the approximate nonnegative real number of Cartesian grid unit lengths which span the length of the shortest path between points D and A.
d = A.get_distance_from(B) = 5. // The method returns the approximate nonnegative real number of Cartesian grid unit lengths which span the length of the shortest path between points A and B.
A.get_slope_of_line_to(B) = inf. // The method returns the approximate nonnegative real number which represents the slope of the line which intersects points A and B.
B.get_slope_of_line_to(C) = 0. // The method returns the approximate nonnegative real number which represents the slope of the line which intersects points B and C.
C.get_slope_of_line_to(D) = -inf. // The method returns the approximate nonnegative real number which represents the slope of the line which intersects points C and D.
D.get_slope_of_line_to(A) = 0. // The method returns the approximate nonnegative real number which represents the slope of the line which intersects points B and C.
interior_angle_DAB = interior_angle_of_A = 90.00007601981207017161068506538867950439453125. // The value represents the approximate nonnegative real number angle measurement of the acute or else right angle formed by the intersection of the line segment whose endpoints are D and A with the line segment whose endpoints are A and B such that those two line segments intersect at A (and the angle measurement is in degrees and not in radians).
interior_angle_ABC = interior_angle_of_B = 90.0000760198120559607559698633849620819091796875. // The method returns the approximate nonnegative real number angle measurement of the acute or else right angle formed by the intersection of the line segment whose endpoints are A and B with the line segment whose endpoints are B and C such that those two line segments intersect at B (and the angle measurement is in degrees and not in radians).
interior_angle_BCD = interior_angle_of_C = 90.00007601981207017161068506538867950439453125. // The method returns the approximate nonnegative real number angle measurement of the acute or else right angle formed by the intersection of the line segment whose endpoints are B and C with the line segment whose endpoints are C and D such that those two line segments intersect at C (and the angle measurement is in degrees and not in radians).
interior_angle_CDA = interior_angle_of_D = 90.0000760198120559607559698633849620819091796875. // The method returns the approximate nonnegative real number angle measurement of the acute or else right angle formed by the intersection of the line segment whose endpoints are C and D with the line segment whose endpoints are D and A such that those two line segments intersect at D (and the angle measurement is in degrees and not in radians).
interior_angle_of_A + interior_angle_of_B + interior_angle_of_C + interior_angle_of_D = 360.000304079248280686442740261554718017578125. // sum of all four approximate interior angle measurements of the quadrilateral represented by the caller QUADRILATERAL object (in degrees and not in radians)
get_perimeter() = a + b + c + d = 18. // The method returns the sum of the four approximated side lengths of the quadrilateral which the caller QUADRILATERAL object represents.
get_area() = 20. // The method returns the approximate nonnegative real number of Cartesian grid unit squares which are enclosed inside of the two-dimensional region formed by the four line segments which connect points A to B, B to C, C to D, and D to A.
--------------------------------------------------------------------------------------------------

--------------------------------------------------------------------------------------------------
this = 0x7ffe7c17e640. // The keyword named this is a pointer which stores the memory address of the first memory cell of a QUADRILATERAL sized chunk of contiguous memory cells which are allocated to the caller TRIANGLE object.
&amp;category = 0x7ffe7c17e688. // The reference operation returns the memory address of the first memory cell of a string sized chunk of contiguous memory cells which are allocated to the string data attribute named category.
&amp;color = 0x7ffe7c17e668. // The reference operation returns the memory address of the first memory cell of a string sized chunk of contiguous memory cells which are allocated to the string data attribute named color..
&amp;A = 0x7ffe7c17e6a8. // The reference operation returns the memory address of the first memory cell of a POINT sized chunk of contiguous memory cells which are allocated to the POINT data attribute named A.
&amp;B = 0x7ffe7c17e6b0. // The reference operation returns the memory address of the first memory cell of a POINT sized chunk of contiguous memory cells which are allocated to the POINT data attribute named B.
&amp;C = 0x7ffe7c17e6b8. // The reference operation returns the memory address of the first memory cell of a POINT sized chunk of contiguous memory cells which are allocated to the POINT data attribute named C.
&amp;D = 0x7ffe7c17e6c0. // The reference operation returns the memory address of the first memory cell of a POINT sized chunk of contiguous memory cells which are allocated to the POINT data attribute named D.
sizeof(int) = 4. // The sizeof() operation returns the nonnegative integer number of bytes of memory which an int type variable occupies. (Each memory cell has a data capacity of 1 byte).
sizeof(int *) = 8. // The sizeof() operation returns the nonnegative integer number of bytes of memory which a pointer-to-int type variable occupies. (Each memory cell has a data capacity of 1 byte).
sizeof(int **) = 8. // The sizeof() operation returns the nonnegative integer number of bytes of memory which an pointer-to-pointer-to-int type variable occupies. (Each memory cell has a data capacity of 1 byte).
sizeof(std::string) = 32. // The sizeof() operation returns the nonnegative integer number of bytes of memory which a string type variable occupies. (Each memory cell has a data capacity of 1 byte).
sizeof(std::string *) = 8. // The sizeof() operation returns the nonnegative integer number of bytes of memory which a pointer-to-string type variable occupies. (Each memory cell has a data capacity of 1 byte).
sizeof(std::string **) = 8. // The sizeof() operation returns the nonnegative integer number of bytes of memory which a pointer-to-pointer-to-string type variable occupies. (Each memory cell has a data capacity of 1 byte).
sizeof(POINT) = 8. // The sizeof() operation returns the nonnegative integer number of bytes of memory which a POINT type object occupies. (Each memory cell has a data capacity of 1 byte).
sizeof(POINT *) = 8. // The sizeof() operation returns the nonnegative integer number of bytes of memory which a pointer-to-POINT type variable occupies. (Each memory cell has a data capacity of 1 byte).
sizeof(POINT **) = 8. // The sizeof() operation returns the nonnegative integer number of bytes of memory which a pointer-to-pointer-to-POINT type variable occupies. (Each memory cell has a data capacity of 1 byte).
sizeof(POLYGON) = 72. // The sizeof() operation returns the nonnegative integer number of bytes of memory which a POLYGON type object occupies. (Each memory cell has a data capacity of 1 byte).
sizeof(POLYGON *) = 8. // The sizeof() operation returns the nonnegative integer number of bytes of memory which a pointer-to-POLYGON type variable occupies. (Each memory cell has a data capacity of 1 byte).
sizeof(POLYGON **) = 8. // The sizeof() operation returns the nonnegative integer number of bytes of memory which a pointer-to-pointer-to-POLYGON type variable occupies. (Each memory cell has a data capacity of 1 byte).
sizeof(QUADRILATERAL) = 136. // The sizeof() operation returns the nonnegative integer number of bytes of memory which a QUADRILATERAL type object occupies. (Each memory cell has a data capacity of 1 byte).
sizeof(QUADRILATERAL *) = 8. // The sizeof() operation returns the nonnegative integer number of bytes of memory which a pointer-to-QUADRILATERAL type variable occupies. (Each memory cell has a data capacity of 1 byte).
sizeof(QUADRILATERAL **) = 8. // The sizeof() operation returns the nonnegative integer number of bytes of memory which a pointer-to-pointer-to-QUADRILATERAL type variable occupies. (Each memory cell has a data capacity of 1 byte).
category = POLYGON/QUADRILATERAL. // This is an immutable string type value which is a data member of the caller QUADRILATERAL object.
color = yellow. // This is a string type value which is a data member of the caller QUADRILATERAL object.
A = POINT(0,0). // A represents a point (which is neither B nor C nor D) plotted on a two-dimensional Cartesian grid (such that the X value represents a real whole number position along the horizontal axis of the Cartesian grid while Y represents a real whole number position along the vertical axis of the same Cartesian grid).
B = POINT(0,2). // B represents a point (which is neither A nor C nor D) plotted on a two-dimensional Cartesian grid (such that the X value represents a real whole number position along the horizontal axis of the Cartesian grid while Y represents a real whole number position along the vertical axis of the same Cartesian grid).
C = POINT(4,0). // C represents a point (which is neither A nor B nor D) plotted on a two-dimensional Cartesian grid (such that the X value represents a real whole number position along the horizontal axis of the Cartesian grid while Y represents a real whole number position along the vertical axis of the same Cartesian grid).
D = POINT(4,2). // D represents a point (which is neither A nor B nor C) plotted on a two-dimensional Cartesian grid (such that the X value represents a real whole number position along the horizontal axis of the Cartesian grid while Y represents a real whole number position along the vertical axis of the same Cartesian grid).
a = B.get_distance_from(C) = 4.47213595499957961010295548476278781890869140625. // The method returns the approximate nonnegative real number of Cartesian grid unit lengths which span the length of the shortest path between points B and C.
b = C.get_distance_from(D) = 2. // The method returns the approximate nonnegative real number of Cartesian grid unit lengths which span the length of the shortest path between points C and D.
c = D.get_distance_from(A) = 4.47213595499957961010295548476278781890869140625. // The method returns the approximate nonnegative real number of Cartesian grid unit lengths which span the length of the shortest path between points D and A.
d = A.get_distance_from(B) = 2. // The method returns the approximate nonnegative real number of Cartesian grid unit lengths which span the length of the shortest path between points A and B.
A.get_slope_of_line_to(B) = inf. // The method returns the approximate nonnegative real number which represents the slope of the line which intersects points A and B.
B.get_slope_of_line_to(C) = -0.5. // The method returns the approximate nonnegative real number which represents the slope of the line which intersects points B and C.
C.get_slope_of_line_to(D) = inf. // The method returns the approximate nonnegative real number which represents the slope of the line which intersects points C and D.
D.get_slope_of_line_to(A) = 0.5. // The method returns the approximate nonnegative real number which represents the slope of the line which intersects points B and C.
interior_angle_DAB = interior_angle_of_A = 63.4350024041763163040741346776485443115234375. // The value represents the approximate nonnegative real number angle measurement of the acute or else right angle formed by the intersection of the line segment whose endpoints are D and A with the line segment whose endpoints are A and B such that those two line segments intersect at A (and the angle measurement is in degrees and not in radians).
interior_angle_ABC = interior_angle_of_B = 116.565149635447824039147235453128814697265625. // The method returns the approximate nonnegative real number angle measurement of the acute or else right angle formed by the intersection of the line segment whose endpoints are A and B with the line segment whose endpoints are B and C such that those two line segments intersect at B (and the angle measurement is in degrees and not in radians).
interior_angle_BCD = interior_angle_of_C = 63.4350024041763163040741346776485443115234375. // The method returns the approximate nonnegative real number angle measurement of the acute or else right angle formed by the intersection of the line segment whose endpoints are B and C with the line segment whose endpoints are C and D such that those two line segments intersect at C (and the angle measurement is in degrees and not in radians).
interior_angle_CDA = interior_angle_of_D = 116.565149635447824039147235453128814697265625. // The method returns the approximate nonnegative real number angle measurement of the acute or else right angle formed by the intersection of the line segment whose endpoints are C and D with the line segment whose endpoints are D and A such that those two line segments intersect at D (and the angle measurement is in degrees and not in radians).
interior_angle_of_A + interior_angle_of_B + interior_angle_of_C + interior_angle_of_D = 360.000304079248280686442740261554718017578125. // sum of all four approximate interior angle measurements of the quadrilateral represented by the caller QUADRILATERAL object (in degrees and not in radians)
get_perimeter() = a + b + c + d = 12.9442719099991592202059109695255756378173828125. // The method returns the sum of the four approximated side lengths of the quadrilateral which the caller QUADRILATERAL object represents.
get_area() = 8. // The method returns the approximate nonnegative real number of Cartesian grid unit squares which are enclosed inside of the two-dimensional region formed by the four line segments which connect points A to B, B to C, C to D, and D to A.
--------------------------------------------------------------------------------------------------
--------------------------------------------------------------------------------------------------
Unit Test # 6: Test the default TRAPEZOID constructor and the TRAPEZOID print method.
--------------------------------------------------------------------------------------------------
TRAPEZOID trapezoid;
trapezoid.print(); // Test the default argument (which is std::cout).
trapezoid.print(output);
output &lt; print(output); // Indirectly call the POLYGON print method.

--------------------------------------------------------------------------------------------------
memory_address = 0x562bfd008670.
category = POLYGON.
color = orange.
&amp;category = 0x562bfd008678.
&amp;color = 0x562bfd008698.
--------------------------------------------------------------------------------------------------
pointer_to_polygon -&gt; get_area() = 1.9999999999999993338661852249060757458209991455078125. // Indirectly call the POLYGON get_area() method.
pointer_to_polygon -&gt; get_perimeter() = 6.8284271247461898468600338674150407314300537109375. // Indirectly call the POLYGON get_permieter() method.
delete pointer_to_polygon; // De-allocate memory which was assigned to the dynamically allocated TRAPEZOID instance.
--------------------------------------------------------------------------------------------------

--------------------------------------------------------------------------------------------------
Unit Test # 8: Create a pointer-to-QUADRILATERAL type variable to store the memory address of a dynamically allocated TRAPEZOID instance. Use that pointer-to-QUADRILATERAL type variable to call the QUADRILATERAL print method.
--------------------------------------------------------------------------------------------------
QUADRILATERAL * pointer_to_quadrilateral; // The pointer-to-QUADRILATERAL type variable can store the memory address of an object whose data type is a non-abstract derived class of QUADRILATERAL such as TRAPEZOID.
pointer_to_quadrilateral = new TRAPEZOID; // Assign memory to a dynamic TRAPEZOID instance (i.e. and dynamic implies that the variable was created during program runtime instead of program compile time).
pointer_to_quadrilateral -&gt; print(output); // Indirectly call the QUADRILATERAL print method.
delete pointer_to_quadrilateral; // De-allocate memory which was assigned to the dynamically allocated TRAPEZOID instance.
--------------------------------------------------------------------------------------------------

--------------------------------------------------------------------------------------------------
this = 0x562bfd008670. // The keyword named this is a pointer which stores the memory address of the first memory cell of a QUADRILATERAL sized chunk of contiguous memory cells which are allocated to the caller TRIANGLE object.
&amp;category = 0x562bfd0086b8. // The reference operation returns the memory address of the first memory cell of a string sized chunk of contiguous memory cells which are allocated to the string data attribute named category.
&amp;color = 0x562bfd008698. // The reference operation returns the memory address of the first memory cell of a string sized chunk of contiguous memory cells which are allocated to the string data attribute named color..
&amp;A = 0x562bfd0086d8. // The reference operation returns the memory address of the first memory cell of a POINT sized chunk of contiguous memory cells which are allocated to the POINT data attribute named A.
&amp;B = 0x562bfd0086e0. // The reference operation returns the memory address of the first memory cell of a POINT sized chunk of contiguous memory cells which are allocated to the POINT data attribute named B.
&amp;C = 0x562bfd0086e8. // The reference operation returns the memory address of the first memory cell of a POINT sized chunk of contiguous memory cells which are allocated to the POINT data attribute named C.
&amp;D = 0x562bfd0086f0. // The reference operation returns the memory address of the first memory cell of a POINT sized chunk of contiguous memory cells which are allocated to the POINT data attribute named D.
sizeof(int) = 4. // The sizeof() operation returns the nonnegative integer number of bytes of memory which an int type variable occupies. (Each memory cell has a data capacity of 1 byte).
sizeof(int *) = 8. // The sizeof() operation returns the nonnegative integer number of bytes of memory which a pointer-to-int type variable occupies. (Each memory cell has a data capacity of 1 byte).
sizeof(int **) = 8. // The sizeof() operation returns the nonnegative integer number of bytes of memory which an pointer-to-pointer-to-int type variable occupies. (Each memory cell has a data capacity of 1 byte).
sizeof(std::string) = 32. // The sizeof() operation returns the nonnegative integer number of bytes of memory which a string type variable occupies. (Each memory cell has a data capacity of 1 byte).
sizeof(std::string *) = 8. // The sizeof() operation returns the nonnegative integer number of bytes of memory which a pointer-to-string type variable occupies. (Each memory cell has a data capacity of 1 byte).
sizeof(std::string **) = 8. // The sizeof() operation returns the nonnegative integer number of bytes of memory which a pointer-to-pointer-to-string type variable occupies. (Each memory cell has a data capacity of 1 byte).
sizeof(POINT) = 8. // The sizeof() operation returns the nonnegative integer number of bytes of memory which a POINT type object occupies. (Each memory cell has a data capacity of 1 byte).
sizeof(POINT *) = 8. // The sizeof() operation returns the nonnegative integer number of bytes of memory which a pointer-to-POINT type variable occupies. (Each memory cell has a data capacity of 1 byte).
sizeof(POINT **) = 8. // The sizeof() operation returns the nonnegative integer number of bytes of memory which a pointer-to-pointer-to-POINT type variable occupies. (Each memory cell has a data capacity of 1 byte).
sizeof(POLYGON) = 72. // The sizeof() operation returns the nonnegative integer number of bytes of memory which a POLYGON type object occupies. (Each memory cell has a data capacity of 1 byte).
sizeof(POLYGON *) = 8. // The sizeof() operation returns the nonnegative integer number of bytes of memory which a pointer-to-POLYGON type variable occupies. (Each memory cell has a data capacity of 1 byte).
sizeof(POLYGON **) = 8. // The sizeof() operation returns the nonnegative integer number of bytes of memory which a pointer-to-pointer-to-POLYGON type variable occupies. (Each memory cell has a data capacity of 1 byte).
sizeof(QUADRILATERAL) = 136. // The sizeof() operation returns the nonnegative integer number of bytes of memory which a QUADRILATERAL type object occupies. (Each memory cell has a data capacity of 1 byte).
sizeof(QUADRILATERAL *) = 8. // The sizeof() operation returns the nonnegative integer number of bytes of memory which a pointer-to-QUADRILATERAL type variable occupies. (Each memory cell has a data capacity of 1 byte).
sizeof(QUADRILATERAL **) = 8. // The sizeof() operation returns the nonnegative integer number of bytes of memory which a pointer-to-pointer-to-QUADRILATERAL type variable occupies. (Each memory cell has a data capacity of 1 byte).
category = POLYGON/QUADRILATERAL. // This is an immutable string type value which is a data member of the caller QUADRILATERAL object.
color = orange. // This is a string type value which is a data member of the caller QUADRILATERAL object.
A = POINT(0,0). // A represents a point (which is neither B nor C nor D) plotted on a two-dimensional Cartesian grid (such that the X value represents a real whole number position along the horizontal axis of the Cartesian grid while Y represents a real whole number position along the vertical axis of the same Cartesian grid).
B = POINT(1,1). // B represents a point (which is neither A nor C nor D) plotted on a two-dimensional Cartesian grid (such that the X value represents a real whole number position along the horizontal axis of the Cartesian grid while Y represents a real whole number position along the vertical axis of the same Cartesian grid).
C = POINT(2,1). // C represents a point (which is neither A nor B nor D) plotted on a two-dimensional Cartesian grid (such that the X value represents a real whole number position along the horizontal axis of the Cartesian grid while Y represents a real whole number position along the vertical axis of the same Cartesian grid).
D = POINT(3,0). // D represents a point (which is neither A nor B nor C) plotted on a two-dimensional Cartesian grid (such that the X value represents a real whole number position along the horizontal axis of the Cartesian grid while Y represents a real whole number position along the vertical axis of the same Cartesian grid).
a = B.get_distance_from(C) = 1. // The method returns the approximate nonnegative real number of Cartesian grid unit lengths which span the length of the shortest path between points B and C.
b = C.get_distance_from(D) = 1.4142135623730951454746218587388284504413604736328125. // The method returns the approximate nonnegative real number of Cartesian grid unit lengths which span the length of the shortest path between points C and D.
c = D.get_distance_from(A) = 3. // The method returns the approximate nonnegative real number of Cartesian grid unit lengths which span the length of the shortest path between points D and A.
d = A.get_distance_from(B) = 1.4142135623730951454746218587388284504413604736328125. // The method returns the approximate nonnegative real number of Cartesian grid unit lengths which span the length of the shortest path between points A and B.
A.get_slope_of_line_to(B) = 1. // The method returns the approximate nonnegative real number which represents the slope of the line which intersects points A and B.
B.get_slope_of_line_to(C) = 0. // The method returns the approximate nonnegative real number which represents the slope of the line which intersects points B and C.
C.get_slope_of_line_to(D) = -1. // The method returns the approximate nonnegative real number which represents the slope of the line which intersects points C and D.
D.get_slope_of_line_to(A) = 0. // The method returns the approximate nonnegative real number which represents the slope of the line which intersects points B and C.
interior_angle_DAB = interior_angle_of_A = 45.00003800990604219123270013369619846343994140625. // The value represents the approximate nonnegative real number angle measurement of the acute or else right angle formed by the intersection of the line segment whose endpoints are D and A with the line segment whose endpoints are A and B such that those two line segments intersect at A (and the angle measurement is in degrees and not in radians).
interior_angle_ABC = interior_angle_of_B = 135.00011402971807683570659719407558441162109375. // The method returns the approximate nonnegative real number angle measurement of the acute or else right angle formed by the intersection of the line segment whose endpoints are A and B with the line segment whose endpoints are B and C such that those two line segments intersect at B (and the angle measurement is in degrees and not in radians).
interior_angle_BCD = interior_angle_of_C = 135.0001140297181336791254580020904541015625. // The method returns the approximate nonnegative real number angle measurement of the acute or else right angle formed by the intersection of the line segment whose endpoints are B and C with the line segment whose endpoints are C and D such that those two line segments intersect at C (and the angle measurement is in degrees and not in radians).
interior_angle_CDA = interior_angle_of_D = 45.00003800990599955866855452768504619598388671875. // The method returns the approximate nonnegative real number angle measurement of the acute or else right angle formed by the intersection of the line segment whose endpoints are C and D with the line segment whose endpoints are D and A such that those two line segments intersect at D (and the angle measurement is in degrees and not in radians).
interior_angle_of_A + interior_angle_of_B + interior_angle_of_C + interior_angle_of_D = 360.000304079248280686442740261554718017578125. // sum of all four approximate interior angle measurements of the quadrilateral represented by the caller QUADRILATERAL object (in degrees and not in radians)
get_perimeter() = a + b + c + d = 6.8284271247461898468600338674150407314300537109375. // The method returns the sum of the four approximated side lengths of the quadrilateral which the caller QUADRILATERAL object represents.
get_area() = 1.9999999999999993338661852249060757458209991455078125. // The method returns the approximate nonnegative real number of Cartesian grid unit squares which are enclosed inside of the two-dimensional region formed by the four line segments which connect points A to B, B to C, C to D, and D to A.
--------------------------------------------------------------------------------------------------
--------------------------------------------------------------------------------------------------
Unit Test # 9: Test the normal TRAPEZOID constructor and TRAPEZOID copy constructor using valid function inputs and the TRAPEZOID print method.
--------------------------------------------------------------------------------------------------
TRAPEZOID trapezoid_0 = TRAPEZOID("pink", POINT(-5,-10), POINT(0,5), POINT(15,5), POINT(30,-10));
trapezoid_0.print(output);
TRAPEZOID trapezoid_1 = TRAPEZOID("brown", POINT(0,0), POINT(4,-5), POINT(15,-5), POINT(45,0));
trapezoid_1.print(output);
TRAPEZOID trapezoid_2 = TRAPEZOID(trapezoid_0);
trapezoid_2.print(output);
--------------------------------------------------------------------------------------------------

--------------------------------------------------------------------------------------------------
this = 0x7ffe7c17e4c0. // The keyword named this is a pointer which stores the memory address of the first memory cell of a QUADRILATERAL sized chunk of contiguous memory cells which are allocated to the caller TRIANGLE object.
&amp;category = 0x7ffe7c17e548. // The reference operation returns the memory address of the first memory cell of a string sized chunk of contiguous memory cells which are allocated to the string data attribute named category.
&amp;color = 0x7ffe7c17e4e8. // The reference operation returns the memory address of the first memory cell of a string sized chunk of contiguous memory cells which are allocated to the string data attribute named color..
&amp;A = 0x7ffe7c17e528. // The reference operation returns the memory address of the first memory cell of a POINT sized chunk of contiguous memory cells which are allocated to the POINT data attribute named A.
&amp;B = 0x7ffe7c17e530. // The reference operation returns the memory address of the first memory cell of a POINT sized chunk of contiguous memory cells which are allocated to the POINT data attribute named B.
&amp;C = 0x7ffe7c17e538. // The reference operation returns the memory address of the first memory cell of a POINT sized chunk of contiguous memory cells which are allocated to the POINT data attribute named C.
&amp;D = 0x7ffe7c17e540. // The reference operation returns the memory address of the first memory cell of a POINT sized chunk of contiguous memory cells which are allocated to the POINT data attribute named D.
sizeof(int) = 4. // The sizeof() operation returns the nonnegative integer number of bytes of memory which an int type variable occupies. (Each memory cell has a data capacity of 1 byte).
sizeof(int *) = 8. // The sizeof() operation returns the nonnegative integer number of bytes of memory which a pointer-to-int type variable occupies. (Each memory cell has a data capacity of 1 byte).
sizeof(int **) = 8. // The sizeof() operation returns the nonnegative integer number of bytes of memory which an pointer-to-pointer-to-int type variable occupies. (Each memory cell has a data capacity of 1 byte).
sizeof(std::string) = 32. // The sizeof() operation returns the nonnegative integer number of bytes of memory which a string type variable occupies. (Each memory cell has a data capacity of 1 byte).
sizeof(std::string *) = 8. // The sizeof() operation returns the nonnegative integer number of bytes of memory which a pointer-to-string type variable occupies. (Each memory cell has a data capacity of 1 byte).
sizeof(std::string **) = 8. // The sizeof() operation returns the nonnegative integer number of bytes of memory which a pointer-to-pointer-to-string type variable occupies. (Each memory cell has a data capacity of 1 byte).
sizeof(POINT) = 8. // The sizeof() operation returns the nonnegative integer number of bytes of memory which a POINT type object occupies. (Each memory cell has a data capacity of 1 byte).
sizeof(POINT *) = 8. // The sizeof() operation returns the nonnegative integer number of bytes of memory which a pointer-to-POINT type variable occupies. (Each memory cell has a data capacity of 1 byte).
sizeof(POINT **) = 8. // The sizeof() operation returns the nonnegative integer number of bytes of memory which a pointer-to-pointer-to-POINT type variable occupies. (Each memory cell has a data capacity of 1 byte).
sizeof(POLYGON) = 72. // The sizeof() operation returns the nonnegative integer number of bytes of memory which a POLYGON type object occupies. (Each memory cell has a data capacity of 1 byte).
sizeof(POLYGON *) = 8. // The sizeof() operation returns the nonnegative integer number of bytes of memory which a pointer-to-POLYGON type variable occupies. (Each memory cell has a data capacity of 1 byte).
sizeof(POLYGON **) = 8. // The sizeof() operation returns the nonnegative integer number of bytes of memory which a pointer-to-pointer-to-POLYGON type variable occupies. (Each memory cell has a data capacity of 1 byte).
sizeof(QUADRILATERAL) = 136. // The sizeof() operation returns the nonnegative integer number of bytes of memory which a QUADRILATERAL type object occupies. (Each memory cell has a data capacity of 1 byte).
sizeof(QUADRILATERAL *) = 8. // The sizeof() operation returns the nonnegative integer number of bytes of memory which a pointer-to-QUADRILATERAL type variable occupies. (Each memory cell has a data capacity of 1 byte).
sizeof(QUADRILATERAL **) = 8. // The sizeof() operation returns the nonnegative integer number of bytes of memory which a pointer-to-pointer-to-QUADRILATERAL type variable occupies. (Each memory cell has a data capacity of 1 byte).
sizeof(TRAPEZOID) = 168. // The sizeof() operation returns the nonnegative integer number of bytes of memory which a TRAPEZOID type object occupies. (Each memory cell has a data capacity of 1 byte).
sizeof(TRAPEZOID *) = 8. // The sizeof() operation returns the nonnegative integer number of bytes of memory which a pointer-to-TRAPEZOID type variable occupies. (Each memory cell has a data capacity of 1 byte).
sizeof(TRAPEZOID **) = 8. // The sizeof() operation returns the nonnegative integer number of bytes of memory which a pointer-to-pointer-to-TRAPEZOID type variable occupies. (Each memory cell has a data capacity of 1 byte).
category = POLYGON/QUADRILATERAL/TRAPEZOID. // This is an immutable string type value which is a data member of the caller TRAPEZOID object.
color = pink. // This is a string type value which is a data member of the caller TRAPEZOID object.
A = POINT(-5,-10). // A represents a point (which is neither B nor C nor D) plotted on a two-dimensional Cartesian grid (such that the X value represents a real whole number position along the horizontal axis of the Cartesian grid while Y represents a real whole number position along the vertical axis of the same Cartesian grid).
B = POINT(0,5). // B represents a point (which is neither A nor C nor D) plotted on a two-dimensional Cartesian grid (such that the X value represents a real whole number position along the horizontal axis of the Cartesian grid while Y represents a real whole number position along the vertical axis of the same Cartesian grid).
C = POINT(15,5). // C represents a point (which is neither A nor B nor D) plotted on a two-dimensional Cartesian grid (such that the X value represents a real whole number position along the horizontal axis of the Cartesian grid while Y represents a real whole number position along the vertical axis of the same Cartesian grid).
D = POINT(30,-10). // D represents a point (which is neither A nor B nor C) plotted on a two-dimensional Cartesian grid (such that the X value represents a real whole number position along the horizontal axis of the Cartesian grid while Y represents a real whole number position along the vertical axis of the same Cartesian grid).
a = B.get_distance_from(C) = 15. // The method returns the approximate nonnegative real number of Cartesian grid unit lengths which span the length of the shortest path between points B and C.
b = C.get_distance_from(D) = 21.21320343559642651598551310598850250244140625. // The method returns the approximate nonnegative real number of Cartesian grid unit lengths which span the length of the shortest path between points C and D.
c = D.get_distance_from(A) = 35. // The method returns the approximate nonnegative real number of Cartesian grid unit lengths which span the length of the shortest path between points D and A.
d = A.get_distance_from(B) = 15.8113883008418962816676867078058421611785888671875. // The method returns the approximate nonnegative real number of Cartesian grid unit lengths which span the length of the shortest path between points A and B.
A.get_slope_of_line_to(B) = 3. // The method returns the approximate nonnegative real number which represents the slope of the line which intersects points A and B.
B.get_slope_of_line_to(C) = 0. // The method returns the approximate nonnegative real number which represents the slope of the line which intersects points B and C.
C.get_slope_of_line_to(D) = -1. // The method returns the approximate nonnegative real number which represents the slope of the line which intersects points C and D.
D.get_slope_of_line_to(A) = 0. // The method returns the approximate nonnegative real number which represents the slope of the line which intersects points B and C.
interior_angle_DAB = interior_angle_of_A = 71.5651116255417747424871777184307575225830078125. // The value represents the approximate nonnegative real number angle measurement of the acute or else right angle formed by the intersection of the line segment whose endpoints are D and A with the line segment whose endpoints are A and B such that those two line segments intersect at A (and the angle measurement is in degrees and not in radians).
interior_angle_ABC = interior_angle_of_B = 108.4350404140823940224436228163540363311767578125. // The method returns the approximate nonnegative real number angle measurement of the acute or else right angle formed by the intersection of the line segment whose endpoints are A and B with the line segment whose endpoints are B and C such that those two line segments intersect at B (and the angle measurement is in degrees and not in radians).
interior_angle_BCD = interior_angle_of_C = 135.00011402971807683570659719407558441162109375. // The method returns the approximate nonnegative real number angle measurement of the acute or else right angle formed by the intersection of the line segment whose endpoints are B and C with the line segment whose endpoints are C and D such that those two line segments intersect at C (and the angle measurement is in degrees and not in radians).
interior_angle_CDA = interior_angle_of_D = 45.00003800990604219123270013369619846343994140625. // The method returns the approximate nonnegative real number angle measurement of the acute or else right angle formed by the intersection of the line segment whose endpoints are C and D with the line segment whose endpoints are D and A such that those two line segments intersect at D (and the angle measurement is in degrees and not in radians).
interior_angle_of_A + interior_angle_of_B + interior_angle_of_C + interior_angle_of_D = 360.00030407924833752986160106956958770751953125. // sum of all four approximate interior angle measurements of the quadrilateral represented by the caller QUADRILATERAL object (in degrees and not in radians)
get_perimeter() = a + b + c + d = 87.0245917364383245740100392140448093414306640625. // The method returns the sum of the four approximated side lengths of the trapezoid which the caller TRAPEZOID object represents.
get_area() = 375. // The method returns the approximate nonnegative real number of Cartesian grid unit squares which are enclosed inside of the two-dimensional region formed by the four line segments which connect points A to B, B to C, C to D, and D to A.
--------------------------------------------------------------------------------------------------

--------------------------------------------------------------------------------------------------
this = 0x7ffe7c17e570. // The keyword named this is a pointer which stores the memory address of the first memory cell of a QUADRILATERAL sized chunk of contiguous memory cells which are allocated to the caller TRIANGLE object.
&amp;category = 0x7ffe7c17e5f8. // The reference operation returns the memory address of the first memory cell of a string sized chunk of contiguous memory cells which are allocated to the string data attribute named category.
&amp;color = 0x7ffe7c17e598. // The reference operation returns the memory address of the first memory cell of a string sized chunk of contiguous memory cells which are allocated to the string data attribute named color..
&amp;A = 0x7ffe7c17e5d8. // The reference operation returns the memory address of the first memory cell of a POINT sized chunk of contiguous memory cells which are allocated to the POINT data attribute named A.
&amp;B = 0x7ffe7c17e5e0. // The reference operation returns the memory address of the first memory cell of a POINT sized chunk of contiguous memory cells which are allocated to the POINT data attribute named B.
&amp;C = 0x7ffe7c17e5e8. // The reference operation returns the memory address of the first memory cell of a POINT sized chunk of contiguous memory cells which are allocated to the POINT data attribute named C.
&amp;D = 0x7ffe7c17e5f0. // The reference operation returns the memory address of the first memory cell of a POINT sized chunk of contiguous memory cells which are allocated to the POINT data attribute named D.
sizeof(int) = 4. // The sizeof() operation returns the nonnegative integer number of bytes of memory which an int type variable occupies. (Each memory cell has a data capacity of 1 byte).
sizeof(int *) = 8. // The sizeof() operation returns the nonnegative integer number of bytes of memory which a pointer-to-int type variable occupies. (Each memory cell has a data capacity of 1 byte).
sizeof(int **) = 8. // The sizeof() operation returns the nonnegative integer number of bytes of memory which an pointer-to-pointer-to-int type variable occupies. (Each memory cell has a data capacity of 1 byte).
sizeof(std::string) = 32. // The sizeof() operation returns the nonnegative integer number of bytes of memory which a string type variable occupies. (Each memory cell has a data capacity of 1 byte).
sizeof(std::string *) = 8. // The sizeof() operation returns the nonnegative integer number of bytes of memory which a pointer-to-string type variable occupies. (Each memory cell has a data capacity of 1 byte).
sizeof(std::string **) = 8. // The sizeof() operation returns the nonnegative integer number of bytes of memory which a pointer-to-pointer-to-string type variable occupies. (Each memory cell has a data capacity of 1 byte).
sizeof(POINT) = 8. // The sizeof() operation returns the nonnegative integer number of bytes of memory which a POINT type object occupies. (Each memory cell has a data capacity of 1 byte).
sizeof(POINT *) = 8. // The sizeof() operation returns the nonnegative integer number of bytes of memory which a pointer-to-POINT type variable occupies. (Each memory cell has a data capacity of 1 byte).
sizeof(POINT **) = 8. // The sizeof() operation returns the nonnegative integer number of bytes of memory which a pointer-to-pointer-to-POINT type variable occupies. (Each memory cell has a data capacity of 1 byte).
sizeof(POLYGON) = 72. // The sizeof() operation returns the nonnegative integer number of bytes of memory which a POLYGON type object occupies. (Each memory cell has a data capacity of 1 byte).
sizeof(POLYGON *) = 8. // The sizeof() operation returns the nonnegative integer number of bytes of memory which a pointer-to-POLYGON type variable occupies. (Each memory cell has a data capacity of 1 byte).
sizeof(POLYGON **) = 8. // The sizeof() operation returns the nonnegative integer number of bytes of memory which a pointer-to-pointer-to-POLYGON type variable occupies. (Each memory cell has a data capacity of 1 byte).
sizeof(QUADRILATERAL) = 136. // The sizeof() operation returns the nonnegative integer number of bytes of memory which a QUADRILATERAL type object occupies. (Each memory cell has a data capacity of 1 byte).
sizeof(QUADRILATERAL *) = 8. // The sizeof() operation returns the nonnegative integer number of bytes of memory which a pointer-to-QUADRILATERAL type variable occupies. (Each memory cell has a data capacity of 1 byte).
sizeof(QUADRILATERAL **) = 8. // The sizeof() operation returns the nonnegative integer number of bytes of memory which a pointer-to-pointer-to-QUADRILATERAL type variable occupies. (Each memory cell has a data capacity of 1 byte).
sizeof(TRAPEZOID) = 168. // The sizeof() operation returns the nonnegative integer number of bytes of memory which a TRAPEZOID type object occupies. (Each memory cell has a data capacity of 1 byte).
sizeof(TRAPEZOID *) = 8. // The sizeof() operation returns the nonnegative integer number of bytes of memory which a pointer-to-TRAPEZOID type variable occupies. (Each memory cell has a data capacity of 1 byte).
sizeof(TRAPEZOID **) = 8. // The sizeof() operation returns the nonnegative integer number of bytes of memory which a pointer-to-pointer-to-TRAPEZOID type variable occupies. (Each memory cell has a data capacity of 1 byte).
category = POLYGON/QUADRILATERAL/TRAPEZOID. // This is an immutable string type value which is a data member of the caller TRAPEZOID object.
color = brown. // This is a string type value which is a data member of the caller TRAPEZOID object.
A = POINT(0,0). // A represents a point (which is neither B nor C nor D) plotted on a two-dimensional Cartesian grid (such that the X value represents a real whole number position along the horizontal axis of the Cartesian grid while Y represents a real whole number position along the vertical axis of the same Cartesian grid).
B = POINT(4,-5). // B represents a point (which is neither A nor C nor D) plotted on a two-dimensional Cartesian grid (such that the X value represents a real whole number position along the horizontal axis of the Cartesian grid while Y represents a real whole number position along the vertical axis of the same Cartesian grid).
C = POINT(15,-5). // C represents a point (which is neither A nor B nor D) plotted on a two-dimensional Cartesian grid (such that the X value represents a real whole number position along the horizontal axis of the Cartesian grid while Y represents a real whole number position along the vertical axis of the same Cartesian grid).
D = POINT(45,0). // D represents a point (which is neither A nor B nor C) plotted on a two-dimensional Cartesian grid (such that the X value represents a real whole number position along the horizontal axis of the Cartesian grid while Y represents a real whole number position along the vertical axis of the same Cartesian grid).
a = B.get_distance_from(C) = 11. // The method returns the approximate nonnegative real number of Cartesian grid unit lengths which span the length of the shortest path between points B and C.
b = C.get_distance_from(D) = 30.413812651491099359191139228641986846923828125. // The method returns the approximate nonnegative real number of Cartesian grid unit lengths which span the length of the shortest path between points C and D.
c = D.get_distance_from(A) = 45. // The method returns the approximate nonnegative real number of Cartesian grid unit lengths which span the length of the shortest path between points D and A.
d = A.get_distance_from(B) = 6.403124237432848531170748174190521240234375. // The method returns the approximate nonnegative real number of Cartesian grid unit lengths which span the length of the shortest path between points A and B.
A.get_slope_of_line_to(B) = -1.25. // The method returns the approximate nonnegative real number which represents the slope of the line which intersects points A and B.
B.get_slope_of_line_to(C) = 0. // The method returns the approximate nonnegative real number which represents the slope of the line which intersects points B and C.
C.get_slope_of_line_to(D) = 0.1666666666666666574148081281236954964697360992431640625. // The method returns the approximate nonnegative real number which represents the slope of the line which intersects points C and D.
D.get_slope_of_line_to(A) = 0. // The method returns the approximate nonnegative real number which represents the slope of the line which intersects points B and C.
interior_angle_DAB = interior_angle_of_A = 51.34023511115130844473242177627980709075927734375. // The value represents the approximate nonnegative real number angle measurement of the acute or else right angle formed by the intersection of the line segment whose endpoints are D and A with the line segment whose endpoints are A and B such that those two line segments intersect at A (and the angle measurement is in degrees and not in radians).
interior_angle_ABC = interior_angle_of_B = 128.659916928472881636480451561510562896728515625. // The method returns the approximate nonnegative real number angle measurement of the acute or else right angle formed by the intersection of the line segment whose endpoints are A and B with the line segment whose endpoints are B and C such that those two line segments intersect at B (and the angle measurement is in degrees and not in radians).
interior_angle_BCD = interior_angle_of_C = 170.53782183910999492582050152122974395751953125. // The method returns the approximate nonnegative real number angle measurement of the acute or else right angle formed by the intersection of the line segment whose endpoints are B and C with the line segment whose endpoints are C and D such that those two line segments intersect at C (and the angle measurement is in degrees and not in radians).
interior_angle_CDA = interior_angle_of_D = 9.462330200513985545285322587005794048309326171875. // The method returns the approximate nonnegative real number angle measurement of the acute or else right angle formed by the intersection of the line segment whose endpoints are C and D with the line segment whose endpoints are D and A such that those two line segments intersect at D (and the angle measurement is in degrees and not in radians).
interior_angle_of_A + interior_angle_of_B + interior_angle_of_C + interior_angle_of_D = 360.0003040792481669996050186455249786376953125. // sum of all four approximate interior angle measurements of the quadrilateral represented by the caller QUADRILATERAL object (in degrees and not in radians)
get_perimeter() = a + b + c + d = 92.816936888923947890361887402832508087158203125. // The method returns the sum of the four approximated side lengths of the trapezoid which the caller TRAPEZOID object represents.
get_area() = 140.0000000000001136868377216160297393798828125. // The method returns the approximate nonnegative real number of Cartesian grid unit squares which are enclosed inside of the two-dimensional region formed by the four line segments which connect points A to B, B to C, C to D, and D to A.
--------------------------------------------------------------------------------------------------

--------------------------------------------------------------------------------------------------
this = 0x7ffe7c17e620. // The keyword named this is a pointer which stores the memory address of the first memory cell of a QUADRILATERAL sized chunk of contiguous memory cells which are allocated to the caller TRIANGLE object.
&amp;category = 0x7ffe7c17e6a8. // The reference operation returns the memory address of the first memory cell of a string sized chunk of contiguous memory cells which are allocated to the string data attribute named category.
&amp;color = 0x7ffe7c17e648. // The reference operation returns the memory address of the first memory cell of a string sized chunk of contiguous memory cells which are allocated to the string data attribute named color..
&amp;A = 0x7ffe7c17e688. // The reference operation returns the memory address of the first memory cell of a POINT sized chunk of contiguous memory cells which are allocated to the POINT data attribute named A.
&amp;B = 0x7ffe7c17e690. // The reference operation returns the memory address of the first memory cell of a POINT sized chunk of contiguous memory cells which are allocated to the POINT data attribute named B.
&amp;C = 0x7ffe7c17e698. // The reference operation returns the memory address of the first memory cell of a POINT sized chunk of contiguous memory cells which are allocated to the POINT data attribute named C.
&amp;D = 0x7ffe7c17e6a0. // The reference operation returns the memory address of the first memory cell of a POINT sized chunk of contiguous memory cells which are allocated to the POINT data attribute named D.
sizeof(int) = 4. // The sizeof() operation returns the nonnegative integer number of bytes of memory which an int type variable occupies. (Each memory cell has a data capacity of 1 byte).
sizeof(int *) = 8. // The sizeof() operation returns the nonnegative integer number of bytes of memory which a pointer-to-int type variable occupies. (Each memory cell has a data capacity of 1 byte).
sizeof(int **) = 8. // The sizeof() operation returns the nonnegative integer number of bytes of memory which an pointer-to-pointer-to-int type variable occupies. (Each memory cell has a data capacity of 1 byte).
sizeof(std::string) = 32. // The sizeof() operation returns the nonnegative integer number of bytes of memory which a string type variable occupies. (Each memory cell has a data capacity of 1 byte).
sizeof(std::string *) = 8. // The sizeof() operation returns the nonnegative integer number of bytes of memory which a pointer-to-string type variable occupies. (Each memory cell has a data capacity of 1 byte).
sizeof(std::string **) = 8. // The sizeof() operation returns the nonnegative integer number of bytes of memory which a pointer-to-pointer-to-string type variable occupies. (Each memory cell has a data capacity of 1 byte).
sizeof(POINT) = 8. // The sizeof() operation returns the nonnegative integer number of bytes of memory which a POINT type object occupies. (Each memory cell has a data capacity of 1 byte).
sizeof(POINT *) = 8. // The sizeof() operation returns the nonnegative integer number of bytes of memory which a pointer-to-POINT type variable occupies. (Each memory cell has a data capacity of 1 byte).
sizeof(POINT **) = 8. // The sizeof() operation returns the nonnegative integer number of bytes of memory which a pointer-to-pointer-to-POINT type variable occupies. (Each memory cell has a data capacity of 1 byte).
sizeof(POLYGON) = 72. // The sizeof() operation returns the nonnegative integer number of bytes of memory which a POLYGON type object occupies. (Each memory cell has a data capacity of 1 byte).
sizeof(POLYGON *) = 8. // The sizeof() operation returns the nonnegative integer number of bytes of memory which a pointer-to-POLYGON type variable occupies. (Each memory cell has a data capacity of 1 byte).
sizeof(POLYGON **) = 8. // The sizeof() operation returns the nonnegative integer number of bytes of memory which a pointer-to-pointer-to-POLYGON type variable occupies. (Each memory cell has a data capacity of 1 byte).
sizeof(QUADRILATERAL) = 136. // The sizeof() operation returns the nonnegative integer number of bytes of memory which a QUADRILATERAL type object occupies. (Each memory cell has a data capacity of 1 byte).
sizeof(QUADRILATERAL *) = 8. // The sizeof() operation returns the nonnegative integer number of bytes of memory which a pointer-to-QUADRILATERAL type variable occupies. (Each memory cell has a data capacity of 1 byte).
sizeof(QUADRILATERAL **) = 8. // The sizeof() operation returns the nonnegative integer number of bytes of memory which a pointer-to-pointer-to-QUADRILATERAL type variable occupies. (Each memory cell has a data capacity of 1 byte).
sizeof(TRAPEZOID) = 168. // The sizeof() operation returns the nonnegative integer number of bytes of memory which a TRAPEZOID type object occupies. (Each memory cell has a data capacity of 1 byte).
sizeof(TRAPEZOID *) = 8. // The sizeof() operation returns the nonnegative integer number of bytes of memory which a pointer-to-TRAPEZOID type variable occupies. (Each memory cell has a data capacity of 1 byte).
sizeof(TRAPEZOID **) = 8. // The sizeof() operation returns the nonnegative integer number of bytes of memory which a pointer-to-pointer-to-TRAPEZOID type variable occupies. (Each memory cell has a data capacity of 1 byte).
category = POLYGON/QUADRILATERAL/TRAPEZOID. // This is an immutable string type value which is a data member of the caller TRAPEZOID object.
color = pink. // This is a string type value which is a data member of the caller TRAPEZOID object.
A = POINT(-5,-10). // A represents a point (which is neither B nor C nor D) plotted on a two-dimensional Cartesian grid (such that the X value represents a real whole number position along the horizontal axis of the Cartesian grid while Y represents a real whole number position along the vertical axis of the same Cartesian grid).
B = POINT(0,5). // B represents a point (which is neither A nor C nor D) plotted on a two-dimensional Cartesian grid (such that the X value represents a real whole number position along the horizontal axis of the Cartesian grid while Y represents a real whole number position along the vertical axis of the same Cartesian grid).
C = POINT(15,5). // C represents a point (which is neither A nor B nor D) plotted on a two-dimensional Cartesian grid (such that the X value represents a real whole number position along the horizontal axis of the Cartesian grid while Y represents a real whole number position along the vertical axis of the same Cartesian grid).
D = POINT(30,-10). // D represents a point (which is neither A nor B nor C) plotted on a two-dimensional Cartesian grid (such that the X value represents a real whole number position along the horizontal axis of the Cartesian grid while Y represents a real whole number position along the vertical axis of the same Cartesian grid).
a = B.get_distance_from(C) = 15. // The method returns the approximate nonnegative real number of Cartesian grid unit lengths which span the length of the shortest path between points B and C.
b = C.get_distance_from(D) = 21.21320343559642651598551310598850250244140625. // The method returns the approximate nonnegative real number of Cartesian grid unit lengths which span the length of the shortest path between points C and D.
c = D.get_distance_from(A) = 35. // The method returns the approximate nonnegative real number of Cartesian grid unit lengths which span the length of the shortest path between points D and A.
d = A.get_distance_from(B) = 15.8113883008418962816676867078058421611785888671875. // The method returns the approximate nonnegative real number of Cartesian grid unit lengths which span the length of the shortest path between points A and B.
A.get_slope_of_line_to(B) = 3. // The method returns the approximate nonnegative real number which represents the slope of the line which intersects points A and B.
B.get_slope_of_line_to(C) = 0. // The method returns the approximate nonnegative real number which represents the slope of the line which intersects points B and C.
C.get_slope_of_line_to(D) = -1. // The method returns the approximate nonnegative real number which represents the slope of the line which intersects points C and D.
D.get_slope_of_line_to(A) = 0. // The method returns the approximate nonnegative real number which represents the slope of the line which intersects points B and C.
interior_angle_DAB = interior_angle_of_A = 71.5651116255417747424871777184307575225830078125. // The value represents the approximate nonnegative real number angle measurement of the acute or else right angle formed by the intersection of the line segment whose endpoints are D and A with the line segment whose endpoints are A and B such that those two line segments intersect at A (and the angle measurement is in degrees and not in radians).
interior_angle_ABC = interior_angle_of_B = 108.4350404140823940224436228163540363311767578125. // The method returns the approximate nonnegative real number angle measurement of the acute or else right angle formed by the intersection of the line segment whose endpoints are A and B with the line segment whose endpoints are B and C such that those two line segments intersect at B (and the angle measurement is in degrees and not in radians).
interior_angle_BCD = interior_angle_of_C = 135.00011402971807683570659719407558441162109375. // The method returns the approximate nonnegative real number angle measurement of the acute or else right angle formed by the intersection of the line segment whose endpoints are B and C with the line segment whose endpoints are C and D such that those two line segments intersect at C (and the angle measurement is in degrees and not in radians).
interior_angle_CDA = interior_angle_of_D = 45.00003800990604219123270013369619846343994140625. // The method returns the approximate nonnegative real number angle measurement of the acute or else right angle formed by the intersection of the line segment whose endpoints are C and D with the line segment whose endpoints are D and A such that those two line segments intersect at D (and the angle measurement is in degrees and not in radians).
interior_angle_of_A + interior_angle_of_B + interior_angle_of_C + interior_angle_of_D = 360.00030407924833752986160106956958770751953125. // sum of all four approximate interior angle measurements of the quadrilateral represented by the caller QUADRILATERAL object (in degrees and not in radians)
get_perimeter() = a + b + c + d = 87.0245917364383245740100392140448093414306640625. // The method returns the sum of the four approximated side lengths of the trapezoid which the caller TRAPEZOID object represents.
get_area() = 375. // The method returns the approximate nonnegative real number of Cartesian grid unit squares which are enclosed inside of the two-dimensional region formed by the four line segments which connect points A to B, B to C, C to D, and D to A.
--------------------------------------------------------------------------------------------------
--------------------------------------------------------------------------------------------------
Unit Test # 10: Test the default RECTANGLE constructor and the RECTANGLE print method.
--------------------------------------------------------------------------------------------------
RECTANGLE rectangle;
rectangle.print(); // Test the default argument (which is std::cout).
rectangle.print(output);
output &lt; print(output); // Indirectly call the POLYGON print method.

--------------------------------------------------------------------------------------------------
memory_address = 0x562bfd008670.
category = POLYGON.
color = orange.
&amp;category = 0x562bfd008678.
&amp;color = 0x562bfd008698.
--------------------------------------------------------------------------------------------------
// COMMENTED OUT (does not work): pointer_to_polygon -&gt; quadrilateral_test(). // Indirectly call the QUADRILATERAL quadrilateral_test() method.
pointer_to_polygon -&gt; get_area() = 12. // Indirectly call the POLYGON get_area() method.
pointer_to_polygon -&gt; get_perimeter() = 14. // Indirectly call the POLYGON get_permieter() method.
delete pointer_to_polygon; // De-allocate memory which was assigned to the dynamically allocated RECTANGLE instance.
--------------------------------------------------------------------------------------------------

--------------------------------------------------------------------------------------------------
Unit Test # 12: Create a pointer-to-QUADRILATERAL type variable to store the memory address of a dynamically allocated RECTANGLE instance. Use that pointer-to-QUADRILATERAL type variable to call the POLYGON print method and the QUADRILATERAL getter methods.
--------------------------------------------------------------------------------------------------
QUADRILATERAL * pointer_to_quadrilateral; // The pointer-to-QUADRILATERAL type variable can store the memory address of an object whose data type is a non-abstract derived class of QUADRILATERAL such as RECTANGLE.
pointer_to_quadrilateral = new RECTANGLE; // Assign memory to a dynamic RECTANGLE instance (i.e. and dynamic implies that the variable was created during program runtime instead of program compile time).
pointer_to_quadrilateral -&gt; print(output); // Indirectly call the QUADRILATERAL print method.

--------------------------------------------------------------------------------------------------
this = 0x562bfd008670. // The keyword named this is a pointer which stores the memory address of the first memory cell of a QUADRILATERAL sized chunk of contiguous memory cells which are allocated to the caller TRIANGLE object.
&amp;category = 0x562bfd0086b8. // The reference operation returns the memory address of the first memory cell of a string sized chunk of contiguous memory cells which are allocated to the string data attribute named category.
&amp;color = 0x562bfd008698. // The reference operation returns the memory address of the first memory cell of a string sized chunk of contiguous memory cells which are allocated to the string data attribute named color..
&amp;A = 0x562bfd0086d8. // The reference operation returns the memory address of the first memory cell of a POINT sized chunk of contiguous memory cells which are allocated to the POINT data attribute named A.
&amp;B = 0x562bfd0086e0. // The reference operation returns the memory address of the first memory cell of a POINT sized chunk of contiguous memory cells which are allocated to the POINT data attribute named B.
&amp;C = 0x562bfd0086e8. // The reference operation returns the memory address of the first memory cell of a POINT sized chunk of contiguous memory cells which are allocated to the POINT data attribute named C.
&amp;D = 0x562bfd0086f0. // The reference operation returns the memory address of the first memory cell of a POINT sized chunk of contiguous memory cells which are allocated to the POINT data attribute named D.
sizeof(int) = 4. // The sizeof() operation returns the nonnegative integer number of bytes of memory which an int type variable occupies. (Each memory cell has a data capacity of 1 byte).
sizeof(int *) = 8. // The sizeof() operation returns the nonnegative integer number of bytes of memory which a pointer-to-int type variable occupies. (Each memory cell has a data capacity of 1 byte).
sizeof(int **) = 8. // The sizeof() operation returns the nonnegative integer number of bytes of memory which an pointer-to-pointer-to-int type variable occupies. (Each memory cell has a data capacity of 1 byte).
sizeof(std::string) = 32. // The sizeof() operation returns the nonnegative integer number of bytes of memory which a string type variable occupies. (Each memory cell has a data capacity of 1 byte).
sizeof(std::string *) = 8. // The sizeof() operation returns the nonnegative integer number of bytes of memory which a pointer-to-string type variable occupies. (Each memory cell has a data capacity of 1 byte).
sizeof(std::string **) = 8. // The sizeof() operation returns the nonnegative integer number of bytes of memory which a pointer-to-pointer-to-string type variable occupies. (Each memory cell has a data capacity of 1 byte).
sizeof(POINT) = 8. // The sizeof() operation returns the nonnegative integer number of bytes of memory which a POINT type object occupies. (Each memory cell has a data capacity of 1 byte).
sizeof(POINT *) = 8. // The sizeof() operation returns the nonnegative integer number of bytes of memory which a pointer-to-POINT type variable occupies. (Each memory cell has a data capacity of 1 byte).
sizeof(POINT **) = 8. // The sizeof() operation returns the nonnegative integer number of bytes of memory which a pointer-to-pointer-to-POINT type variable occupies. (Each memory cell has a data capacity of 1 byte).
sizeof(POLYGON) = 72. // The sizeof() operation returns the nonnegative integer number of bytes of memory which a POLYGON type object occupies. (Each memory cell has a data capacity of 1 byte).
sizeof(POLYGON *) = 8. // The sizeof() operation returns the nonnegative integer number of bytes of memory which a pointer-to-POLYGON type variable occupies. (Each memory cell has a data capacity of 1 byte).
sizeof(POLYGON **) = 8. // The sizeof() operation returns the nonnegative integer number of bytes of memory which a pointer-to-pointer-to-POLYGON type variable occupies. (Each memory cell has a data capacity of 1 byte).
sizeof(QUADRILATERAL) = 136. // The sizeof() operation returns the nonnegative integer number of bytes of memory which a QUADRILATERAL type object occupies. (Each memory cell has a data capacity of 1 byte).
sizeof(QUADRILATERAL *) = 8. // The sizeof() operation returns the nonnegative integer number of bytes of memory which a pointer-to-QUADRILATERAL type variable occupies. (Each memory cell has a data capacity of 1 byte).
sizeof(QUADRILATERAL **) = 8. // The sizeof() operation returns the nonnegative integer number of bytes of memory which a pointer-to-pointer-to-QUADRILATERAL type variable occupies. (Each memory cell has a data capacity of 1 byte).
category = POLYGON/QUADRILATERAL. // This is an immutable string type value which is a data member of the caller QUADRILATERAL object.
color = orange. // This is a string type value which is a data member of the caller QUADRILATERAL object.
A = POINT(0,0). // A represents a point (which is neither B nor C nor D) plotted on a two-dimensional Cartesian grid (such that the X value represents a real whole number position along the horizontal axis of the Cartesian grid while Y represents a real whole number position along the vertical axis of the same Cartesian grid).
B = POINT(0,3). // B represents a point (which is neither A nor C nor D) plotted on a two-dimensional Cartesian grid (such that the X value represents a real whole number position along the horizontal axis of the Cartesian grid while Y represents a real whole number position along the vertical axis of the same Cartesian grid).
C = POINT(4,3). // C represents a point (which is neither A nor B nor D) plotted on a two-dimensional Cartesian grid (such that the X value represents a real whole number position along the horizontal axis of the Cartesian grid while Y represents a real whole number position along the vertical axis of the same Cartesian grid).
D = POINT(4,0). // D represents a point (which is neither A nor B nor C) plotted on a two-dimensional Cartesian grid (such that the X value represents a real whole number position along the horizontal axis of the Cartesian grid while Y represents a real whole number position along the vertical axis of the same Cartesian grid).
a = B.get_distance_from(C) = 4. // The method returns the approximate nonnegative real number of Cartesian grid unit lengths which span the length of the shortest path between points B and C.
b = C.get_distance_from(D) = 3. // The method returns the approximate nonnegative real number of Cartesian grid unit lengths which span the length of the shortest path between points C and D.
c = D.get_distance_from(A) = 4. // The method returns the approximate nonnegative real number of Cartesian grid unit lengths which span the length of the shortest path between points D and A.
d = A.get_distance_from(B) = 3. // The method returns the approximate nonnegative real number of Cartesian grid unit lengths which span the length of the shortest path between points A and B.
A.get_slope_of_line_to(B) = inf. // The method returns the approximate nonnegative real number which represents the slope of the line which intersects points A and B.
B.get_slope_of_line_to(C) = 0. // The method returns the approximate nonnegative real number which represents the slope of the line which intersects points B and C.
C.get_slope_of_line_to(D) = -inf. // The method returns the approximate nonnegative real number which represents the slope of the line which intersects points C and D.
D.get_slope_of_line_to(A) = 0. // The method returns the approximate nonnegative real number which represents the slope of the line which intersects points B and C.
interior_angle_DAB = interior_angle_of_A = 90.00007601981207017161068506538867950439453125. // The value represents the approximate nonnegative real number angle measurement of the acute or else right angle formed by the intersection of the line segment whose endpoints are D and A with the line segment whose endpoints are A and B such that those two line segments intersect at A (and the angle measurement is in degrees and not in radians).
interior_angle_ABC = interior_angle_of_B = 90.00007601981207017161068506538867950439453125. // The method returns the approximate nonnegative real number angle measurement of the acute or else right angle formed by the intersection of the line segment whose endpoints are A and B with the line segment whose endpoints are B and C such that those two line segments intersect at B (and the angle measurement is in degrees and not in radians).
interior_angle_BCD = interior_angle_of_C = 90.00007601981207017161068506538867950439453125. // The method returns the approximate nonnegative real number angle measurement of the acute or else right angle formed by the intersection of the line segment whose endpoints are B and C with the line segment whose endpoints are C and D such that those two line segments intersect at C (and the angle measurement is in degrees and not in radians).
interior_angle_CDA = interior_angle_of_D = 90.00007601981207017161068506538867950439453125. // The method returns the approximate nonnegative real number angle measurement of the acute or else right angle formed by the intersection of the line segment whose endpoints are C and D with the line segment whose endpoints are D and A such that those two line segments intersect at D (and the angle measurement is in degrees and not in radians).
interior_angle_of_A + interior_angle_of_B + interior_angle_of_C + interior_angle_of_D = 360.000304079248280686442740261554718017578125. // sum of all four approximate interior angle measurements of the quadrilateral represented by the caller QUADRILATERAL object (in degrees and not in radians)
get_perimeter() = a + b + c + d = 14. // The method returns the sum of the four approximated side lengths of the quadrilateral which the caller QUADRILATERAL object represents.
get_area() = 12. // The method returns the approximate nonnegative real number of Cartesian grid unit squares which are enclosed inside of the two-dimensional region formed by the four line segments which connect points A to B, B to C, C to D, and D to A.
--------------------------------------------------------------------------------------------------
// COMMENTED OUT (does not work): pointer_to_quadrilateral -&gt; rectangle_test(); // Indirectly call the RECTANGLE rectangle_test() method.
pointer_to_quadrilateral -&gt; get_area() = 12. // Indirectly call the QUADRILATERAL get_area() method.
pointer_to_quadrilateral -&gt; get_perimeter() = 14. // Indirectly call the QUADRILATERAL get_permieter() method.
delete pointer_to_quadrilateral; // De-allocate memory which was assigned to the dynamically allocated RECTANGLE instance.
--------------------------------------------------------------------------------------------------
--------------------------------------------------------------------------------------------------
Unit Test # 13: Test the normal RECTANGLE constructor and RECTANGLE copy constructor using valid function inputs and the RECTANGLE print method.
--------------------------------------------------------------------------------------------------
RECTANGLE rectangle_0 = RECTANGLE("gray", POINT(9,10), POINT(9,5), POINT(3,5), POINT(3,10));
rectangle_0.print(output);
RECTANGLE rectangle_1 = RECTANGLE("black", POINT(0,0), POINT(0,1), POINT(1,1), POINT(1,0));
rectangle_1.print(output);
RECTANGLE rectangle_2 = RECTANGLE(rectangle_0);
rectangle_2.print(output);
--------------------------------------------------------------------------------------------------

--------------------------------------------------------------------------------------------------
this = 0x7ffe7c17e4c0. // The keyword named this is a pointer which stores the memory address of the first memory cell of a QUADRILATERAL sized chunk of contiguous memory cells which are allocated to the caller TRIANGLE object.
&amp;category = 0x7ffe7c17e548. // The reference operation returns the memory address of the first memory cell of a string sized chunk of contiguous memory cells which are allocated to the string data attribute named category.
&amp;color = 0x7ffe7c17e4e8. // The reference operation returns the memory address of the first memory cell of a string sized chunk of contiguous memory cells which are allocated to the string data attribute named color..
&amp;A = 0x7ffe7c17e528. // The reference operation returns the memory address of the first memory cell of a POINT sized chunk of contiguous memory cells which are allocated to the POINT data attribute named A.
&amp;B = 0x7ffe7c17e530. // The reference operation returns the memory address of the first memory cell of a POINT sized chunk of contiguous memory cells which are allocated to the POINT data attribute named B.
&amp;C = 0x7ffe7c17e538. // The reference operation returns the memory address of the first memory cell of a POINT sized chunk of contiguous memory cells which are allocated to the POINT data attribute named C.
&amp;D = 0x7ffe7c17e540. // The reference operation returns the memory address of the first memory cell of a POINT sized chunk of contiguous memory cells which are allocated to the POINT data attribute named D.
sizeof(int) = 4. // The sizeof() operation returns the nonnegative integer number of bytes of memory which an int type variable occupies. (Each memory cell has a data capacity of 1 byte).
sizeof(int *) = 8. // The sizeof() operation returns the nonnegative integer number of bytes of memory which a pointer-to-int type variable occupies. (Each memory cell has a data capacity of 1 byte).
sizeof(int **) = 8. // The sizeof() operation returns the nonnegative integer number of bytes of memory which an pointer-to-pointer-to-int type variable occupies. (Each memory cell has a data capacity of 1 byte).
sizeof(std::string) = 32. // The sizeof() operation returns the nonnegative integer number of bytes of memory which a string type variable occupies. (Each memory cell has a data capacity of 1 byte).
sizeof(std::string *) = 8. // The sizeof() operation returns the nonnegative integer number of bytes of memory which a pointer-to-string type variable occupies. (Each memory cell has a data capacity of 1 byte).
sizeof(std::string **) = 8. // The sizeof() operation returns the nonnegative integer number of bytes of memory which a pointer-to-pointer-to-string type variable occupies. (Each memory cell has a data capacity of 1 byte).
sizeof(POINT) = 8. // The sizeof() operation returns the nonnegative integer number of bytes of memory which a POINT type object occupies. (Each memory cell has a data capacity of 1 byte).
sizeof(POINT *) = 8. // The sizeof() operation returns the nonnegative integer number of bytes of memory which a pointer-to-POINT type variable occupies. (Each memory cell has a data capacity of 1 byte).
sizeof(POINT **) = 8. // The sizeof() operation returns the nonnegative integer number of bytes of memory which a pointer-to-pointer-to-POINT type variable occupies. (Each memory cell has a data capacity of 1 byte).
sizeof(POLYGON) = 72. // The sizeof() operation returns the nonnegative integer number of bytes of memory which a POLYGON type object occupies. (Each memory cell has a data capacity of 1 byte).
sizeof(POLYGON *) = 8. // The sizeof() operation returns the nonnegative integer number of bytes of memory which a pointer-to-POLYGON type variable occupies. (Each memory cell has a data capacity of 1 byte).
sizeof(POLYGON **) = 8. // The sizeof() operation returns the nonnegative integer number of bytes of memory which a pointer-to-pointer-to-POLYGON type variable occupies. (Each memory cell has a data capacity of 1 byte).
sizeof(QUADRILATERAL) = 136. // The sizeof() operation returns the nonnegative integer number of bytes of memory which a QUADRILATERAL type object occupies. (Each memory cell has a data capacity of 1 byte).
sizeof(QUADRILATERAL *) = 8. // The sizeof() operation returns the nonnegative integer number of bytes of memory which a pointer-to-QUADRILATERAL type variable occupies. (Each memory cell has a data capacity of 1 byte).
sizeof(QUADRILATERAL **) = 8. // The sizeof() operation returns the nonnegative integer number of bytes of memory which a pointer-to-pointer-to-QUADRILATERAL type variable occupies. (Each memory cell has a data capacity of 1 byte).
sizeof(RECTANGLE) = 168. // The sizeof() operation returns the nonnegative integer number of bytes of memory which a RECTANGLE type object occupies. (Each memory cell has a data capacity of 1 byte).
sizeof(RECTANGLE *) = 8. // The sizeof() operation returns the nonnegative integer number of bytes of memory which a pointer-to-RECTANGLE type variable occupies. (Each memory cell has a data capacity of 1 byte).
sizeof(RECTANGLE **) = 8. // The sizeof() operation returns the nonnegative integer number of bytes of memory which a pointer-to-pointer-to-RECTANGLE type variable occupies. (Each memory cell has a data capacity of 1 byte).
category = POLYGON/QUADRILATERAL/RECTANGLE. // This is an immutable string type value which is a data member of the caller RECTANGLE object.
color = gray. // This is a string type value which is a data member of the caller RECTANGLE object.
A = POINT(9,10). // A represents a point (which is neither B nor C nor D) plotted on a two-dimensional Cartesian grid (such that the X value represents a real whole number position along the horizontal axis of the Cartesian grid while Y represents a real whole number position along the vertical axis of the same Cartesian grid).
B = POINT(9,5). // B represents a point (which is neither A nor C nor D) plotted on a two-dimensional Cartesian grid (such that the X value represents a real whole number position along the horizontal axis of the Cartesian grid while Y represents a real whole number position along the vertical axis of the same Cartesian grid).
C = POINT(3,5). // C represents a point (which is neither A nor B nor D) plotted on a two-dimensional Cartesian grid (such that the X value represents a real whole number position along the horizontal axis of the Cartesian grid while Y represents a real whole number position along the vertical axis of the same Cartesian grid).
D = POINT(3,10). // D represents a point (which is neither A nor B nor C) plotted on a two-dimensional Cartesian grid (such that the X value represents a real whole number position along the horizontal axis of the Cartesian grid while Y represents a real whole number position along the vertical axis of the same Cartesian grid).
a = B.get_distance_from(C) = 6. // The method returns the approximate nonnegative real number of Cartesian grid unit lengths which span the length of the shortest path between points B and C.
b = C.get_distance_from(D) = 5. // The method returns the approximate nonnegative real number of Cartesian grid unit lengths which span the length of the shortest path between points C and D.
c = D.get_distance_from(A) = 6. // The method returns the approximate nonnegative real number of Cartesian grid unit lengths which span the length of the shortest path between points D and A.
d = A.get_distance_from(B) = 5. // The method returns the approximate nonnegative real number of Cartesian grid unit lengths which span the length of the shortest path between points A and B.
A.get_slope_of_line_to(B) = -inf. // The method returns the approximate nonnegative real number which represents the slope of the line which intersects points A and B.
B.get_slope_of_line_to(C) = 0. // The method returns the approximate nonnegative real number which represents the slope of the line which intersects points B and C.
C.get_slope_of_line_to(D) = inf. // The method returns the approximate nonnegative real number which represents the slope of the line which intersects points C and D.
D.get_slope_of_line_to(A) = 0. // The method returns the approximate nonnegative real number which represents the slope of the line which intersects points B and C.
interior_angle_DAB = interior_angle_of_A = 90.00007601981207017161068506538867950439453125. // The value represents the approximate nonnegative real number angle measurement of the acute or else right angle formed by the intersection of the line segment whose endpoints are D and A with the line segment whose endpoints are A and B such that those two line segments intersect at A (and the angle measurement is in degrees and not in radians).
interior_angle_ABC = interior_angle_of_B = 90.0000760198120559607559698633849620819091796875. // The method returns the approximate nonnegative real number angle measurement of the acute or else right angle formed by the intersection of the line segment whose endpoints are A and B with the line segment whose endpoints are B and C such that those two line segments intersect at B (and the angle measurement is in degrees and not in radians).
interior_angle_BCD = interior_angle_of_C = 90.00007601981207017161068506538867950439453125. // The method returns the approximate nonnegative real number angle measurement of the acute or else right angle formed by the intersection of the line segment whose endpoints are B and C with the line segment whose endpoints are C and D such that those two line segments intersect at C (and the angle measurement is in degrees and not in radians).
interior_angle_CDA = interior_angle_of_D = 90.0000760198120559607559698633849620819091796875. // The method returns the approximate nonnegative real number angle measurement of the acute or else right angle formed by the intersection of the line segment whose endpoints are C and D with the line segment whose endpoints are D and A such that those two line segments intersect at D (and the angle measurement is in degrees and not in radians).
interior_angle_of_A + interior_angle_of_B + interior_angle_of_C + interior_angle_of_D = 360.000304079248280686442740261554718017578125. // sum of all four approximate interior angle measurements of the quadrilateral represented by the caller QUADRILATERAL object (in degrees and not in radians)
get_perimeter() = a + b + c + d = 22. // The method returns the sum of the four approximated side lengths of the rectangle which the caller RECTANGLE object represents.
get_area() = 30. // The method returns the approximate nonnegative real number of Cartesian grid unit squares which are enclosed inside of the two-dimensional region formed by the four line segments which connect points A to B, B to C, C to D, and D to A.
--------------------------------------------------------------------------------------------------

--------------------------------------------------------------------------------------------------
this = 0x7ffe7c17e570. // The keyword named this is a pointer which stores the memory address of the first memory cell of a QUADRILATERAL sized chunk of contiguous memory cells which are allocated to the caller TRIANGLE object.
&amp;category = 0x7ffe7c17e5f8. // The reference operation returns the memory address of the first memory cell of a string sized chunk of contiguous memory cells which are allocated to the string data attribute named category.
&amp;color = 0x7ffe7c17e598. // The reference operation returns the memory address of the first memory cell of a string sized chunk of contiguous memory cells which are allocated to the string data attribute named color..
&amp;A = 0x7ffe7c17e5d8. // The reference operation returns the memory address of the first memory cell of a POINT sized chunk of contiguous memory cells which are allocated to the POINT data attribute named A.
&amp;B = 0x7ffe7c17e5e0. // The reference operation returns the memory address of the first memory cell of a POINT sized chunk of contiguous memory cells which are allocated to the POINT data attribute named B.
&amp;C = 0x7ffe7c17e5e8. // The reference operation returns the memory address of the first memory cell of a POINT sized chunk of contiguous memory cells which are allocated to the POINT data attribute named C.
&amp;D = 0x7ffe7c17e5f0. // The reference operation returns the memory address of the first memory cell of a POINT sized chunk of contiguous memory cells which are allocated to the POINT data attribute named D.
sizeof(int) = 4. // The sizeof() operation returns the nonnegative integer number of bytes of memory which an int type variable occupies. (Each memory cell has a data capacity of 1 byte).
sizeof(int *) = 8. // The sizeof() operation returns the nonnegative integer number of bytes of memory which a pointer-to-int type variable occupies. (Each memory cell has a data capacity of 1 byte).
sizeof(int **) = 8. // The sizeof() operation returns the nonnegative integer number of bytes of memory which an pointer-to-pointer-to-int type variable occupies. (Each memory cell has a data capacity of 1 byte).
sizeof(std::string) = 32. // The sizeof() operation returns the nonnegative integer number of bytes of memory which a string type variable occupies. (Each memory cell has a data capacity of 1 byte).
sizeof(std::string *) = 8. // The sizeof() operation returns the nonnegative integer number of bytes of memory which a pointer-to-string type variable occupies. (Each memory cell has a data capacity of 1 byte).
sizeof(std::string **) = 8. // The sizeof() operation returns the nonnegative integer number of bytes of memory which a pointer-to-pointer-to-string type variable occupies. (Each memory cell has a data capacity of 1 byte).
sizeof(POINT) = 8. // The sizeof() operation returns the nonnegative integer number of bytes of memory which a POINT type object occupies. (Each memory cell has a data capacity of 1 byte).
sizeof(POINT *) = 8. // The sizeof() operation returns the nonnegative integer number of bytes of memory which a pointer-to-POINT type variable occupies. (Each memory cell has a data capacity of 1 byte).
sizeof(POINT **) = 8. // The sizeof() operation returns the nonnegative integer number of bytes of memory which a pointer-to-pointer-to-POINT type variable occupies. (Each memory cell has a data capacity of 1 byte).
sizeof(POLYGON) = 72. // The sizeof() operation returns the nonnegative integer number of bytes of memory which a POLYGON type object occupies. (Each memory cell has a data capacity of 1 byte).
sizeof(POLYGON *) = 8. // The sizeof() operation returns the nonnegative integer number of bytes of memory which a pointer-to-POLYGON type variable occupies. (Each memory cell has a data capacity of 1 byte).
sizeof(POLYGON **) = 8. // The sizeof() operation returns the nonnegative integer number of bytes of memory which a pointer-to-pointer-to-POLYGON type variable occupies. (Each memory cell has a data capacity of 1 byte).
sizeof(QUADRILATERAL) = 136. // The sizeof() operation returns the nonnegative integer number of bytes of memory which a QUADRILATERAL type object occupies. (Each memory cell has a data capacity of 1 byte).
sizeof(QUADRILATERAL *) = 8. // The sizeof() operation returns the nonnegative integer number of bytes of memory which a pointer-to-QUADRILATERAL type variable occupies. (Each memory cell has a data capacity of 1 byte).
sizeof(QUADRILATERAL **) = 8. // The sizeof() operation returns the nonnegative integer number of bytes of memory which a pointer-to-pointer-to-QUADRILATERAL type variable occupies. (Each memory cell has a data capacity of 1 byte).
sizeof(RECTANGLE) = 168. // The sizeof() operation returns the nonnegative integer number of bytes of memory which a RECTANGLE type object occupies. (Each memory cell has a data capacity of 1 byte).
sizeof(RECTANGLE *) = 8. // The sizeof() operation returns the nonnegative integer number of bytes of memory which a pointer-to-RECTANGLE type variable occupies. (Each memory cell has a data capacity of 1 byte).
sizeof(RECTANGLE **) = 8. // The sizeof() operation returns the nonnegative integer number of bytes of memory which a pointer-to-pointer-to-RECTANGLE type variable occupies. (Each memory cell has a data capacity of 1 byte).
category = POLYGON/QUADRILATERAL/RECTANGLE. // This is an immutable string type value which is a data member of the caller RECTANGLE object.
color = black. // This is a string type value which is a data member of the caller RECTANGLE object.
A = POINT(0,0). // A represents a point (which is neither B nor C nor D) plotted on a two-dimensional Cartesian grid (such that the X value represents a real whole number position along the horizontal axis of the Cartesian grid while Y represents a real whole number position along the vertical axis of the same Cartesian grid).
B = POINT(0,1). // B represents a point (which is neither A nor C nor D) plotted on a two-dimensional Cartesian grid (such that the X value represents a real whole number position along the horizontal axis of the Cartesian grid while Y represents a real whole number position along the vertical axis of the same Cartesian grid).
C = POINT(1,1). // C represents a point (which is neither A nor B nor D) plotted on a two-dimensional Cartesian grid (such that the X value represents a real whole number position along the horizontal axis of the Cartesian grid while Y represents a real whole number position along the vertical axis of the same Cartesian grid).
D = POINT(1,0). // D represents a point (which is neither A nor B nor C) plotted on a two-dimensional Cartesian grid (such that the X value represents a real whole number position along the horizontal axis of the Cartesian grid while Y represents a real whole number position along the vertical axis of the same Cartesian grid).
a = B.get_distance_from(C) = 1. // The method returns the approximate nonnegative real number of Cartesian grid unit lengths which span the length of the shortest path between points B and C.
b = C.get_distance_from(D) = 1. // The method returns the approximate nonnegative real number of Cartesian grid unit lengths which span the length of the shortest path between points C and D.
c = D.get_distance_from(A) = 1. // The method returns the approximate nonnegative real number of Cartesian grid unit lengths which span the length of the shortest path between points D and A.
d = A.get_distance_from(B) = 1. // The method returns the approximate nonnegative real number of Cartesian grid unit lengths which span the length of the shortest path between points A and B.
A.get_slope_of_line_to(B) = inf. // The method returns the approximate nonnegative real number which represents the slope of the line which intersects points A and B.
B.get_slope_of_line_to(C) = 0. // The method returns the approximate nonnegative real number which represents the slope of the line which intersects points B and C.
C.get_slope_of_line_to(D) = -inf. // The method returns the approximate nonnegative real number which represents the slope of the line which intersects points C and D.
D.get_slope_of_line_to(A) = 0. // The method returns the approximate nonnegative real number which represents the slope of the line which intersects points B and C.
interior_angle_DAB = interior_angle_of_A = 90.0000760198120843824654002673923969268798828125. // The value represents the approximate nonnegative real number angle measurement of the acute or else right angle formed by the intersection of the line segment whose endpoints are D and A with the line segment whose endpoints are A and B such that those two line segments intersect at A (and the angle measurement is in degrees and not in radians).
interior_angle_ABC = interior_angle_of_B = 90.000076019812041749901254661381244659423828125. // The method returns the approximate nonnegative real number angle measurement of the acute or else right angle formed by the intersection of the line segment whose endpoints are A and B with the line segment whose endpoints are B and C such that those two line segments intersect at B (and the angle measurement is in degrees and not in radians).
interior_angle_BCD = interior_angle_of_C = 90.0000760198120843824654002673923969268798828125. // The method returns the approximate nonnegative real number angle measurement of the acute or else right angle formed by the intersection of the line segment whose endpoints are B and C with the line segment whose endpoints are C and D such that those two line segments intersect at C (and the angle measurement is in degrees and not in radians).
interior_angle_CDA = interior_angle_of_D = 90.000076019812041749901254661381244659423828125. // The method returns the approximate nonnegative real number angle measurement of the acute or else right angle formed by the intersection of the line segment whose endpoints are C and D with the line segment whose endpoints are D and A such that those two line segments intersect at D (and the angle measurement is in degrees and not in radians).
interior_angle_of_A + interior_angle_of_B + interior_angle_of_C + interior_angle_of_D = 360.000304079248280686442740261554718017578125. // sum of all four approximate interior angle measurements of the quadrilateral represented by the caller QUADRILATERAL object (in degrees and not in radians)
get_perimeter() = a + b + c + d = 4. // The method returns the sum of the four approximated side lengths of the rectangle which the caller RECTANGLE object represents.
get_area() = 0.999999999999999555910790149937383830547332763671875. // The method returns the approximate nonnegative real number of Cartesian grid unit squares which are enclosed inside of the two-dimensional region formed by the four line segments which connect points A to B, B to C, C to D, and D to A.
--------------------------------------------------------------------------------------------------

--------------------------------------------------------------------------------------------------
this = 0x7ffe7c17e620. // The keyword named this is a pointer which stores the memory address of the first memory cell of a QUADRILATERAL sized chunk of contiguous memory cells which are allocated to the caller TRIANGLE object.
&amp;category = 0x7ffe7c17e6a8. // The reference operation returns the memory address of the first memory cell of a string sized chunk of contiguous memory cells which are allocated to the string data attribute named category.
&amp;color = 0x7ffe7c17e648. // The reference operation returns the memory address of the first memory cell of a string sized chunk of contiguous memory cells which are allocated to the string data attribute named color..
&amp;A = 0x7ffe7c17e688. // The reference operation returns the memory address of the first memory cell of a POINT sized chunk of contiguous memory cells which are allocated to the POINT data attribute named A.
&amp;B = 0x7ffe7c17e690. // The reference operation returns the memory address of the first memory cell of a POINT sized chunk of contiguous memory cells which are allocated to the POINT data attribute named B.
&amp;C = 0x7ffe7c17e698. // The reference operation returns the memory address of the first memory cell of a POINT sized chunk of contiguous memory cells which are allocated to the POINT data attribute named C.
&amp;D = 0x7ffe7c17e6a0. // The reference operation returns the memory address of the first memory cell of a POINT sized chunk of contiguous memory cells which are allocated to the POINT data attribute named D.
sizeof(int) = 4. // The sizeof() operation returns the nonnegative integer number of bytes of memory which an int type variable occupies. (Each memory cell has a data capacity of 1 byte).
sizeof(int *) = 8. // The sizeof() operation returns the nonnegative integer number of bytes of memory which a pointer-to-int type variable occupies. (Each memory cell has a data capacity of 1 byte).
sizeof(int **) = 8. // The sizeof() operation returns the nonnegative integer number of bytes of memory which an pointer-to-pointer-to-int type variable occupies. (Each memory cell has a data capacity of 1 byte).
sizeof(std::string) = 32. // The sizeof() operation returns the nonnegative integer number of bytes of memory which a string type variable occupies. (Each memory cell has a data capacity of 1 byte).
sizeof(std::string *) = 8. // The sizeof() operation returns the nonnegative integer number of bytes of memory which a pointer-to-string type variable occupies. (Each memory cell has a data capacity of 1 byte).
sizeof(std::string **) = 8. // The sizeof() operation returns the nonnegative integer number of bytes of memory which a pointer-to-pointer-to-string type variable occupies. (Each memory cell has a data capacity of 1 byte).
sizeof(POINT) = 8. // The sizeof() operation returns the nonnegative integer number of bytes of memory which a POINT type object occupies. (Each memory cell has a data capacity of 1 byte).
sizeof(POINT *) = 8. // The sizeof() operation returns the nonnegative integer number of bytes of memory which a pointer-to-POINT type variable occupies. (Each memory cell has a data capacity of 1 byte).
sizeof(POINT **) = 8. // The sizeof() operation returns the nonnegative integer number of bytes of memory which a pointer-to-pointer-to-POINT type variable occupies. (Each memory cell has a data capacity of 1 byte).
sizeof(POLYGON) = 72. // The sizeof() operation returns the nonnegative integer number of bytes of memory which a POLYGON type object occupies. (Each memory cell has a data capacity of 1 byte).
sizeof(POLYGON *) = 8. // The sizeof() operation returns the nonnegative integer number of bytes of memory which a pointer-to-POLYGON type variable occupies. (Each memory cell has a data capacity of 1 byte).
sizeof(POLYGON **) = 8. // The sizeof() operation returns the nonnegative integer number of bytes of memory which a pointer-to-pointer-to-POLYGON type variable occupies. (Each memory cell has a data capacity of 1 byte).
sizeof(QUADRILATERAL) = 136. // The sizeof() operation returns the nonnegative integer number of bytes of memory which a QUADRILATERAL type object occupies. (Each memory cell has a data capacity of 1 byte).
sizeof(QUADRILATERAL *) = 8. // The sizeof() operation returns the nonnegative integer number of bytes of memory which a pointer-to-QUADRILATERAL type variable occupies. (Each memory cell has a data capacity of 1 byte).
sizeof(QUADRILATERAL **) = 8. // The sizeof() operation returns the nonnegative integer number of bytes of memory which a pointer-to-pointer-to-QUADRILATERAL type variable occupies. (Each memory cell has a data capacity of 1 byte).
sizeof(RECTANGLE) = 168. // The sizeof() operation returns the nonnegative integer number of bytes of memory which a RECTANGLE type object occupies. (Each memory cell has a data capacity of 1 byte).
sizeof(RECTANGLE *) = 8. // The sizeof() operation returns the nonnegative integer number of bytes of memory which a pointer-to-RECTANGLE type variable occupies. (Each memory cell has a data capacity of 1 byte).
sizeof(RECTANGLE **) = 8. // The sizeof() operation returns the nonnegative integer number of bytes of memory which a pointer-to-pointer-to-RECTANGLE type variable occupies. (Each memory cell has a data capacity of 1 byte).
category = POLYGON/QUADRILATERAL/RECTANGLE. // This is an immutable string type value which is a data member of the caller RECTANGLE object.
color = gray. // This is a string type value which is a data member of the caller RECTANGLE object.
A = POINT(9,10). // A represents a point (which is neither B nor C nor D) plotted on a two-dimensional Cartesian grid (such that the X value represents a real whole number position along the horizontal axis of the Cartesian grid while Y represents a real whole number position along the vertical axis of the same Cartesian grid).
B = POINT(9,5). // B represents a point (which is neither A nor C nor D) plotted on a two-dimensional Cartesian grid (such that the X value represents a real whole number position along the horizontal axis of the Cartesian grid while Y represents a real whole number position along the vertical axis of the same Cartesian grid).
C = POINT(3,5). // C represents a point (which is neither A nor B nor D) plotted on a two-dimensional Cartesian grid (such that the X value represents a real whole number position along the horizontal axis of the Cartesian grid while Y represents a real whole number position along the vertical axis of the same Cartesian grid).
D = POINT(3,10). // D represents a point (which is neither A nor B nor C) plotted on a two-dimensional Cartesian grid (such that the X value represents a real whole number position along the horizontal axis of the Cartesian grid while Y represents a real whole number position along the vertical axis of the same Cartesian grid).
a = B.get_distance_from(C) = 6. // The method returns the approximate nonnegative real number of Cartesian grid unit lengths which span the length of the shortest path between points B and C.
b = C.get_distance_from(D) = 5. // The method returns the approximate nonnegative real number of Cartesian grid unit lengths which span the length of the shortest path between points C and D.
c = D.get_distance_from(A) = 6. // The method returns the approximate nonnegative real number of Cartesian grid unit lengths which span the length of the shortest path between points D and A.
d = A.get_distance_from(B) = 5. // The method returns the approximate nonnegative real number of Cartesian grid unit lengths which span the length of the shortest path between points A and B.
A.get_slope_of_line_to(B) = -inf. // The method returns the approximate nonnegative real number which represents the slope of the line which intersects points A and B.
B.get_slope_of_line_to(C) = 0. // The method returns the approximate nonnegative real number which represents the slope of the line which intersects points B and C.
C.get_slope_of_line_to(D) = inf. // The method returns the approximate nonnegative real number which represents the slope of the line which intersects points C and D.
D.get_slope_of_line_to(A) = 0. // The method returns the approximate nonnegative real number which represents the slope of the line which intersects points B and C.
interior_angle_DAB = interior_angle_of_A = 90.00007601981207017161068506538867950439453125. // The value represents the approximate nonnegative real number angle measurement of the acute or else right angle formed by the intersection of the line segment whose endpoints are D and A with the line segment whose endpoints are A and B such that those two line segments intersect at A (and the angle measurement is in degrees and not in radians).
interior_angle_ABC = interior_angle_of_B = 90.0000760198120559607559698633849620819091796875. // The method returns the approximate nonnegative real number angle measurement of the acute or else right angle formed by the intersection of the line segment whose endpoints are A and B with the line segment whose endpoints are B and C such that those two line segments intersect at B (and the angle measurement is in degrees and not in radians).
interior_angle_BCD = interior_angle_of_C = 90.00007601981207017161068506538867950439453125. // The method returns the approximate nonnegative real number angle measurement of the acute or else right angle formed by the intersection of the line segment whose endpoints are B and C with the line segment whose endpoints are C and D such that those two line segments intersect at C (and the angle measurement is in degrees and not in radians).
interior_angle_CDA = interior_angle_of_D = 90.0000760198120559607559698633849620819091796875. // The method returns the approximate nonnegative real number angle measurement of the acute or else right angle formed by the intersection of the line segment whose endpoints are C and D with the line segment whose endpoints are D and A such that those two line segments intersect at D (and the angle measurement is in degrees and not in radians).
interior_angle_of_A + interior_angle_of_B + interior_angle_of_C + interior_angle_of_D = 360.000304079248280686442740261554718017578125. // sum of all four approximate interior angle measurements of the quadrilateral represented by the caller QUADRILATERAL object (in degrees and not in radians)
get_perimeter() = a + b + c + d = 22. // The method returns the sum of the four approximated side lengths of the rectangle which the caller RECTANGLE object represents.
get_area() = 30. // The method returns the approximate nonnegative real number of Cartesian grid unit squares which are enclosed inside of the two-dimensional region formed by the four line segments which connect points A to B, B to C, C to D, and D to A.
--------------------------------------------------------------------------------------------------
--------------------------------------------------------------------------------------------------
Unit Test # 14: Test the normal RECTANGLE constructor using invalid function inputs and the RECTANGLE print method.
--------------------------------------------------------------------------------------------------
RECTANGLE rectangle_0 = RECTANGLE("red", POINT(-1,-1), POINT(0,0), POINT(1,1), POINT(2,2));
rectangle_0.print(output);
RECTANGLE rectangle_1 = RECTANGLE("green", POINT(-5,-10), POINT(0,5), POINT(15,5), POINT(30,-10));
rectangle_1.print(output);
RECTANGLE rectangle_2 = RECTANGLE("blue", POINT(-5,-5), POINT(0,0), POINT(-5,-5), POINT(0,0));
rectangle_2.print(output);
--------------------------------------------------------------------------------------------------

--------------------------------------------------------------------------------------------------
this = 0x7ffe7c17e4c0. // The keyword named this is a pointer which stores the memory address of the first memory cell of a QUADRILATERAL sized chunk of contiguous memory cells which are allocated to the caller TRIANGLE object.
&amp;category = 0x7ffe7c17e548. // The reference operation returns the memory address of the first memory cell of a string sized chunk of contiguous memory cells which are allocated to the string data attribute named category.
&amp;color = 0x7ffe7c17e4e8. // The reference operation returns the memory address of the first memory cell of a string sized chunk of contiguous memory cells which are allocated to the string data attribute named color..
&amp;A = 0x7ffe7c17e528. // The reference operation returns the memory address of the first memory cell of a POINT sized chunk of contiguous memory cells which are allocated to the POINT data attribute named A.
&amp;B = 0x7ffe7c17e530. // The reference operation returns the memory address of the first memory cell of a POINT sized chunk of contiguous memory cells which are allocated to the POINT data attribute named B.
&amp;C = 0x7ffe7c17e538. // The reference operation returns the memory address of the first memory cell of a POINT sized chunk of contiguous memory cells which are allocated to the POINT data attribute named C.
&amp;D = 0x7ffe7c17e540. // The reference operation returns the memory address of the first memory cell of a POINT sized chunk of contiguous memory cells which are allocated to the POINT data attribute named D.
sizeof(int) = 4. // The sizeof() operation returns the nonnegative integer number of bytes of memory which an int type variable occupies. (Each memory cell has a data capacity of 1 byte).
sizeof(int *) = 8. // The sizeof() operation returns the nonnegative integer number of bytes of memory which a pointer-to-int type variable occupies. (Each memory cell has a data capacity of 1 byte).
sizeof(int **) = 8. // The sizeof() operation returns the nonnegative integer number of bytes of memory which an pointer-to-pointer-to-int type variable occupies. (Each memory cell has a data capacity of 1 byte).
sizeof(std::string) = 32. // The sizeof() operation returns the nonnegative integer number of bytes of memory which a string type variable occupies. (Each memory cell has a data capacity of 1 byte).
sizeof(std::string *) = 8. // The sizeof() operation returns the nonnegative integer number of bytes of memory which a pointer-to-string type variable occupies. (Each memory cell has a data capacity of 1 byte).
sizeof(std::string **) = 8. // The sizeof() operation returns the nonnegative integer number of bytes of memory which a pointer-to-pointer-to-string type variable occupies. (Each memory cell has a data capacity of 1 byte).
sizeof(POINT) = 8. // The sizeof() operation returns the nonnegative integer number of bytes of memory which a POINT type object occupies. (Each memory cell has a data capacity of 1 byte).
sizeof(POINT *) = 8. // The sizeof() operation returns the nonnegative integer number of bytes of memory which a pointer-to-POINT type variable occupies. (Each memory cell has a data capacity of 1 byte).
sizeof(POINT **) = 8. // The sizeof() operation returns the nonnegative integer number of bytes of memory which a pointer-to-pointer-to-POINT type variable occupies. (Each memory cell has a data capacity of 1 byte).
sizeof(POLYGON) = 72. // The sizeof() operation returns the nonnegative integer number of bytes of memory which a POLYGON type object occupies. (Each memory cell has a data capacity of 1 byte).
sizeof(POLYGON *) = 8. // The sizeof() operation returns the nonnegative integer number of bytes of memory which a pointer-to-POLYGON type variable occupies. (Each memory cell has a data capacity of 1 byte).
sizeof(POLYGON **) = 8. // The sizeof() operation returns the nonnegative integer number of bytes of memory which a pointer-to-pointer-to-POLYGON type variable occupies. (Each memory cell has a data capacity of 1 byte).
sizeof(QUADRILATERAL) = 136. // The sizeof() operation returns the nonnegative integer number of bytes of memory which a QUADRILATERAL type object occupies. (Each memory cell has a data capacity of 1 byte).
sizeof(QUADRILATERAL *) = 8. // The sizeof() operation returns the nonnegative integer number of bytes of memory which a pointer-to-QUADRILATERAL type variable occupies. (Each memory cell has a data capacity of 1 byte).
sizeof(QUADRILATERAL **) = 8. // The sizeof() operation returns the nonnegative integer number of bytes of memory which a pointer-to-pointer-to-QUADRILATERAL type variable occupies. (Each memory cell has a data capacity of 1 byte).
sizeof(RECTANGLE) = 168. // The sizeof() operation returns the nonnegative integer number of bytes of memory which a RECTANGLE type object occupies. (Each memory cell has a data capacity of 1 byte).
sizeof(RECTANGLE *) = 8. // The sizeof() operation returns the nonnegative integer number of bytes of memory which a pointer-to-RECTANGLE type variable occupies. (Each memory cell has a data capacity of 1 byte).
sizeof(RECTANGLE **) = 8. // The sizeof() operation returns the nonnegative integer number of bytes of memory which a pointer-to-pointer-to-RECTANGLE type variable occupies. (Each memory cell has a data capacity of 1 byte).
category = POLYGON/QUADRILATERAL/RECTANGLE. // This is an immutable string type value which is a data member of the caller RECTANGLE object.
color = red. // This is a string type value which is a data member of the caller RECTANGLE object.
A = POINT(0,0). // A represents a point (which is neither B nor C nor D) plotted on a two-dimensional Cartesian grid (such that the X value represents a real whole number position along the horizontal axis of the Cartesian grid while Y represents a real whole number position along the vertical axis of the same Cartesian grid).
B = POINT(0,3). // B represents a point (which is neither A nor C nor D) plotted on a two-dimensional Cartesian grid (such that the X value represents a real whole number position along the horizontal axis of the Cartesian grid while Y represents a real whole number position along the vertical axis of the same Cartesian grid).
C = POINT(4,3). // C represents a point (which is neither A nor B nor D) plotted on a two-dimensional Cartesian grid (such that the X value represents a real whole number position along the horizontal axis of the Cartesian grid while Y represents a real whole number position along the vertical axis of the same Cartesian grid).
D = POINT(4,0). // D represents a point (which is neither A nor B nor C) plotted on a two-dimensional Cartesian grid (such that the X value represents a real whole number position along the horizontal axis of the Cartesian grid while Y represents a real whole number position along the vertical axis of the same Cartesian grid).
a = B.get_distance_from(C) = 4. // The method returns the approximate nonnegative real number of Cartesian grid unit lengths which span the length of the shortest path between points B and C.
b = C.get_distance_from(D) = 3. // The method returns the approximate nonnegative real number of Cartesian grid unit lengths which span the length of the shortest path between points C and D.
c = D.get_distance_from(A) = 4. // The method returns the approximate nonnegative real number of Cartesian grid unit lengths which span the length of the shortest path between points D and A.
d = A.get_distance_from(B) = 3. // The method returns the approximate nonnegative real number of Cartesian grid unit lengths which span the length of the shortest path between points A and B.
A.get_slope_of_line_to(B) = inf. // The method returns the approximate nonnegative real number which represents the slope of the line which intersects points A and B.
B.get_slope_of_line_to(C) = 0. // The method returns the approximate nonnegative real number which represents the slope of the line which intersects points B and C.
C.get_slope_of_line_to(D) = -inf. // The method returns the approximate nonnegative real number which represents the slope of the line which intersects points C and D.
D.get_slope_of_line_to(A) = 0. // The method returns the approximate nonnegative real number which represents the slope of the line which intersects points B and C.
interior_angle_DAB = interior_angle_of_A = 90.00007601981207017161068506538867950439453125. // The value represents the approximate nonnegative real number angle measurement of the acute or else right angle formed by the intersection of the line segment whose endpoints are D and A with the line segment whose endpoints are A and B such that those two line segments intersect at A (and the angle measurement is in degrees and not in radians).
interior_angle_ABC = interior_angle_of_B = 90.00007601981207017161068506538867950439453125. // The method returns the approximate nonnegative real number angle measurement of the acute or else right angle formed by the intersection of the line segment whose endpoints are A and B with the line segment whose endpoints are B and C such that those two line segments intersect at B (and the angle measurement is in degrees and not in radians).
interior_angle_BCD = interior_angle_of_C = 90.00007601981207017161068506538867950439453125. // The method returns the approximate nonnegative real number angle measurement of the acute or else right angle formed by the intersection of the line segment whose endpoints are B and C with the line segment whose endpoints are C and D such that those two line segments intersect at C (and the angle measurement is in degrees and not in radians).
interior_angle_CDA = interior_angle_of_D = 90.00007601981207017161068506538867950439453125. // The method returns the approximate nonnegative real number angle measurement of the acute or else right angle formed by the intersection of the line segment whose endpoints are C and D with the line segment whose endpoints are D and A such that those two line segments intersect at D (and the angle measurement is in degrees and not in radians).
interior_angle_of_A + interior_angle_of_B + interior_angle_of_C + interior_angle_of_D = 360.000304079248280686442740261554718017578125. // sum of all four approximate interior angle measurements of the quadrilateral represented by the caller QUADRILATERAL object (in degrees and not in radians)
get_perimeter() = a + b + c + d = 14. // The method returns the sum of the four approximated side lengths of the rectangle which the caller RECTANGLE object represents.
get_area() = 12. // The method returns the approximate nonnegative real number of Cartesian grid unit squares which are enclosed inside of the two-dimensional region formed by the four line segments which connect points A to B, B to C, C to D, and D to A.
--------------------------------------------------------------------------------------------------

--------------------------------------------------------------------------------------------------
this = 0x7ffe7c17e570. // The keyword named this is a pointer which stores the memory address of the first memory cell of a QUADRILATERAL sized chunk of contiguous memory cells which are allocated to the caller TRIANGLE object.
&amp;category = 0x7ffe7c17e5f8. // The reference operation returns the memory address of the first memory cell of a string sized chunk of contiguous memory cells which are allocated to the string data attribute named category.
&amp;color = 0x7ffe7c17e598. // The reference operation returns the memory address of the first memory cell of a string sized chunk of contiguous memory cells which are allocated to the string data attribute named color..
&amp;A = 0x7ffe7c17e5d8. // The reference operation returns the memory address of the first memory cell of a POINT sized chunk of contiguous memory cells which are allocated to the POINT data attribute named A.
&amp;B = 0x7ffe7c17e5e0. // The reference operation returns the memory address of the first memory cell of a POINT sized chunk of contiguous memory cells which are allocated to the POINT data attribute named B.
&amp;C = 0x7ffe7c17e5e8. // The reference operation returns the memory address of the first memory cell of a POINT sized chunk of contiguous memory cells which are allocated to the POINT data attribute named C.
&amp;D = 0x7ffe7c17e5f0. // The reference operation returns the memory address of the first memory cell of a POINT sized chunk of contiguous memory cells which are allocated to the POINT data attribute named D.
sizeof(int) = 4. // The sizeof() operation returns the nonnegative integer number of bytes of memory which an int type variable occupies. (Each memory cell has a data capacity of 1 byte).
sizeof(int *) = 8. // The sizeof() operation returns the nonnegative integer number of bytes of memory which a pointer-to-int type variable occupies. (Each memory cell has a data capacity of 1 byte).
sizeof(int **) = 8. // The sizeof() operation returns the nonnegative integer number of bytes of memory which an pointer-to-pointer-to-int type variable occupies. (Each memory cell has a data capacity of 1 byte).
sizeof(std::string) = 32. // The sizeof() operation returns the nonnegative integer number of bytes of memory which a string type variable occupies. (Each memory cell has a data capacity of 1 byte).
sizeof(std::string *) = 8. // The sizeof() operation returns the nonnegative integer number of bytes of memory which a pointer-to-string type variable occupies. (Each memory cell has a data capacity of 1 byte).
sizeof(std::string **) = 8. // The sizeof() operation returns the nonnegative integer number of bytes of memory which a pointer-to-pointer-to-string type variable occupies. (Each memory cell has a data capacity of 1 byte).
sizeof(POINT) = 8. // The sizeof() operation returns the nonnegative integer number of bytes of memory which a POINT type object occupies. (Each memory cell has a data capacity of 1 byte).
sizeof(POINT *) = 8. // The sizeof() operation returns the nonnegative integer number of bytes of memory which a pointer-to-POINT type variable occupies. (Each memory cell has a data capacity of 1 byte).
sizeof(POINT **) = 8. // The sizeof() operation returns the nonnegative integer number of bytes of memory which a pointer-to-pointer-to-POINT type variable occupies. (Each memory cell has a data capacity of 1 byte).
sizeof(POLYGON) = 72. // The sizeof() operation returns the nonnegative integer number of bytes of memory which a POLYGON type object occupies. (Each memory cell has a data capacity of 1 byte).
sizeof(POLYGON *) = 8. // The sizeof() operation returns the nonnegative integer number of bytes of memory which a pointer-to-POLYGON type variable occupies. (Each memory cell has a data capacity of 1 byte).
sizeof(POLYGON **) = 8. // The sizeof() operation returns the nonnegative integer number of bytes of memory which a pointer-to-pointer-to-POLYGON type variable occupies. (Each memory cell has a data capacity of 1 byte).
sizeof(QUADRILATERAL) = 136. // The sizeof() operation returns the nonnegative integer number of bytes of memory which a QUADRILATERAL type object occupies. (Each memory cell has a data capacity of 1 byte).
sizeof(QUADRILATERAL *) = 8. // The sizeof() operation returns the nonnegative integer number of bytes of memory which a pointer-to-QUADRILATERAL type variable occupies. (Each memory cell has a data capacity of 1 byte).
sizeof(QUADRILATERAL **) = 8. // The sizeof() operation returns the nonnegative integer number of bytes of memory which a pointer-to-pointer-to-QUADRILATERAL type variable occupies. (Each memory cell has a data capacity of 1 byte).
sizeof(RECTANGLE) = 168. // The sizeof() operation returns the nonnegative integer number of bytes of memory which a RECTANGLE type object occupies. (Each memory cell has a data capacity of 1 byte).
sizeof(RECTANGLE *) = 8. // The sizeof() operation returns the nonnegative integer number of bytes of memory which a pointer-to-RECTANGLE type variable occupies. (Each memory cell has a data capacity of 1 byte).
sizeof(RECTANGLE **) = 8. // The sizeof() operation returns the nonnegative integer number of bytes of memory which a pointer-to-pointer-to-RECTANGLE type variable occupies. (Each memory cell has a data capacity of 1 byte).
category = POLYGON/QUADRILATERAL/RECTANGLE. // This is an immutable string type value which is a data member of the caller RECTANGLE object.
color = green. // This is a string type value which is a data member of the caller RECTANGLE object.
A = POINT(0,0). // A represents a point (which is neither B nor C nor D) plotted on a two-dimensional Cartesian grid (such that the X value represents a real whole number position along the horizontal axis of the Cartesian grid while Y represents a real whole number position along the vertical axis of the same Cartesian grid).
B = POINT(0,3). // B represents a point (which is neither A nor C nor D) plotted on a two-dimensional Cartesian grid (such that the X value represents a real whole number position along the horizontal axis of the Cartesian grid while Y represents a real whole number position along the vertical axis of the same Cartesian grid).
C = POINT(4,3). // C represents a point (which is neither A nor B nor D) plotted on a two-dimensional Cartesian grid (such that the X value represents a real whole number position along the horizontal axis of the Cartesian grid while Y represents a real whole number position along the vertical axis of the same Cartesian grid).
D = POINT(4,0). // D represents a point (which is neither A nor B nor C) plotted on a two-dimensional Cartesian grid (such that the X value represents a real whole number position along the horizontal axis of the Cartesian grid while Y represents a real whole number position along the vertical axis of the same Cartesian grid).
a = B.get_distance_from(C) = 4. // The method returns the approximate nonnegative real number of Cartesian grid unit lengths which span the length of the shortest path between points B and C.
b = C.get_distance_from(D) = 3. // The method returns the approximate nonnegative real number of Cartesian grid unit lengths which span the length of the shortest path between points C and D.
c = D.get_distance_from(A) = 4. // The method returns the approximate nonnegative real number of Cartesian grid unit lengths which span the length of the shortest path between points D and A.
d = A.get_distance_from(B) = 3. // The method returns the approximate nonnegative real number of Cartesian grid unit lengths which span the length of the shortest path between points A and B.
A.get_slope_of_line_to(B) = inf. // The method returns the approximate nonnegative real number which represents the slope of the line which intersects points A and B.
B.get_slope_of_line_to(C) = 0. // The method returns the approximate nonnegative real number which represents the slope of the line which intersects points B and C.
C.get_slope_of_line_to(D) = -inf. // The method returns the approximate nonnegative real number which represents the slope of the line which intersects points C and D.
D.get_slope_of_line_to(A) = 0. // The method returns the approximate nonnegative real number which represents the slope of the line which intersects points B and C.
interior_angle_DAB = interior_angle_of_A = 90.00007601981207017161068506538867950439453125. // The value represents the approximate nonnegative real number angle measurement of the acute or else right angle formed by the intersection of the line segment whose endpoints are D and A with the line segment whose endpoints are A and B such that those two line segments intersect at A (and the angle measurement is in degrees and not in radians).
interior_angle_ABC = interior_angle_of_B = 90.00007601981207017161068506538867950439453125. // The method returns the approximate nonnegative real number angle measurement of the acute or else right angle formed by the intersection of the line segment whose endpoints are A and B with the line segment whose endpoints are B and C such that those two line segments intersect at B (and the angle measurement is in degrees and not in radians).
interior_angle_BCD = interior_angle_of_C = 90.00007601981207017161068506538867950439453125. // The method returns the approximate nonnegative real number angle measurement of the acute or else right angle formed by the intersection of the line segment whose endpoints are B and C with the line segment whose endpoints are C and D such that those two line segments intersect at C (and the angle measurement is in degrees and not in radians).
interior_angle_CDA = interior_angle_of_D = 90.00007601981207017161068506538867950439453125. // The method returns the approximate nonnegative real number angle measurement of the acute or else right angle formed by the intersection of the line segment whose endpoints are C and D with the line segment whose endpoints are D and A such that those two line segments intersect at D (and the angle measurement is in degrees and not in radians).
interior_angle_of_A + interior_angle_of_B + interior_angle_of_C + interior_angle_of_D = 360.000304079248280686442740261554718017578125. // sum of all four approximate interior angle measurements of the quadrilateral represented by the caller QUADRILATERAL object (in degrees and not in radians)
get_perimeter() = a + b + c + d = 14. // The method returns the sum of the four approximated side lengths of the rectangle which the caller RECTANGLE object represents.
get_area() = 12. // The method returns the approximate nonnegative real number of Cartesian grid unit squares which are enclosed inside of the two-dimensional region formed by the four line segments which connect points A to B, B to C, C to D, and D to A.
--------------------------------------------------------------------------------------------------

--------------------------------------------------------------------------------------------------
this = 0x7ffe7c17e620. // The keyword named this is a pointer which stores the memory address of the first memory cell of a QUADRILATERAL sized chunk of contiguous memory cells which are allocated to the caller TRIANGLE object.
&amp;category = 0x7ffe7c17e6a8. // The reference operation returns the memory address of the first memory cell of a string sized chunk of contiguous memory cells which are allocated to the string data attribute named category.
&amp;color = 0x7ffe7c17e648. // The reference operation returns the memory address of the first memory cell of a string sized chunk of contiguous memory cells which are allocated to the string data attribute named color..
&amp;A = 0x7ffe7c17e688. // The reference operation returns the memory address of the first memory cell of a POINT sized chunk of contiguous memory cells which are allocated to the POINT data attribute named A.
&amp;B = 0x7ffe7c17e690. // The reference operation returns the memory address of the first memory cell of a POINT sized chunk of contiguous memory cells which are allocated to the POINT data attribute named B.
&amp;C = 0x7ffe7c17e698. // The reference operation returns the memory address of the first memory cell of a POINT sized chunk of contiguous memory cells which are allocated to the POINT data attribute named C.
&amp;D = 0x7ffe7c17e6a0. // The reference operation returns the memory address of the first memory cell of a POINT sized chunk of contiguous memory cells which are allocated to the POINT data attribute named D.
sizeof(int) = 4. // The sizeof() operation returns the nonnegative integer number of bytes of memory which an int type variable occupies. (Each memory cell has a data capacity of 1 byte).
sizeof(int *) = 8. // The sizeof() operation returns the nonnegative integer number of bytes of memory which a pointer-to-int type variable occupies. (Each memory cell has a data capacity of 1 byte).
sizeof(int **) = 8. // The sizeof() operation returns the nonnegative integer number of bytes of memory which an pointer-to-pointer-to-int type variable occupies. (Each memory cell has a data capacity of 1 byte).
sizeof(std::string) = 32. // The sizeof() operation returns the nonnegative integer number of bytes of memory which a string type variable occupies. (Each memory cell has a data capacity of 1 byte).
sizeof(std::string *) = 8. // The sizeof() operation returns the nonnegative integer number of bytes of memory which a pointer-to-string type variable occupies. (Each memory cell has a data capacity of 1 byte).
sizeof(std::string **) = 8. // The sizeof() operation returns the nonnegative integer number of bytes of memory which a pointer-to-pointer-to-string type variable occupies. (Each memory cell has a data capacity of 1 byte).
sizeof(POINT) = 8. // The sizeof() operation returns the nonnegative integer number of bytes of memory which a POINT type object occupies. (Each memory cell has a data capacity of 1 byte).
sizeof(POINT *) = 8. // The sizeof() operation returns the nonnegative integer number of bytes of memory which a pointer-to-POINT type variable occupies. (Each memory cell has a data capacity of 1 byte).
sizeof(POINT **) = 8. // The sizeof() operation returns the nonnegative integer number of bytes of memory which a pointer-to-pointer-to-POINT type variable occupies. (Each memory cell has a data capacity of 1 byte).
sizeof(POLYGON) = 72. // The sizeof() operation returns the nonnegative integer number of bytes of memory which a POLYGON type object occupies. (Each memory cell has a data capacity of 1 byte).
sizeof(POLYGON *) = 8. // The sizeof() operation returns the nonnegative integer number of bytes of memory which a pointer-to-POLYGON type variable occupies. (Each memory cell has a data capacity of 1 byte).
sizeof(POLYGON **) = 8. // The sizeof() operation returns the nonnegative integer number of bytes of memory which a pointer-to-pointer-to-POLYGON type variable occupies. (Each memory cell has a data capacity of 1 byte).
sizeof(QUADRILATERAL) = 136. // The sizeof() operation returns the nonnegative integer number of bytes of memory which a QUADRILATERAL type object occupies. (Each memory cell has a data capacity of 1 byte).
sizeof(QUADRILATERAL *) = 8. // The sizeof() operation returns the nonnegative integer number of bytes of memory which a pointer-to-QUADRILATERAL type variable occupies. (Each memory cell has a data capacity of 1 byte).
sizeof(QUADRILATERAL **) = 8. // The sizeof() operation returns the nonnegative integer number of bytes of memory which a pointer-to-pointer-to-QUADRILATERAL type variable occupies. (Each memory cell has a data capacity of 1 byte).
sizeof(RECTANGLE) = 168. // The sizeof() operation returns the nonnegative integer number of bytes of memory which a RECTANGLE type object occupies. (Each memory cell has a data capacity of 1 byte).
sizeof(RECTANGLE *) = 8. // The sizeof() operation returns the nonnegative integer number of bytes of memory which a pointer-to-RECTANGLE type variable occupies. (Each memory cell has a data capacity of 1 byte).
sizeof(RECTANGLE **) = 8. // The sizeof() operation returns the nonnegative integer number of bytes of memory which a pointer-to-pointer-to-RECTANGLE type variable occupies. (Each memory cell has a data capacity of 1 byte).
category = POLYGON/QUADRILATERAL/RECTANGLE. // This is an immutable string type value which is a data member of the caller RECTANGLE object.
color = blue. // This is a string type value which is a data member of the caller RECTANGLE object.
A = POINT(0,0). // A represents a point (which is neither B nor C nor D) plotted on a two-dimensional Cartesian grid (such that the X value represents a real whole number position along the horizontal axis of the Cartesian grid while Y represents a real whole number position along the vertical axis of the same Cartesian grid).
B = POINT(0,3). // B represents a point (which is neither A nor C nor D) plotted on a two-dimensional Cartesian grid (such that the X value represents a real whole number position along the horizontal axis of the Cartesian grid while Y represents a real whole number position along the vertical axis of the same Cartesian grid).
C = POINT(4,3). // C represents a point (which is neither A nor B nor D) plotted on a two-dimensional Cartesian grid (such that the X value represents a real whole number position along the horizontal axis of the Cartesian grid while Y represents a real whole number position along the vertical axis of the same Cartesian grid).
D = POINT(4,0). // D represents a point (which is neither A nor B nor C) plotted on a two-dimensional Cartesian grid (such that the X value represents a real whole number position along the horizontal axis of the Cartesian grid while Y represents a real whole number position along the vertical axis of the same Cartesian grid).
a = B.get_distance_from(C) = 4. // The method returns the approximate nonnegative real number of Cartesian grid unit lengths which span the length of the shortest path between points B and C.
b = C.get_distance_from(D) = 3. // The method returns the approximate nonnegative real number of Cartesian grid unit lengths which span the length of the shortest path between points C and D.
c = D.get_distance_from(A) = 4. // The method returns the approximate nonnegative real number of Cartesian grid unit lengths which span the length of the shortest path between points D and A.
d = A.get_distance_from(B) = 3. // The method returns the approximate nonnegative real number of Cartesian grid unit lengths which span the length of the shortest path between points A and B.
A.get_slope_of_line_to(B) = inf. // The method returns the approximate nonnegative real number which represents the slope of the line which intersects points A and B.
B.get_slope_of_line_to(C) = 0. // The method returns the approximate nonnegative real number which represents the slope of the line which intersects points B and C.
C.get_slope_of_line_to(D) = -inf. // The method returns the approximate nonnegative real number which represents the slope of the line which intersects points C and D.
D.get_slope_of_line_to(A) = 0. // The method returns the approximate nonnegative real number which represents the slope of the line which intersects points B and C.
interior_angle_DAB = interior_angle_of_A = 90.00007601981207017161068506538867950439453125. // The value represents the approximate nonnegative real number angle measurement of the acute or else right angle formed by the intersection of the line segment whose endpoints are D and A with the line segment whose endpoints are A and B such that those two line segments intersect at A (and the angle measurement is in degrees and not in radians).
interior_angle_ABC = interior_angle_of_B = 90.00007601981207017161068506538867950439453125. // The method returns the approximate nonnegative real number angle measurement of the acute or else right angle formed by the intersection of the line segment whose endpoints are A and B with the line segment whose endpoints are B and C such that those two line segments intersect at B (and the angle measurement is in degrees and not in radians).
interior_angle_BCD = interior_angle_of_C = 90.00007601981207017161068506538867950439453125. // The method returns the approximate nonnegative real number angle measurement of the acute or else right angle formed by the intersection of the line segment whose endpoints are B and C with the line segment whose endpoints are C and D such that those two line segments intersect at C (and the angle measurement is in degrees and not in radians).
interior_angle_CDA = interior_angle_of_D = 90.00007601981207017161068506538867950439453125. // The method returns the approximate nonnegative real number angle measurement of the acute or else right angle formed by the intersection of the line segment whose endpoints are C and D with the line segment whose endpoints are D and A such that those two line segments intersect at D (and the angle measurement is in degrees and not in radians).
interior_angle_of_A + interior_angle_of_B + interior_angle_of_C + interior_angle_of_D = 360.000304079248280686442740261554718017578125. // sum of all four approximate interior angle measurements of the quadrilateral represented by the caller QUADRILATERAL object (in degrees and not in radians)
get_perimeter() = a + b + c + d = 14. // The method returns the sum of the four approximated side lengths of the rectangle which the caller RECTANGLE object represents.
get_area() = 12. // The method returns the approximate nonnegative real number of Cartesian grid unit squares which are enclosed inside of the two-dimensional region formed by the four line segments which connect points A to B, B to C, C to D, and D to A.
--------------------------------------------------------------------------------------------------

--------------------------------------------------------------------------------------------------
Unit Test # 15: Create a pointer-to-POLYGON type variable to store the memory address of a dynamically allocated SQUARE instance. Use that pointer-to-POLYGON type variable to call the print method of the POLYGON class and the getter methods of the POLYGON class.
--------------------------------------------------------------------------------------------------
// COMMENTED OUT: POLYGON polygon; // This command does not work because POLYGON is an abstract class.
POLYGON * pointer_to_polygon; // The pointer-to-POLYGON type variable can store the memory address of an object whose data type is a non-abstract derived class of POLYGON such as SQUARE.
pointer_to_polygon = new SQUARE; // Assign memory to a dynamic SQUARE instance (i.e. and dynamic implies that the variable was created during program runtime instead of program compile time).
pointer_to_polygon -&gt; print(output); // Indirectly call the POLYGON print method.

--------------------------------------------------------------------------------------------------
memory_address = 0x562bfd0089b0.
category = POLYGON.
color = orange.
&amp;category = 0x562bfd0089b8.
&amp;color = 0x562bfd0089d8.
--------------------------------------------------------------------------------------------------
pointer_to_polygon -&gt; get_area() = 25. // Indirectly call the POLYGON get_area() method.
pointer_to_polygon -&gt; get_perimeter() = 20. // Indirectly call the POLYGON get_permieter() method.
delete pointer_to_polygon; // De-allocate memory which was assigned to the dynamically allocated SQUARE instance.
--------------------------------------------------------------------------------------------------
--------------------------------------------------------------------------------------------------
Unit Test # 16: Test the default SQUARE constructor and the SQUARE print method.
--------------------------------------------------------------------------------------------------
SQUARE square;
square.print(); // Test the default argument (which is std::cout).
square.print(output);
output &lt; print(output); // Indirectly call the QUADRILATERAL print method.

--------------------------------------------------------------------------------------------------
this = 0x562bfd0089b0. // The keyword named this is a pointer which stores the memory address of the first memory cell of a QUADRILATERAL sized chunk of contiguous memory cells which are allocated to the caller TRIANGLE object.
&amp;category = 0x562bfd0089f8. // The reference operation returns the memory address of the first memory cell of a string sized chunk of contiguous memory cells which are allocated to the string data attribute named category.
&amp;color = 0x562bfd0089d8. // The reference operation returns the memory address of the first memory cell of a string sized chunk of contiguous memory cells which are allocated to the string data attribute named color..
&amp;A = 0x562bfd008a18. // The reference operation returns the memory address of the first memory cell of a POINT sized chunk of contiguous memory cells which are allocated to the POINT data attribute named A.
&amp;B = 0x562bfd008a20. // The reference operation returns the memory address of the first memory cell of a POINT sized chunk of contiguous memory cells which are allocated to the POINT data attribute named B.
&amp;C = 0x562bfd008a28. // The reference operation returns the memory address of the first memory cell of a POINT sized chunk of contiguous memory cells which are allocated to the POINT data attribute named C.
&amp;D = 0x562bfd008a30. // The reference operation returns the memory address of the first memory cell of a POINT sized chunk of contiguous memory cells which are allocated to the POINT data attribute named D.
sizeof(int) = 4. // The sizeof() operation returns the nonnegative integer number of bytes of memory which an int type variable occupies. (Each memory cell has a data capacity of 1 byte).
sizeof(int *) = 8. // The sizeof() operation returns the nonnegative integer number of bytes of memory which a pointer-to-int type variable occupies. (Each memory cell has a data capacity of 1 byte).
sizeof(int **) = 8. // The sizeof() operation returns the nonnegative integer number of bytes of memory which an pointer-to-pointer-to-int type variable occupies. (Each memory cell has a data capacity of 1 byte).
sizeof(std::string) = 32. // The sizeof() operation returns the nonnegative integer number of bytes of memory which a string type variable occupies. (Each memory cell has a data capacity of 1 byte).
sizeof(std::string *) = 8. // The sizeof() operation returns the nonnegative integer number of bytes of memory which a pointer-to-string type variable occupies. (Each memory cell has a data capacity of 1 byte).
sizeof(std::string **) = 8. // The sizeof() operation returns the nonnegative integer number of bytes of memory which a pointer-to-pointer-to-string type variable occupies. (Each memory cell has a data capacity of 1 byte).
sizeof(POINT) = 8. // The sizeof() operation returns the nonnegative integer number of bytes of memory which a POINT type object occupies. (Each memory cell has a data capacity of 1 byte).
sizeof(POINT *) = 8. // The sizeof() operation returns the nonnegative integer number of bytes of memory which a pointer-to-POINT type variable occupies. (Each memory cell has a data capacity of 1 byte).
sizeof(POINT **) = 8. // The sizeof() operation returns the nonnegative integer number of bytes of memory which a pointer-to-pointer-to-POINT type variable occupies. (Each memory cell has a data capacity of 1 byte).
sizeof(POLYGON) = 72. // The sizeof() operation returns the nonnegative integer number of bytes of memory which a POLYGON type object occupies. (Each memory cell has a data capacity of 1 byte).
sizeof(POLYGON *) = 8. // The sizeof() operation returns the nonnegative integer number of bytes of memory which a pointer-to-POLYGON type variable occupies. (Each memory cell has a data capacity of 1 byte).
sizeof(POLYGON **) = 8. // The sizeof() operation returns the nonnegative integer number of bytes of memory which a pointer-to-pointer-to-POLYGON type variable occupies. (Each memory cell has a data capacity of 1 byte).
sizeof(QUADRILATERAL) = 136. // The sizeof() operation returns the nonnegative integer number of bytes of memory which a QUADRILATERAL type object occupies. (Each memory cell has a data capacity of 1 byte).
sizeof(QUADRILATERAL *) = 8. // The sizeof() operation returns the nonnegative integer number of bytes of memory which a pointer-to-QUADRILATERAL type variable occupies. (Each memory cell has a data capacity of 1 byte).
sizeof(QUADRILATERAL **) = 8. // The sizeof() operation returns the nonnegative integer number of bytes of memory which a pointer-to-pointer-to-QUADRILATERAL type variable occupies. (Each memory cell has a data capacity of 1 byte).
category = POLYGON/QUADRILATERAL. // This is an immutable string type value which is a data member of the caller QUADRILATERAL object.
color = orange. // This is a string type value which is a data member of the caller QUADRILATERAL object.
A = POINT(0,0). // A represents a point (which is neither B nor C nor D) plotted on a two-dimensional Cartesian grid (such that the X value represents a real whole number position along the horizontal axis of the Cartesian grid while Y represents a real whole number position along the vertical axis of the same Cartesian grid).
B = POINT(0,5). // B represents a point (which is neither A nor C nor D) plotted on a two-dimensional Cartesian grid (such that the X value represents a real whole number position along the horizontal axis of the Cartesian grid while Y represents a real whole number position along the vertical axis of the same Cartesian grid).
C = POINT(5,5). // C represents a point (which is neither A nor B nor D) plotted on a two-dimensional Cartesian grid (such that the X value represents a real whole number position along the horizontal axis of the Cartesian grid while Y represents a real whole number position along the vertical axis of the same Cartesian grid).
D = POINT(5,0). // D represents a point (which is neither A nor B nor C) plotted on a two-dimensional Cartesian grid (such that the X value represents a real whole number position along the horizontal axis of the Cartesian grid while Y represents a real whole number position along the vertical axis of the same Cartesian grid).
a = B.get_distance_from(C) = 5. // The method returns the approximate nonnegative real number of Cartesian grid unit lengths which span the length of the shortest path between points B and C.
b = C.get_distance_from(D) = 5. // The method returns the approximate nonnegative real number of Cartesian grid unit lengths which span the length of the shortest path between points C and D.
c = D.get_distance_from(A) = 5. // The method returns the approximate nonnegative real number of Cartesian grid unit lengths which span the length of the shortest path between points D and A.
d = A.get_distance_from(B) = 5. // The method returns the approximate nonnegative real number of Cartesian grid unit lengths which span the length of the shortest path between points A and B.
A.get_slope_of_line_to(B) = inf. // The method returns the approximate nonnegative real number which represents the slope of the line which intersects points A and B.
B.get_slope_of_line_to(C) = 0. // The method returns the approximate nonnegative real number which represents the slope of the line which intersects points B and C.
C.get_slope_of_line_to(D) = -inf. // The method returns the approximate nonnegative real number which represents the slope of the line which intersects points C and D.
D.get_slope_of_line_to(A) = 0. // The method returns the approximate nonnegative real number which represents the slope of the line which intersects points B and C.
interior_angle_DAB = interior_angle_of_A = 90.0000760198120843824654002673923969268798828125. // The value represents the approximate nonnegative real number angle measurement of the acute or else right angle formed by the intersection of the line segment whose endpoints are D and A with the line segment whose endpoints are A and B such that those two line segments intersect at A (and the angle measurement is in degrees and not in radians).
interior_angle_ABC = interior_angle_of_B = 90.0000760198120843824654002673923969268798828125. // The method returns the approximate nonnegative real number angle measurement of the acute or else right angle formed by the intersection of the line segment whose endpoints are A and B with the line segment whose endpoints are B and C such that those two line segments intersect at B (and the angle measurement is in degrees and not in radians).
interior_angle_BCD = interior_angle_of_C = 90.0000760198120843824654002673923969268798828125. // The method returns the approximate nonnegative real number angle measurement of the acute or else right angle formed by the intersection of the line segment whose endpoints are B and C with the line segment whose endpoints are C and D such that those two line segments intersect at C (and the angle measurement is in degrees and not in radians).
interior_angle_CDA = interior_angle_of_D = 90.0000760198120843824654002673923969268798828125. // The method returns the approximate nonnegative real number angle measurement of the acute or else right angle formed by the intersection of the line segment whose endpoints are C and D with the line segment whose endpoints are D and A such that those two line segments intersect at D (and the angle measurement is in degrees and not in radians).
interior_angle_of_A + interior_angle_of_B + interior_angle_of_C + interior_angle_of_D = 360.00030407924833752986160106956958770751953125. // sum of all four approximate interior angle measurements of the quadrilateral represented by the caller QUADRILATERAL object (in degrees and not in radians)
get_perimeter() = a + b + c + d = 20. // The method returns the sum of the four approximated side lengths of the quadrilateral which the caller QUADRILATERAL object represents.
get_area() = 25. // The method returns the approximate nonnegative real number of Cartesian grid unit squares which are enclosed inside of the two-dimensional region formed by the four line segments which connect points A to B, B to C, C to D, and D to A.
--------------------------------------------------------------------------------------------------
pointer_to_quadrilateral -&gt; get_area() = 25. // Indirectly call the QUADRILATERAL get_area() method.
pointer_to_quadrilateral -&gt; get_perimeter() = 20. // Indirectly call the QUADRILATERAL get_permieter() method.
delete pointer_to_quadrilateral; // De-allocate memory which was assigned to the dynamically allocated SQUARE instance.
--------------------------------------------------------------------------------------------------

--------------------------------------------------------------------------------------------------
Unit Test # 18: Create a pointer-to-RECTANGLE type variable to store the memory address of a dynamically allocated SQUARE instance. Use that pointer-to-RECTANGLE type variable to call the RECTANGLE print method and the RECTANGLE getter methods.
--------------------------------------------------------------------------------------------------
RECTANGLE * pointer_to_rectangle; // The pointer-to-RECTANGLE type variable can store the memory address of an object whose data type is a non-abstract derived class of RECTANGLE such as SQUARE.
pointer_to_rectangle = new SQUARE; // Assign memory to a dynamic SQUARE instance (i.e. and dynamic implies that the variable was created during program runtime instead of program compile time).
pointer_to_rectangle -&gt; print(output); // Indirectly call the RECTANGLE print method.

--------------------------------------------------------------------------------------------------
this = 0x562bfd0089b0. // The keyword named this is a pointer which stores the memory address of the first memory cell of a QUADRILATERAL sized chunk of contiguous memory cells which are allocated to the caller TRIANGLE object.
&amp;category = 0x562bfd008a38. // The reference operation returns the memory address of the first memory cell of a string sized chunk of contiguous memory cells which are allocated to the string data attribute named category.
&amp;color = 0x562bfd0089d8. // The reference operation returns the memory address of the first memory cell of a string sized chunk of contiguous memory cells which are allocated to the string data attribute named color..
&amp;A = 0x562bfd008a18. // The reference operation returns the memory address of the first memory cell of a POINT sized chunk of contiguous memory cells which are allocated to the POINT data attribute named A.
&amp;B = 0x562bfd008a20. // The reference operation returns the memory address of the first memory cell of a POINT sized chunk of contiguous memory cells which are allocated to the POINT data attribute named B.
&amp;C = 0x562bfd008a28. // The reference operation returns the memory address of the first memory cell of a POINT sized chunk of contiguous memory cells which are allocated to the POINT data attribute named C.
&amp;D = 0x562bfd008a30. // The reference operation returns the memory address of the first memory cell of a POINT sized chunk of contiguous memory cells which are allocated to the POINT data attribute named D.
sizeof(int) = 4. // The sizeof() operation returns the nonnegative integer number of bytes of memory which an int type variable occupies. (Each memory cell has a data capacity of 1 byte).
sizeof(int *) = 8. // The sizeof() operation returns the nonnegative integer number of bytes of memory which a pointer-to-int type variable occupies. (Each memory cell has a data capacity of 1 byte).
sizeof(int **) = 8. // The sizeof() operation returns the nonnegative integer number of bytes of memory which an pointer-to-pointer-to-int type variable occupies. (Each memory cell has a data capacity of 1 byte).
sizeof(std::string) = 32. // The sizeof() operation returns the nonnegative integer number of bytes of memory which a string type variable occupies. (Each memory cell has a data capacity of 1 byte).
sizeof(std::string *) = 8. // The sizeof() operation returns the nonnegative integer number of bytes of memory which a pointer-to-string type variable occupies. (Each memory cell has a data capacity of 1 byte).
sizeof(std::string **) = 8. // The sizeof() operation returns the nonnegative integer number of bytes of memory which a pointer-to-pointer-to-string type variable occupies. (Each memory cell has a data capacity of 1 byte).
sizeof(POINT) = 8. // The sizeof() operation returns the nonnegative integer number of bytes of memory which a POINT type object occupies. (Each memory cell has a data capacity of 1 byte).
sizeof(POINT *) = 8. // The sizeof() operation returns the nonnegative integer number of bytes of memory which a pointer-to-POINT type variable occupies. (Each memory cell has a data capacity of 1 byte).
sizeof(POINT **) = 8. // The sizeof() operation returns the nonnegative integer number of bytes of memory which a pointer-to-pointer-to-POINT type variable occupies. (Each memory cell has a data capacity of 1 byte).
sizeof(POLYGON) = 72. // The sizeof() operation returns the nonnegative integer number of bytes of memory which a POLYGON type object occupies. (Each memory cell has a data capacity of 1 byte).
sizeof(POLYGON *) = 8. // The sizeof() operation returns the nonnegative integer number of bytes of memory which a pointer-to-POLYGON type variable occupies. (Each memory cell has a data capacity of 1 byte).
sizeof(POLYGON **) = 8. // The sizeof() operation returns the nonnegative integer number of bytes of memory which a pointer-to-pointer-to-POLYGON type variable occupies. (Each memory cell has a data capacity of 1 byte).
sizeof(QUADRILATERAL) = 136. // The sizeof() operation returns the nonnegative integer number of bytes of memory which a QUADRILATERAL type object occupies. (Each memory cell has a data capacity of 1 byte).
sizeof(QUADRILATERAL *) = 8. // The sizeof() operation returns the nonnegative integer number of bytes of memory which a pointer-to-QUADRILATERAL type variable occupies. (Each memory cell has a data capacity of 1 byte).
sizeof(QUADRILATERAL **) = 8. // The sizeof() operation returns the nonnegative integer number of bytes of memory which a pointer-to-pointer-to-QUADRILATERAL type variable occupies. (Each memory cell has a data capacity of 1 byte).
sizeof(RECTANGLE) = 168. // The sizeof() operation returns the nonnegative integer number of bytes of memory which a RECTANGLE type object occupies. (Each memory cell has a data capacity of 1 byte).
sizeof(RECTANGLE *) = 8. // The sizeof() operation returns the nonnegative integer number of bytes of memory which a pointer-to-RECTANGLE type variable occupies. (Each memory cell has a data capacity of 1 byte).
sizeof(RECTANGLE **) = 8. // The sizeof() operation returns the nonnegative integer number of bytes of memory which a pointer-to-pointer-to-RECTANGLE type variable occupies. (Each memory cell has a data capacity of 1 byte).
category = POLYGON/QUADRILATERAL/RECTANGLE. // This is an immutable string type value which is a data member of the caller RECTANGLE object.
color = orange. // This is a string type value which is a data member of the caller RECTANGLE object.
A = POINT(0,0). // A represents a point (which is neither B nor C nor D) plotted on a two-dimensional Cartesian grid (such that the X value represents a real whole number position along the horizontal axis of the Cartesian grid while Y represents a real whole number position along the vertical axis of the same Cartesian grid).
B = POINT(0,5). // B represents a point (which is neither A nor C nor D) plotted on a two-dimensional Cartesian grid (such that the X value represents a real whole number position along the horizontal axis of the Cartesian grid while Y represents a real whole number position along the vertical axis of the same Cartesian grid).
C = POINT(5,5). // C represents a point (which is neither A nor B nor D) plotted on a two-dimensional Cartesian grid (such that the X value represents a real whole number position along the horizontal axis of the Cartesian grid while Y represents a real whole number position along the vertical axis of the same Cartesian grid).
D = POINT(5,0). // D represents a point (which is neither A nor B nor C) plotted on a two-dimensional Cartesian grid (such that the X value represents a real whole number position along the horizontal axis of the Cartesian grid while Y represents a real whole number position along the vertical axis of the same Cartesian grid).
a = B.get_distance_from(C) = 5. // The method returns the approximate nonnegative real number of Cartesian grid unit lengths which span the length of the shortest path between points B and C.
b = C.get_distance_from(D) = 5. // The method returns the approximate nonnegative real number of Cartesian grid unit lengths which span the length of the shortest path between points C and D.
c = D.get_distance_from(A) = 5. // The method returns the approximate nonnegative real number of Cartesian grid unit lengths which span the length of the shortest path between points D and A.
d = A.get_distance_from(B) = 5. // The method returns the approximate nonnegative real number of Cartesian grid unit lengths which span the length of the shortest path between points A and B.
A.get_slope_of_line_to(B) = inf. // The method returns the approximate nonnegative real number which represents the slope of the line which intersects points A and B.
B.get_slope_of_line_to(C) = 0. // The method returns the approximate nonnegative real number which represents the slope of the line which intersects points B and C.
C.get_slope_of_line_to(D) = -inf. // The method returns the approximate nonnegative real number which represents the slope of the line which intersects points C and D.
D.get_slope_of_line_to(A) = 0. // The method returns the approximate nonnegative real number which represents the slope of the line which intersects points B and C.
interior_angle_DAB = interior_angle_of_A = 90.0000760198120843824654002673923969268798828125. // The value represents the approximate nonnegative real number angle measurement of the acute or else right angle formed by the intersection of the line segment whose endpoints are D and A with the line segment whose endpoints are A and B such that those two line segments intersect at A (and the angle measurement is in degrees and not in radians).
interior_angle_ABC = interior_angle_of_B = 90.0000760198120843824654002673923969268798828125. // The method returns the approximate nonnegative real number angle measurement of the acute or else right angle formed by the intersection of the line segment whose endpoints are A and B with the line segment whose endpoints are B and C such that those two line segments intersect at B (and the angle measurement is in degrees and not in radians).
interior_angle_BCD = interior_angle_of_C = 90.0000760198120843824654002673923969268798828125. // The method returns the approximate nonnegative real number angle measurement of the acute or else right angle formed by the intersection of the line segment whose endpoints are B and C with the line segment whose endpoints are C and D such that those two line segments intersect at C (and the angle measurement is in degrees and not in radians).
interior_angle_CDA = interior_angle_of_D = 90.0000760198120843824654002673923969268798828125. // The method returns the approximate nonnegative real number angle measurement of the acute or else right angle formed by the intersection of the line segment whose endpoints are C and D with the line segment whose endpoints are D and A such that those two line segments intersect at D (and the angle measurement is in degrees and not in radians).
interior_angle_of_A + interior_angle_of_B + interior_angle_of_C + interior_angle_of_D = 360.00030407924833752986160106956958770751953125. // sum of all four approximate interior angle measurements of the quadrilateral represented by the caller QUADRILATERAL object (in degrees and not in radians)
get_perimeter() = a + b + c + d = 20. // The method returns the sum of the four approximated side lengths of the rectangle which the caller RECTANGLE object represents.
get_area() = 25. // The method returns the approximate nonnegative real number of Cartesian grid unit squares which are enclosed inside of the two-dimensional region formed by the four line segments which connect points A to B, B to C, C to D, and D to A.
--------------------------------------------------------------------------------------------------
pointer_to_rectangle -&gt; get_area() = 25. // Indirectly call the RECTANGLE get_area() method.
pointer_to_rectangle -&gt; get_perimeter() = 20. // Indirectly call the RECTANGLE get_permieter() method.
delete pointer_to_rectangle; // De-allocate memory which was assigned to the dynamically allocated SQUARE instance.
--------------------------------------------------------------------------------------------------
--------------------------------------------------------------------------------------------------
Unit Test # 19: Test the normal SQUARE constructor and SQUARE copy constructor using valid function inputs and the SQUARE print method.
--------------------------------------------------------------------------------------------------
SQUARE square_0 = SQUARE("yellow", POINT(-3,-3), POINT(-3,0), POINT(0,0), POINT(0,-3));
square_0.print(output);
SQUARE square_1 = SQUARE("white", POINT(-1,-1), POINT(-1,1), POINT(1,1), POINT(1,-1));
square_1.print(output);
SQUARE square_2 = SQUARE(square_0);
square_2.print(output);
--------------------------------------------------------------------------------------------------

--------------------------------------------------------------------------------------------------
this = 0x7ffe7c17e460. // The keyword named this is a pointer which stores the memory address of the first memory cell of a QUADRILATERAL sized chunk of contiguous memory cells which are allocated to the caller TRIANGLE object.
&amp;category = 0x7ffe7c17e508. // The reference operation returns the memory address of the first memory cell of a string sized chunk of contiguous memory cells which are allocated to the string data attribute named category.
&amp;color = 0x7ffe7c17e488. // The reference operation returns the memory address of the first memory cell of a string sized chunk of contiguous memory cells which are allocated to the string data attribute named color..
&amp;A = 0x7ffe7c17e4c8. // The reference operation returns the memory address of the first memory cell of a POINT sized chunk of contiguous memory cells which are allocated to the POINT data attribute named A.
&amp;B = 0x7ffe7c17e4d0. // The reference operation returns the memory address of the first memory cell of a POINT sized chunk of contiguous memory cells which are allocated to the POINT data attribute named B.
&amp;C = 0x7ffe7c17e4d8. // The reference operation returns the memory address of the first memory cell of a POINT sized chunk of contiguous memory cells which are allocated to the POINT data attribute named C.
&amp;D = 0x7ffe7c17e4e0. // The reference operation returns the memory address of the first memory cell of a POINT sized chunk of contiguous memory cells which are allocated to the POINT data attribute named D.
sizeof(int) = 4. // The sizeof() operation returns the nonnegative integer number of bytes of memory which an int type variable occupies. (Each memory cell has a data capacity of 1 byte).
sizeof(int *) = 8. // The sizeof() operation returns the nonnegative integer number of bytes of memory which a pointer-to-int type variable occupies. (Each memory cell has a data capacity of 1 byte).
sizeof(int **) = 8. // The sizeof() operation returns the nonnegative integer number of bytes of memory which an pointer-to-pointer-to-int type variable occupies. (Each memory cell has a data capacity of 1 byte).
sizeof(std::string) = 32. // The sizeof() operation returns the nonnegative integer number of bytes of memory which a string type variable occupies. (Each memory cell has a data capacity of 1 byte).
sizeof(std::string *) = 8. // The sizeof() operation returns the nonnegative integer number of bytes of memory which a pointer-to-string type variable occupies. (Each memory cell has a data capacity of 1 byte).
sizeof(std::string **) = 8. // The sizeof() operation returns the nonnegative integer number of bytes of memory which a pointer-to-pointer-to-string type variable occupies. (Each memory cell has a data capacity of 1 byte).
sizeof(POINT) = 8. // The sizeof() operation returns the nonnegative integer number of bytes of memory which a POINT type object occupies. (Each memory cell has a data capacity of 1 byte).
sizeof(POINT *) = 8. // The sizeof() operation returns the nonnegative integer number of bytes of memory which a pointer-to-POINT type variable occupies. (Each memory cell has a data capacity of 1 byte).
sizeof(POINT **) = 8. // The sizeof() operation returns the nonnegative integer number of bytes of memory which a pointer-to-pointer-to-POINT type variable occupies. (Each memory cell has a data capacity of 1 byte).
sizeof(POLYGON) = 72. // The sizeof() operation returns the nonnegative integer number of bytes of memory which a POLYGON type object occupies. (Each memory cell has a data capacity of 1 byte).
sizeof(POLYGON *) = 8. // The sizeof() operation returns the nonnegative integer number of bytes of memory which a pointer-to-POLYGON type variable occupies. (Each memory cell has a data capacity of 1 byte).
sizeof(POLYGON **) = 8. // The sizeof() operation returns the nonnegative integer number of bytes of memory which a pointer-to-pointer-to-POLYGON type variable occupies. (Each memory cell has a data capacity of 1 byte).
sizeof(QUADRILATERAL) = 136. // The sizeof() operation returns the nonnegative integer number of bytes of memory which a QUADRILATERAL type object occupies. (Each memory cell has a data capacity of 1 byte).
sizeof(QUADRILATERAL *) = 8. // The sizeof() operation returns the nonnegative integer number of bytes of memory which a pointer-to-QUADRILATERAL type variable occupies. (Each memory cell has a data capacity of 1 byte).
sizeof(QUADRILATERAL **) = 8. // The sizeof() operation returns the nonnegative integer number of bytes of memory which a pointer-to-pointer-to-QUADRILATERAL type variable occupies. (Each memory cell has a data capacity of 1 byte).
sizeof(RECTANGLE) = 168. // The sizeof() operation returns the nonnegative integer number of bytes of memory which a RECTANGLE type object occupies. (Each memory cell has a data capacity of 1 byte).
sizeof(RECTANGLE *) = 8. // The sizeof() operation returns the nonnegative integer number of bytes of memory which a pointer-to-RECTANGLE type variable occupies. (Each memory cell has a data capacity of 1 byte).
sizeof(RECTANGLE **) = 8. // The sizeof() operation returns the nonnegative integer number of bytes of memory which a pointer-to-pointer-to-RECTANGLE type variable occupies. (Each memory cell has a data capacity of 1 byte).
sizeof(SQUARE) = 200. // The sizeof() operation returns the nonnegative integer number of bytes of memory which a SQUARE type object occupies. (Each memory cell has a data capacity of 1 byte).
sizeof(SQUARE *) = 8. // The sizeof() operation returns the nonnegative integer number of bytes of memory which a pointer-to-SQUARE type variable occupies. (Each memory cell has a data capacity of 1 byte).
sizeof(SQUARE **) = 8. // The sizeof() operation returns the nonnegative integer number of bytes of memory which a pointer-to-pointer-to-SQUARE type variable occupies. (Each memory cell has a data capacity of 1 byte).
category = POLYGON/QUADRILATERAL/RECTANGLE/SQUARE. // This is an immutable string type value which is a data member of the caller RECTANGLE object.
color = yellow. // This is a string type value which is a data member of the caller RECTANGLE object.
A = POINT(-3,-3). // A represents a point (which is neither B nor C nor D) plotted on a two-dimensional Cartesian grid (such that the X value represents a real whole number position along the horizontal axis of the Cartesian grid while Y represents a real whole number position along the vertical axis of the same Cartesian grid).
B = POINT(-3,0). // B represents a point (which is neither A nor C nor D) plotted on a two-dimensional Cartesian grid (such that the X value represents a real whole number position along the horizontal axis of the Cartesian grid while Y represents a real whole number position along the vertical axis of the same Cartesian grid).
C = POINT(0,0). // C represents a point (which is neither A nor B nor D) plotted on a two-dimensional Cartesian grid (such that the X value represents a real whole number position along the horizontal axis of the Cartesian grid while Y represents a real whole number position along the vertical axis of the same Cartesian grid).
D = POINT(0,-3). // D represents a point (which is neither A nor B nor C) plotted on a two-dimensional Cartesian grid (such that the X value represents a real whole number position along the horizontal axis of the Cartesian grid while Y represents a real whole number position along the vertical axis of the same Cartesian grid).
a = B.get_distance_from(C) = 3. // The method returns the approximate nonnegative real number of Cartesian grid unit lengths which span the length of the shortest path between points B and C.
b = C.get_distance_from(D) = 3. // The method returns the approximate nonnegative real number of Cartesian grid unit lengths which span the length of the shortest path between points C and D.
c = D.get_distance_from(A) = 3. // The method returns the approximate nonnegative real number of Cartesian grid unit lengths which span the length of the shortest path between points D and A.
d = A.get_distance_from(B) = 3. // The method returns the approximate nonnegative real number of Cartesian grid unit lengths which span the length of the shortest path between points A and B.
A.get_slope_of_line_to(B) = inf. // The method returns the approximate nonnegative real number which represents the slope of the line which intersects points A and B.
B.get_slope_of_line_to(C) = 0. // The method returns the approximate nonnegative real number which represents the slope of the line which intersects points B and C.
C.get_slope_of_line_to(D) = -inf. // The method returns the approximate nonnegative real number which represents the slope of the line which intersects points C and D.
D.get_slope_of_line_to(A) = 0. // The method returns the approximate nonnegative real number which represents the slope of the line which intersects points B and C.
interior_angle_DAB = interior_angle_of_A = 90.0000760198120559607559698633849620819091796875. // The value represents the approximate nonnegative real number angle measurement of the acute or else right angle formed by the intersection of the line segment whose endpoints are D and A with the line segment whose endpoints are A and B such that those two line segments intersect at A (and the angle measurement is in degrees and not in radians).
interior_angle_ABC = interior_angle_of_B = 90.0000760198120843824654002673923969268798828125. // The method returns the approximate nonnegative real number angle measurement of the acute or else right angle formed by the intersection of the line segment whose endpoints are A and B with the line segment whose endpoints are B and C such that those two line segments intersect at B (and the angle measurement is in degrees and not in radians).
interior_angle_BCD = interior_angle_of_C = 90.0000760198120559607559698633849620819091796875. // The method returns the approximate nonnegative real number angle measurement of the acute or else right angle formed by the intersection of the line segment whose endpoints are B and C with the line segment whose endpoints are C and D such that those two line segments intersect at C (and the angle measurement is in degrees and not in radians).
interior_angle_CDA = interior_angle_of_D = 90.0000760198120843824654002673923969268798828125. // The method returns the approximate nonnegative real number angle measurement of the acute or else right angle formed by the intersection of the line segment whose endpoints are C and D with the line segment whose endpoints are D and A such that those two line segments intersect at D (and the angle measurement is in degrees and not in radians).
interior_angle_of_A + interior_angle_of_B + interior_angle_of_C + interior_angle_of_D = 360.000304079248280686442740261554718017578125. // sum of all four approximate interior angle measurements of the quadrilateral represented by the caller QUADRILATERAL object (in degrees and not in radians)
get_perimeter() = a + b + c + d = 12. // The method returns the sum of the four approximated side lengths of the rectangle which the caller RECTANGLE object represents.
get_area() = 8.9999999999999946709294817992486059665679931640625. // The method returns the approximate nonnegative real number of Cartesian grid unit squares which are enclosed inside of the two-dimensional region formed by the four line segments which connect points A to B, B to C, C to D, and D to A.
--------------------------------------------------------------------------------------------------

--------------------------------------------------------------------------------------------------
this = 0x7ffe7c17e530. // The keyword named this is a pointer which stores the memory address of the first memory cell of a QUADRILATERAL sized chunk of contiguous memory cells which are allocated to the caller TRIANGLE object.
&amp;category = 0x7ffe7c17e5d8. // The reference operation returns the memory address of the first memory cell of a string sized chunk of contiguous memory cells which are allocated to the string data attribute named category.
&amp;color = 0x7ffe7c17e558. // The reference operation returns the memory address of the first memory cell of a string sized chunk of contiguous memory cells which are allocated to the string data attribute named color..
&amp;A = 0x7ffe7c17e598. // The reference operation returns the memory address of the first memory cell of a POINT sized chunk of contiguous memory cells which are allocated to the POINT data attribute named A.
&amp;B = 0x7ffe7c17e5a0. // The reference operation returns the memory address of the first memory cell of a POINT sized chunk of contiguous memory cells which are allocated to the POINT data attribute named B.
&amp;C = 0x7ffe7c17e5a8. // The reference operation returns the memory address of the first memory cell of a POINT sized chunk of contiguous memory cells which are allocated to the POINT data attribute named C.
&amp;D = 0x7ffe7c17e5b0. // The reference operation returns the memory address of the first memory cell of a POINT sized chunk of contiguous memory cells which are allocated to the POINT data attribute named D.
sizeof(int) = 4. // The sizeof() operation returns the nonnegative integer number of bytes of memory which an int type variable occupies. (Each memory cell has a data capacity of 1 byte).
sizeof(int *) = 8. // The sizeof() operation returns the nonnegative integer number of bytes of memory which a pointer-to-int type variable occupies. (Each memory cell has a data capacity of 1 byte).
sizeof(int **) = 8. // The sizeof() operation returns the nonnegative integer number of bytes of memory which an pointer-to-pointer-to-int type variable occupies. (Each memory cell has a data capacity of 1 byte).
sizeof(std::string) = 32. // The sizeof() operation returns the nonnegative integer number of bytes of memory which a string type variable occupies. (Each memory cell has a data capacity of 1 byte).
sizeof(std::string *) = 8. // The sizeof() operation returns the nonnegative integer number of bytes of memory which a pointer-to-string type variable occupies. (Each memory cell has a data capacity of 1 byte).
sizeof(std::string **) = 8. // The sizeof() operation returns the nonnegative integer number of bytes of memory which a pointer-to-pointer-to-string type variable occupies. (Each memory cell has a data capacity of 1 byte).
sizeof(POINT) = 8. // The sizeof() operation returns the nonnegative integer number of bytes of memory which a POINT type object occupies. (Each memory cell has a data capacity of 1 byte).
sizeof(POINT *) = 8. // The sizeof() operation returns the nonnegative integer number of bytes of memory which a pointer-to-POINT type variable occupies. (Each memory cell has a data capacity of 1 byte).
sizeof(POINT **) = 8. // The sizeof() operation returns the nonnegative integer number of bytes of memory which a pointer-to-pointer-to-POINT type variable occupies. (Each memory cell has a data capacity of 1 byte).
sizeof(POLYGON) = 72. // The sizeof() operation returns the nonnegative integer number of bytes of memory which a POLYGON type object occupies. (Each memory cell has a data capacity of 1 byte).
sizeof(POLYGON *) = 8. // The sizeof() operation returns the nonnegative integer number of bytes of memory which a pointer-to-POLYGON type variable occupies. (Each memory cell has a data capacity of 1 byte).
sizeof(POLYGON **) = 8. // The sizeof() operation returns the nonnegative integer number of bytes of memory which a pointer-to-pointer-to-POLYGON type variable occupies. (Each memory cell has a data capacity of 1 byte).
sizeof(QUADRILATERAL) = 136. // The sizeof() operation returns the nonnegative integer number of bytes of memory which a QUADRILATERAL type object occupies. (Each memory cell has a data capacity of 1 byte).
sizeof(QUADRILATERAL *) = 8. // The sizeof() operation returns the nonnegative integer number of bytes of memory which a pointer-to-QUADRILATERAL type variable occupies. (Each memory cell has a data capacity of 1 byte).
sizeof(QUADRILATERAL **) = 8. // The sizeof() operation returns the nonnegative integer number of bytes of memory which a pointer-to-pointer-to-QUADRILATERAL type variable occupies. (Each memory cell has a data capacity of 1 byte).
sizeof(RECTANGLE) = 168. // The sizeof() operation returns the nonnegative integer number of bytes of memory which a RECTANGLE type object occupies. (Each memory cell has a data capacity of 1 byte).
sizeof(RECTANGLE *) = 8. // The sizeof() operation returns the nonnegative integer number of bytes of memory which a pointer-to-RECTANGLE type variable occupies. (Each memory cell has a data capacity of 1 byte).
sizeof(RECTANGLE **) = 8. // The sizeof() operation returns the nonnegative integer number of bytes of memory which a pointer-to-pointer-to-RECTANGLE type variable occupies. (Each memory cell has a data capacity of 1 byte).
sizeof(SQUARE) = 200. // The sizeof() operation returns the nonnegative integer number of bytes of memory which a SQUARE type object occupies. (Each memory cell has a data capacity of 1 byte).
sizeof(SQUARE *) = 8. // The sizeof() operation returns the nonnegative integer number of bytes of memory which a pointer-to-SQUARE type variable occupies. (Each memory cell has a data capacity of 1 byte).
sizeof(SQUARE **) = 8. // The sizeof() operation returns the nonnegative integer number of bytes of memory which a pointer-to-pointer-to-SQUARE type variable occupies. (Each memory cell has a data capacity of 1 byte).
category = POLYGON/QUADRILATERAL/RECTANGLE/SQUARE. // This is an immutable string type value which is a data member of the caller RECTANGLE object.
color = white. // This is a string type value which is a data member of the caller RECTANGLE object.
A = POINT(-1,-1). // A represents a point (which is neither B nor C nor D) plotted on a two-dimensional Cartesian grid (such that the X value represents a real whole number position along the horizontal axis of the Cartesian grid while Y represents a real whole number position along the vertical axis of the same Cartesian grid).
B = POINT(-1,1). // B represents a point (which is neither A nor C nor D) plotted on a two-dimensional Cartesian grid (such that the X value represents a real whole number position along the horizontal axis of the Cartesian grid while Y represents a real whole number position along the vertical axis of the same Cartesian grid).
C = POINT(1,1). // C represents a point (which is neither A nor B nor D) plotted on a two-dimensional Cartesian grid (such that the X value represents a real whole number position along the horizontal axis of the Cartesian grid while Y represents a real whole number position along the vertical axis of the same Cartesian grid).
D = POINT(1,-1). // D represents a point (which is neither A nor B nor C) plotted on a two-dimensional Cartesian grid (such that the X value represents a real whole number position along the horizontal axis of the Cartesian grid while Y represents a real whole number position along the vertical axis of the same Cartesian grid).
a = B.get_distance_from(C) = 2. // The method returns the approximate nonnegative real number of Cartesian grid unit lengths which span the length of the shortest path between points B and C.
b = C.get_distance_from(D) = 2. // The method returns the approximate nonnegative real number of Cartesian grid unit lengths which span the length of the shortest path between points C and D.
c = D.get_distance_from(A) = 2. // The method returns the approximate nonnegative real number of Cartesian grid unit lengths which span the length of the shortest path between points D and A.
d = A.get_distance_from(B) = 2. // The method returns the approximate nonnegative real number of Cartesian grid unit lengths which span the length of the shortest path between points A and B.
A.get_slope_of_line_to(B) = inf. // The method returns the approximate nonnegative real number which represents the slope of the line which intersects points A and B.
B.get_slope_of_line_to(C) = 0. // The method returns the approximate nonnegative real number which represents the slope of the line which intersects points B and C.
C.get_slope_of_line_to(D) = -inf. // The method returns the approximate nonnegative real number which represents the slope of the line which intersects points C and D.
D.get_slope_of_line_to(A) = 0. // The method returns the approximate nonnegative real number which represents the slope of the line which intersects points B and C.
interior_angle_DAB = interior_angle_of_A = 90.0000760198120843824654002673923969268798828125. // The value represents the approximate nonnegative real number angle measurement of the acute or else right angle formed by the intersection of the line segment whose endpoints are D and A with the line segment whose endpoints are A and B such that those two line segments intersect at A (and the angle measurement is in degrees and not in radians).
interior_angle_ABC = interior_angle_of_B = 90.000076019812041749901254661381244659423828125. // The method returns the approximate nonnegative real number angle measurement of the acute or else right angle formed by the intersection of the line segment whose endpoints are A and B with the line segment whose endpoints are B and C such that those two line segments intersect at B (and the angle measurement is in degrees and not in radians).
interior_angle_BCD = interior_angle_of_C = 90.0000760198120843824654002673923969268798828125. // The method returns the approximate nonnegative real number angle measurement of the acute or else right angle formed by the intersection of the line segment whose endpoints are B and C with the line segment whose endpoints are C and D such that those two line segments intersect at C (and the angle measurement is in degrees and not in radians).
interior_angle_CDA = interior_angle_of_D = 90.000076019812041749901254661381244659423828125. // The method returns the approximate nonnegative real number angle measurement of the acute or else right angle formed by the intersection of the line segment whose endpoints are C and D with the line segment whose endpoints are D and A such that those two line segments intersect at D (and the angle measurement is in degrees and not in radians).
interior_angle_of_A + interior_angle_of_B + interior_angle_of_C + interior_angle_of_D = 360.000304079248280686442740261554718017578125. // sum of all four approximate interior angle measurements of the quadrilateral represented by the caller QUADRILATERAL object (in degrees and not in radians)
get_perimeter() = a + b + c + d = 8. // The method returns the sum of the four approximated side lengths of the rectangle which the caller RECTANGLE object represents.
get_area() = 3.9999999999999982236431605997495353221893310546875. // The method returns the approximate nonnegative real number of Cartesian grid unit squares which are enclosed inside of the two-dimensional region formed by the four line segments which connect points A to B, B to C, C to D, and D to A.
--------------------------------------------------------------------------------------------------

--------------------------------------------------------------------------------------------------
this = 0x7ffe7c17e600. // The keyword named this is a pointer which stores the memory address of the first memory cell of a QUADRILATERAL sized chunk of contiguous memory cells which are allocated to the caller TRIANGLE object.
&amp;category = 0x7ffe7c17e6a8. // The reference operation returns the memory address of the first memory cell of a string sized chunk of contiguous memory cells which are allocated to the string data attribute named category.
&amp;color = 0x7ffe7c17e628. // The reference operation returns the memory address of the first memory cell of a string sized chunk of contiguous memory cells which are allocated to the string data attribute named color..
&amp;A = 0x7ffe7c17e668. // The reference operation returns the memory address of the first memory cell of a POINT sized chunk of contiguous memory cells which are allocated to the POINT data attribute named A.
&amp;B = 0x7ffe7c17e670. // The reference operation returns the memory address of the first memory cell of a POINT sized chunk of contiguous memory cells which are allocated to the POINT data attribute named B.
&amp;C = 0x7ffe7c17e678. // The reference operation returns the memory address of the first memory cell of a POINT sized chunk of contiguous memory cells which are allocated to the POINT data attribute named C.
&amp;D = 0x7ffe7c17e680. // The reference operation returns the memory address of the first memory cell of a POINT sized chunk of contiguous memory cells which are allocated to the POINT data attribute named D.
sizeof(int) = 4. // The sizeof() operation returns the nonnegative integer number of bytes of memory which an int type variable occupies. (Each memory cell has a data capacity of 1 byte).
sizeof(int *) = 8. // The sizeof() operation returns the nonnegative integer number of bytes of memory which a pointer-to-int type variable occupies. (Each memory cell has a data capacity of 1 byte).
sizeof(int **) = 8. // The sizeof() operation returns the nonnegative integer number of bytes of memory which an pointer-to-pointer-to-int type variable occupies. (Each memory cell has a data capacity of 1 byte).
sizeof(std::string) = 32. // The sizeof() operation returns the nonnegative integer number of bytes of memory which a string type variable occupies. (Each memory cell has a data capacity of 1 byte).
sizeof(std::string *) = 8. // The sizeof() operation returns the nonnegative integer number of bytes of memory which a pointer-to-string type variable occupies. (Each memory cell has a data capacity of 1 byte).
sizeof(std::string **) = 8. // The sizeof() operation returns the nonnegative integer number of bytes of memory which a pointer-to-pointer-to-string type variable occupies. (Each memory cell has a data capacity of 1 byte).
sizeof(POINT) = 8. // The sizeof() operation returns the nonnegative integer number of bytes of memory which a POINT type object occupies. (Each memory cell has a data capacity of 1 byte).
sizeof(POINT *) = 8. // The sizeof() operation returns the nonnegative integer number of bytes of memory which a pointer-to-POINT type variable occupies. (Each memory cell has a data capacity of 1 byte).
sizeof(POINT **) = 8. // The sizeof() operation returns the nonnegative integer number of bytes of memory which a pointer-to-pointer-to-POINT type variable occupies. (Each memory cell has a data capacity of 1 byte).
sizeof(POLYGON) = 72. // The sizeof() operation returns the nonnegative integer number of bytes of memory which a POLYGON type object occupies. (Each memory cell has a data capacity of 1 byte).
sizeof(POLYGON *) = 8. // The sizeof() operation returns the nonnegative integer number of bytes of memory which a pointer-to-POLYGON type variable occupies. (Each memory cell has a data capacity of 1 byte).
sizeof(POLYGON **) = 8. // The sizeof() operation returns the nonnegative integer number of bytes of memory which a pointer-to-pointer-to-POLYGON type variable occupies. (Each memory cell has a data capacity of 1 byte).
sizeof(QUADRILATERAL) = 136. // The sizeof() operation returns the nonnegative integer number of bytes of memory which a QUADRILATERAL type object occupies. (Each memory cell has a data capacity of 1 byte).
sizeof(QUADRILATERAL *) = 8. // The sizeof() operation returns the nonnegative integer number of bytes of memory which a pointer-to-QUADRILATERAL type variable occupies. (Each memory cell has a data capacity of 1 byte).
sizeof(QUADRILATERAL **) = 8. // The sizeof() operation returns the nonnegative integer number of bytes of memory which a pointer-to-pointer-to-QUADRILATERAL type variable occupies. (Each memory cell has a data capacity of 1 byte).
sizeof(RECTANGLE) = 168. // The sizeof() operation returns the nonnegative integer number of bytes of memory which a RECTANGLE type object occupies. (Each memory cell has a data capacity of 1 byte).
sizeof(RECTANGLE *) = 8. // The sizeof() operation returns the nonnegative integer number of bytes of memory which a pointer-to-RECTANGLE type variable occupies. (Each memory cell has a data capacity of 1 byte).
sizeof(RECTANGLE **) = 8. // The sizeof() operation returns the nonnegative integer number of bytes of memory which a pointer-to-pointer-to-RECTANGLE type variable occupies. (Each memory cell has a data capacity of 1 byte).
sizeof(SQUARE) = 200. // The sizeof() operation returns the nonnegative integer number of bytes of memory which a SQUARE type object occupies. (Each memory cell has a data capacity of 1 byte).
sizeof(SQUARE *) = 8. // The sizeof() operation returns the nonnegative integer number of bytes of memory which a pointer-to-SQUARE type variable occupies. (Each memory cell has a data capacity of 1 byte).
sizeof(SQUARE **) = 8. // The sizeof() operation returns the nonnegative integer number of bytes of memory which a pointer-to-pointer-to-SQUARE type variable occupies. (Each memory cell has a data capacity of 1 byte).
category = POLYGON/QUADRILATERAL/RECTANGLE/SQUARE. // This is an immutable string type value which is a data member of the caller RECTANGLE object.
color = yellow. // This is a string type value which is a data member of the caller RECTANGLE object.
A = POINT(-3,-3). // A represents a point (which is neither B nor C nor D) plotted on a two-dimensional Cartesian grid (such that the X value represents a real whole number position along the horizontal axis of the Cartesian grid while Y represents a real whole number position along the vertical axis of the same Cartesian grid).
B = POINT(-3,0). // B represents a point (which is neither A nor C nor D) plotted on a two-dimensional Cartesian grid (such that the X value represents a real whole number position along the horizontal axis of the Cartesian grid while Y represents a real whole number position along the vertical axis of the same Cartesian grid).
C = POINT(0,0). // C represents a point (which is neither A nor B nor D) plotted on a two-dimensional Cartesian grid (such that the X value represents a real whole number position along the horizontal axis of the Cartesian grid while Y represents a real whole number position along the vertical axis of the same Cartesian grid).
D = POINT(0,-3). // D represents a point (which is neither A nor B nor C) plotted on a two-dimensional Cartesian grid (such that the X value represents a real whole number position along the horizontal axis of the Cartesian grid while Y represents a real whole number position along the vertical axis of the same Cartesian grid).
a = B.get_distance_from(C) = 3. // The method returns the approximate nonnegative real number of Cartesian grid unit lengths which span the length of the shortest path between points B and C.
b = C.get_distance_from(D) = 3. // The method returns the approximate nonnegative real number of Cartesian grid unit lengths which span the length of the shortest path between points C and D.
c = D.get_distance_from(A) = 3. // The method returns the approximate nonnegative real number of Cartesian grid unit lengths which span the length of the shortest path between points D and A.
d = A.get_distance_from(B) = 3. // The method returns the approximate nonnegative real number of Cartesian grid unit lengths which span the length of the shortest path between points A and B.
A.get_slope_of_line_to(B) = inf. // The method returns the approximate nonnegative real number which represents the slope of the line which intersects points A and B.
B.get_slope_of_line_to(C) = 0. // The method returns the approximate nonnegative real number which represents the slope of the line which intersects points B and C.
C.get_slope_of_line_to(D) = -inf. // The method returns the approximate nonnegative real number which represents the slope of the line which intersects points C and D.
D.get_slope_of_line_to(A) = 0. // The method returns the approximate nonnegative real number which represents the slope of the line which intersects points B and C.
interior_angle_DAB = interior_angle_of_A = 90.0000760198120559607559698633849620819091796875. // The value represents the approximate nonnegative real number angle measurement of the acute or else right angle formed by the intersection of the line segment whose endpoints are D and A with the line segment whose endpoints are A and B such that those two line segments intersect at A (and the angle measurement is in degrees and not in radians).
interior_angle_ABC = interior_angle_of_B = 90.0000760198120843824654002673923969268798828125. // The method returns the approximate nonnegative real number angle measurement of the acute or else right angle formed by the intersection of the line segment whose endpoints are A and B with the line segment whose endpoints are B and C such that those two line segments intersect at B (and the angle measurement is in degrees and not in radians).
interior_angle_BCD = interior_angle_of_C = 90.0000760198120559607559698633849620819091796875. // The method returns the approximate nonnegative real number angle measurement of the acute or else right angle formed by the intersection of the line segment whose endpoints are B and C with the line segment whose endpoints are C and D such that those two line segments intersect at C (and the angle measurement is in degrees and not in radians).
interior_angle_CDA = interior_angle_of_D = 90.0000760198120843824654002673923969268798828125. // The method returns the approximate nonnegative real number angle measurement of the acute or else right angle formed by the intersection of the line segment whose endpoints are C and D with the line segment whose endpoints are D and A such that those two line segments intersect at D (and the angle measurement is in degrees and not in radians).
interior_angle_of_A + interior_angle_of_B + interior_angle_of_C + interior_angle_of_D = 360.000304079248280686442740261554718017578125. // sum of all four approximate interior angle measurements of the quadrilateral represented by the caller QUADRILATERAL object (in degrees and not in radians)
get_perimeter() = a + b + c + d = 12. // The method returns the sum of the four approximated side lengths of the rectangle which the caller RECTANGLE object represents.
get_area() = 8.9999999999999946709294817992486059665679931640625. // The method returns the approximate nonnegative real number of Cartesian grid unit squares which are enclosed inside of the two-dimensional region formed by the four line segments which connect points A to B, B to C, C to D, and D to A.
--------------------------------------------------------------------------------------------------
--------------------------------------------------------------------------------------------------
Unit Test # 20: Test the normal SQUARE constructor using invalid function inputs and the SQUARE print method.
--------------------------------------------------------------------------------------------------
SQUARE square_0 = SQUARE("red", POINT(0,0), POINT(0,1), POINT(0,2), POINT(0,3));
square_0.print(output);
SQUARE square_1 = SQUARE("green", POINT(0,0), POINT(0,1), POINT(5,1), POINT(5,0));
square_1.print(output);
SQUARE square_2 = SQUARE("blue", POINT(0,0), POINT(0,1), POINT(1,1), POINT(0,0));
square_2.print(output);
--------------------------------------------------------------------------------------------------

--------------------------------------------------------------------------------------------------
this = 0x7ffe7c17e460. // The keyword named this is a pointer which stores the memory address of the first memory cell of a QUADRILATERAL sized chunk of contiguous memory cells which are allocated to the caller TRIANGLE object.
&amp;category = 0x7ffe7c17e508. // The reference operation returns the memory address of the first memory cell of a string sized chunk of contiguous memory cells which are allocated to the string data attribute named category.
&amp;color = 0x7ffe7c17e488. // The reference operation returns the memory address of the first memory cell of a string sized chunk of contiguous memory cells which are allocated to the string data attribute named color..
&amp;A = 0x7ffe7c17e4c8. // The reference operation returns the memory address of the first memory cell of a POINT sized chunk of contiguous memory cells which are allocated to the POINT data attribute named A.
&amp;B = 0x7ffe7c17e4d0. // The reference operation returns the memory address of the first memory cell of a POINT sized chunk of contiguous memory cells which are allocated to the POINT data attribute named B.
&amp;C = 0x7ffe7c17e4d8. // The reference operation returns the memory address of the first memory cell of a POINT sized chunk of contiguous memory cells which are allocated to the POINT data attribute named C.
&amp;D = 0x7ffe7c17e4e0. // The reference operation returns the memory address of the first memory cell of a POINT sized chunk of contiguous memory cells which are allocated to the POINT data attribute named D.
sizeof(int) = 4. // The sizeof() operation returns the nonnegative integer number of bytes of memory which an int type variable occupies. (Each memory cell has a data capacity of 1 byte).
sizeof(int *) = 8. // The sizeof() operation returns the nonnegative integer number of bytes of memory which a pointer-to-int type variable occupies. (Each memory cell has a data capacity of 1 byte).
sizeof(int **) = 8. // The sizeof() operation returns the nonnegative integer number of bytes of memory which an pointer-to-pointer-to-int type variable occupies. (Each memory cell has a data capacity of 1 byte).
sizeof(std::string) = 32. // The sizeof() operation returns the nonnegative integer number of bytes of memory which a string type variable occupies. (Each memory cell has a data capacity of 1 byte).
sizeof(std::string *) = 8. // The sizeof() operation returns the nonnegative integer number of bytes of memory which a pointer-to-string type variable occupies. (Each memory cell has a data capacity of 1 byte).
sizeof(std::string **) = 8. // The sizeof() operation returns the nonnegative integer number of bytes of memory which a pointer-to-pointer-to-string type variable occupies. (Each memory cell has a data capacity of 1 byte).
sizeof(POINT) = 8. // The sizeof() operation returns the nonnegative integer number of bytes of memory which a POINT type object occupies. (Each memory cell has a data capacity of 1 byte).
sizeof(POINT *) = 8. // The sizeof() operation returns the nonnegative integer number of bytes of memory which a pointer-to-POINT type variable occupies. (Each memory cell has a data capacity of 1 byte).
sizeof(POINT **) = 8. // The sizeof() operation returns the nonnegative integer number of bytes of memory which a pointer-to-pointer-to-POINT type variable occupies. (Each memory cell has a data capacity of 1 byte).
sizeof(POLYGON) = 72. // The sizeof() operation returns the nonnegative integer number of bytes of memory which a POLYGON type object occupies. (Each memory cell has a data capacity of 1 byte).
sizeof(POLYGON *) = 8. // The sizeof() operation returns the nonnegative integer number of bytes of memory which a pointer-to-POLYGON type variable occupies. (Each memory cell has a data capacity of 1 byte).
sizeof(POLYGON **) = 8. // The sizeof() operation returns the nonnegative integer number of bytes of memory which a pointer-to-pointer-to-POLYGON type variable occupies. (Each memory cell has a data capacity of 1 byte).
sizeof(QUADRILATERAL) = 136. // The sizeof() operation returns the nonnegative integer number of bytes of memory which a QUADRILATERAL type object occupies. (Each memory cell has a data capacity of 1 byte).
sizeof(QUADRILATERAL *) = 8. // The sizeof() operation returns the nonnegative integer number of bytes of memory which a pointer-to-QUADRILATERAL type variable occupies. (Each memory cell has a data capacity of 1 byte).
sizeof(QUADRILATERAL **) = 8. // The sizeof() operation returns the nonnegative integer number of bytes of memory which a pointer-to-pointer-to-QUADRILATERAL type variable occupies. (Each memory cell has a data capacity of 1 byte).
sizeof(RECTANGLE) = 168. // The sizeof() operation returns the nonnegative integer number of bytes of memory which a RECTANGLE type object occupies. (Each memory cell has a data capacity of 1 byte).
sizeof(RECTANGLE *) = 8. // The sizeof() operation returns the nonnegative integer number of bytes of memory which a pointer-to-RECTANGLE type variable occupies. (Each memory cell has a data capacity of 1 byte).
sizeof(RECTANGLE **) = 8. // The sizeof() operation returns the nonnegative integer number of bytes of memory which a pointer-to-pointer-to-RECTANGLE type variable occupies. (Each memory cell has a data capacity of 1 byte).
sizeof(SQUARE) = 200. // The sizeof() operation returns the nonnegative integer number of bytes of memory which a SQUARE type object occupies. (Each memory cell has a data capacity of 1 byte).
sizeof(SQUARE *) = 8. // The sizeof() operation returns the nonnegative integer number of bytes of memory which a pointer-to-SQUARE type variable occupies. (Each memory cell has a data capacity of 1 byte).
sizeof(SQUARE **) = 8. // The sizeof() operation returns the nonnegative integer number of bytes of memory which a pointer-to-pointer-to-SQUARE type variable occupies. (Each memory cell has a data capacity of 1 byte).
category = POLYGON/QUADRILATERAL/RECTANGLE/SQUARE. // This is an immutable string type value which is a data member of the caller RECTANGLE object.
color = red. // This is a string type value which is a data member of the caller RECTANGLE object.
A = POINT(0,0). // A represents a point (which is neither B nor C nor D) plotted on a two-dimensional Cartesian grid (such that the X value represents a real whole number position along the horizontal axis of the Cartesian grid while Y represents a real whole number position along the vertical axis of the same Cartesian grid).
B = POINT(0,3). // B represents a point (which is neither A nor C nor D) plotted on a two-dimensional Cartesian grid (such that the X value represents a real whole number position along the horizontal axis of the Cartesian grid while Y represents a real whole number position along the vertical axis of the same Cartesian grid).
C = POINT(4,3). // C represents a point (which is neither A nor B nor D) plotted on a two-dimensional Cartesian grid (such that the X value represents a real whole number position along the horizontal axis of the Cartesian grid while Y represents a real whole number position along the vertical axis of the same Cartesian grid).
D = POINT(4,0). // D represents a point (which is neither A nor B nor C) plotted on a two-dimensional Cartesian grid (such that the X value represents a real whole number position along the horizontal axis of the Cartesian grid while Y represents a real whole number position along the vertical axis of the same Cartesian grid).
a = B.get_distance_from(C) = 4. // The method returns the approximate nonnegative real number of Cartesian grid unit lengths which span the length of the shortest path between points B and C.
b = C.get_distance_from(D) = 3. // The method returns the approximate nonnegative real number of Cartesian grid unit lengths which span the length of the shortest path between points C and D.
c = D.get_distance_from(A) = 4. // The method returns the approximate nonnegative real number of Cartesian grid unit lengths which span the length of the shortest path between points D and A.
d = A.get_distance_from(B) = 3. // The method returns the approximate nonnegative real number of Cartesian grid unit lengths which span the length of the shortest path between points A and B.
A.get_slope_of_line_to(B) = inf. // The method returns the approximate nonnegative real number which represents the slope of the line which intersects points A and B.
B.get_slope_of_line_to(C) = 0. // The method returns the approximate nonnegative real number which represents the slope of the line which intersects points B and C.
C.get_slope_of_line_to(D) = -inf. // The method returns the approximate nonnegative real number which represents the slope of the line which intersects points C and D.
D.get_slope_of_line_to(A) = 0. // The method returns the approximate nonnegative real number which represents the slope of the line which intersects points B and C.
interior_angle_DAB = interior_angle_of_A = 90.00007601981207017161068506538867950439453125. // The value represents the approximate nonnegative real number angle measurement of the acute or else right angle formed by the intersection of the line segment whose endpoints are D and A with the line segment whose endpoints are A and B such that those two line segments intersect at A (and the angle measurement is in degrees and not in radians).
interior_angle_ABC = interior_angle_of_B = 90.00007601981207017161068506538867950439453125. // The method returns the approximate nonnegative real number angle measurement of the acute or else right angle formed by the intersection of the line segment whose endpoints are A and B with the line segment whose endpoints are B and C such that those two line segments intersect at B (and the angle measurement is in degrees and not in radians).
interior_angle_BCD = interior_angle_of_C = 90.00007601981207017161068506538867950439453125. // The method returns the approximate nonnegative real number angle measurement of the acute or else right angle formed by the intersection of the line segment whose endpoints are B and C with the line segment whose endpoints are C and D such that those two line segments intersect at C (and the angle measurement is in degrees and not in radians).
interior_angle_CDA = interior_angle_of_D = 90.00007601981207017161068506538867950439453125. // The method returns the approximate nonnegative real number angle measurement of the acute or else right angle formed by the intersection of the line segment whose endpoints are C and D with the line segment whose endpoints are D and A such that those two line segments intersect at D (and the angle measurement is in degrees and not in radians).
interior_angle_of_A + interior_angle_of_B + interior_angle_of_C + interior_angle_of_D = 360.000304079248280686442740261554718017578125. // sum of all four approximate interior angle measurements of the quadrilateral represented by the caller QUADRILATERAL object (in degrees and not in radians)
get_perimeter() = a + b + c + d = 14. // The method returns the sum of the four approximated side lengths of the rectangle which the caller RECTANGLE object represents.
get_area() = 12. // The method returns the approximate nonnegative real number of Cartesian grid unit squares which are enclosed inside of the two-dimensional region formed by the four line segments which connect points A to B, B to C, C to D, and D to A.
--------------------------------------------------------------------------------------------------

--------------------------------------------------------------------------------------------------
this = 0x7ffe7c17e530. // The keyword named this is a pointer which stores the memory address of the first memory cell of a QUADRILATERAL sized chunk of contiguous memory cells which are allocated to the caller TRIANGLE object.
&amp;category = 0x7ffe7c17e5d8. // The reference operation returns the memory address of the first memory cell of a string sized chunk of contiguous memory cells which are allocated to the string data attribute named category.
&amp;color = 0x7ffe7c17e558. // The reference operation returns the memory address of the first memory cell of a string sized chunk of contiguous memory cells which are allocated to the string data attribute named color..
&amp;A = 0x7ffe7c17e598. // The reference operation returns the memory address of the first memory cell of a POINT sized chunk of contiguous memory cells which are allocated to the POINT data attribute named A.
&amp;B = 0x7ffe7c17e5a0. // The reference operation returns the memory address of the first memory cell of a POINT sized chunk of contiguous memory cells which are allocated to the POINT data attribute named B.
&amp;C = 0x7ffe7c17e5a8. // The reference operation returns the memory address of the first memory cell of a POINT sized chunk of contiguous memory cells which are allocated to the POINT data attribute named C.
&amp;D = 0x7ffe7c17e5b0. // The reference operation returns the memory address of the first memory cell of a POINT sized chunk of contiguous memory cells which are allocated to the POINT data attribute named D.
sizeof(int) = 4. // The sizeof() operation returns the nonnegative integer number of bytes of memory which an int type variable occupies. (Each memory cell has a data capacity of 1 byte).
sizeof(int *) = 8. // The sizeof() operation returns the nonnegative integer number of bytes of memory which a pointer-to-int type variable occupies. (Each memory cell has a data capacity of 1 byte).
sizeof(int **) = 8. // The sizeof() operation returns the nonnegative integer number of bytes of memory which an pointer-to-pointer-to-int type variable occupies. (Each memory cell has a data capacity of 1 byte).
sizeof(std::string) = 32. // The sizeof() operation returns the nonnegative integer number of bytes of memory which a string type variable occupies. (Each memory cell has a data capacity of 1 byte).
sizeof(std::string *) = 8. // The sizeof() operation returns the nonnegative integer number of bytes of memory which a pointer-to-string type variable occupies. (Each memory cell has a data capacity of 1 byte).
sizeof(std::string **) = 8. // The sizeof() operation returns the nonnegative integer number of bytes of memory which a pointer-to-pointer-to-string type variable occupies. (Each memory cell has a data capacity of 1 byte).
sizeof(POINT) = 8. // The sizeof() operation returns the nonnegative integer number of bytes of memory which a POINT type object occupies. (Each memory cell has a data capacity of 1 byte).
sizeof(POINT *) = 8. // The sizeof() operation returns the nonnegative integer number of bytes of memory which a pointer-to-POINT type variable occupies. (Each memory cell has a data capacity of 1 byte).
sizeof(POINT **) = 8. // The sizeof() operation returns the nonnegative integer number of bytes of memory which a pointer-to-pointer-to-POINT type variable occupies. (Each memory cell has a data capacity of 1 byte).
sizeof(POLYGON) = 72. // The sizeof() operation returns the nonnegative integer number of bytes of memory which a POLYGON type object occupies. (Each memory cell has a data capacity of 1 byte).
sizeof(POLYGON *) = 8. // The sizeof() operation returns the nonnegative integer number of bytes of memory which a pointer-to-POLYGON type variable occupies. (Each memory cell has a data capacity of 1 byte).
sizeof(POLYGON **) = 8. // The sizeof() operation returns the nonnegative integer number of bytes of memory which a pointer-to-pointer-to-POLYGON type variable occupies. (Each memory cell has a data capacity of 1 byte).
sizeof(QUADRILATERAL) = 136. // The sizeof() operation returns the nonnegative integer number of bytes of memory which a QUADRILATERAL type object occupies. (Each memory cell has a data capacity of 1 byte).
sizeof(QUADRILATERAL *) = 8. // The sizeof() operation returns the nonnegative integer number of bytes of memory which a pointer-to-QUADRILATERAL type variable occupies. (Each memory cell has a data capacity of 1 byte).
sizeof(QUADRILATERAL **) = 8. // The sizeof() operation returns the nonnegative integer number of bytes of memory which a pointer-to-pointer-to-QUADRILATERAL type variable occupies. (Each memory cell has a data capacity of 1 byte).
sizeof(RECTANGLE) = 168. // The sizeof() operation returns the nonnegative integer number of bytes of memory which a RECTANGLE type object occupies. (Each memory cell has a data capacity of 1 byte).
sizeof(RECTANGLE *) = 8. // The sizeof() operation returns the nonnegative integer number of bytes of memory which a pointer-to-RECTANGLE type variable occupies. (Each memory cell has a data capacity of 1 byte).
sizeof(RECTANGLE **) = 8. // The sizeof() operation returns the nonnegative integer number of bytes of memory which a pointer-to-pointer-to-RECTANGLE type variable occupies. (Each memory cell has a data capacity of 1 byte).
sizeof(SQUARE) = 200. // The sizeof() operation returns the nonnegative integer number of bytes of memory which a SQUARE type object occupies. (Each memory cell has a data capacity of 1 byte).
sizeof(SQUARE *) = 8. // The sizeof() operation returns the nonnegative integer number of bytes of memory which a pointer-to-SQUARE type variable occupies. (Each memory cell has a data capacity of 1 byte).
sizeof(SQUARE **) = 8. // The sizeof() operation returns the nonnegative integer number of bytes of memory which a pointer-to-pointer-to-SQUARE type variable occupies. (Each memory cell has a data capacity of 1 byte).
category = POLYGON/QUADRILATERAL/RECTANGLE/SQUARE. // This is an immutable string type value which is a data member of the caller RECTANGLE object.
color = green. // This is a string type value which is a data member of the caller RECTANGLE object.
A = POINT(0,0). // A represents a point (which is neither B nor C nor D) plotted on a two-dimensional Cartesian grid (such that the X value represents a real whole number position along the horizontal axis of the Cartesian grid while Y represents a real whole number position along the vertical axis of the same Cartesian grid).
B = POINT(0,3). // B represents a point (which is neither A nor C nor D) plotted on a two-dimensional Cartesian grid (such that the X value represents a real whole number position along the horizontal axis of the Cartesian grid while Y represents a real whole number position along the vertical axis of the same Cartesian grid).
C = POINT(4,3). // C represents a point (which is neither A nor B nor D) plotted on a two-dimensional Cartesian grid (such that the X value represents a real whole number position along the horizontal axis of the Cartesian grid while Y represents a real whole number position along the vertical axis of the same Cartesian grid).
D = POINT(4,0). // D represents a point (which is neither A nor B nor C) plotted on a two-dimensional Cartesian grid (such that the X value represents a real whole number position along the horizontal axis of the Cartesian grid while Y represents a real whole number position along the vertical axis of the same Cartesian grid).
a = B.get_distance_from(C) = 4. // The method returns the approximate nonnegative real number of Cartesian grid unit lengths which span the length of the shortest path between points B and C.
b = C.get_distance_from(D) = 3. // The method returns the approximate nonnegative real number of Cartesian grid unit lengths which span the length of the shortest path between points C and D.
c = D.get_distance_from(A) = 4. // The method returns the approximate nonnegative real number of Cartesian grid unit lengths which span the length of the shortest path between points D and A.
d = A.get_distance_from(B) = 3. // The method returns the approximate nonnegative real number of Cartesian grid unit lengths which span the length of the shortest path between points A and B.
A.get_slope_of_line_to(B) = inf. // The method returns the approximate nonnegative real number which represents the slope of the line which intersects points A and B.
B.get_slope_of_line_to(C) = 0. // The method returns the approximate nonnegative real number which represents the slope of the line which intersects points B and C.
C.get_slope_of_line_to(D) = -inf. // The method returns the approximate nonnegative real number which represents the slope of the line which intersects points C and D.
D.get_slope_of_line_to(A) = 0. // The method returns the approximate nonnegative real number which represents the slope of the line which intersects points B and C.
interior_angle_DAB = interior_angle_of_A = 90.00007601981207017161068506538867950439453125. // The value represents the approximate nonnegative real number angle measurement of the acute or else right angle formed by the intersection of the line segment whose endpoints are D and A with the line segment whose endpoints are A and B such that those two line segments intersect at A (and the angle measurement is in degrees and not in radians).
interior_angle_ABC = interior_angle_of_B = 90.00007601981207017161068506538867950439453125. // The method returns the approximate nonnegative real number angle measurement of the acute or else right angle formed by the intersection of the line segment whose endpoints are A and B with the line segment whose endpoints are B and C such that those two line segments intersect at B (and the angle measurement is in degrees and not in radians).
interior_angle_BCD = interior_angle_of_C = 90.00007601981207017161068506538867950439453125. // The method returns the approximate nonnegative real number angle measurement of the acute or else right angle formed by the intersection of the line segment whose endpoints are B and C with the line segment whose endpoints are C and D such that those two line segments intersect at C (and the angle measurement is in degrees and not in radians).
interior_angle_CDA = interior_angle_of_D = 90.00007601981207017161068506538867950439453125. // The method returns the approximate nonnegative real number angle measurement of the acute or else right angle formed by the intersection of the line segment whose endpoints are C and D with the line segment whose endpoints are D and A such that those two line segments intersect at D (and the angle measurement is in degrees and not in radians).
interior_angle_of_A + interior_angle_of_B + interior_angle_of_C + interior_angle_of_D = 360.000304079248280686442740261554718017578125. // sum of all four approximate interior angle measurements of the quadrilateral represented by the caller QUADRILATERAL object (in degrees and not in radians)
get_perimeter() = a + b + c + d = 14. // The method returns the sum of the four approximated side lengths of the rectangle which the caller RECTANGLE object represents.
get_area() = 12. // The method returns the approximate nonnegative real number of Cartesian grid unit squares which are enclosed inside of the two-dimensional region formed by the four line segments which connect points A to B, B to C, C to D, and D to A.
--------------------------------------------------------------------------------------------------

--------------------------------------------------------------------------------------------------
this = 0x7ffe7c17e600. // The keyword named this is a pointer which stores the memory address of the first memory cell of a QUADRILATERAL sized chunk of contiguous memory cells which are allocated to the caller TRIANGLE object.
&amp;category = 0x7ffe7c17e6a8. // The reference operation returns the memory address of the first memory cell of a string sized chunk of contiguous memory cells which are allocated to the string data attribute named category.
&amp;color = 0x7ffe7c17e628. // The reference operation returns the memory address of the first memory cell of a string sized chunk of contiguous memory cells which are allocated to the string data attribute named color..
&amp;A = 0x7ffe7c17e668. // The reference operation returns the memory address of the first memory cell of a POINT sized chunk of contiguous memory cells which are allocated to the POINT data attribute named A.
&amp;B = 0x7ffe7c17e670. // The reference operation returns the memory address of the first memory cell of a POINT sized chunk of contiguous memory cells which are allocated to the POINT data attribute named B.
&amp;C = 0x7ffe7c17e678. // The reference operation returns the memory address of the first memory cell of a POINT sized chunk of contiguous memory cells which are allocated to the POINT data attribute named C.
&amp;D = 0x7ffe7c17e680. // The reference operation returns the memory address of the first memory cell of a POINT sized chunk of contiguous memory cells which are allocated to the POINT data attribute named D.
sizeof(int) = 4. // The sizeof() operation returns the nonnegative integer number of bytes of memory which an int type variable occupies. (Each memory cell has a data capacity of 1 byte).
sizeof(int *) = 8. // The sizeof() operation returns the nonnegative integer number of bytes of memory which a pointer-to-int type variable occupies. (Each memory cell has a data capacity of 1 byte).
sizeof(int **) = 8. // The sizeof() operation returns the nonnegative integer number of bytes of memory which an pointer-to-pointer-to-int type variable occupies. (Each memory cell has a data capacity of 1 byte).
sizeof(std::string) = 32. // The sizeof() operation returns the nonnegative integer number of bytes of memory which a string type variable occupies. (Each memory cell has a data capacity of 1 byte).
sizeof(std::string *) = 8. // The sizeof() operation returns the nonnegative integer number of bytes of memory which a pointer-to-string type variable occupies. (Each memory cell has a data capacity of 1 byte).
sizeof(std::string **) = 8. // The sizeof() operation returns the nonnegative integer number of bytes of memory which a pointer-to-pointer-to-string type variable occupies. (Each memory cell has a data capacity of 1 byte).
sizeof(POINT) = 8. // The sizeof() operation returns the nonnegative integer number of bytes of memory which a POINT type object occupies. (Each memory cell has a data capacity of 1 byte).
sizeof(POINT *) = 8. // The sizeof() operation returns the nonnegative integer number of bytes of memory which a pointer-to-POINT type variable occupies. (Each memory cell has a data capacity of 1 byte).
sizeof(POINT **) = 8. // The sizeof() operation returns the nonnegative integer number of bytes of memory which a pointer-to-pointer-to-POINT type variable occupies. (Each memory cell has a data capacity of 1 byte).
sizeof(POLYGON) = 72. // The sizeof() operation returns the nonnegative integer number of bytes of memory which a POLYGON type object occupies. (Each memory cell has a data capacity of 1 byte).
sizeof(POLYGON *) = 8. // The sizeof() operation returns the nonnegative integer number of bytes of memory which a pointer-to-POLYGON type variable occupies. (Each memory cell has a data capacity of 1 byte).
sizeof(POLYGON **) = 8. // The sizeof() operation returns the nonnegative integer number of bytes of memory which a pointer-to-pointer-to-POLYGON type variable occupies. (Each memory cell has a data capacity of 1 byte).
sizeof(QUADRILATERAL) = 136. // The sizeof() operation returns the nonnegative integer number of bytes of memory which a QUADRILATERAL type object occupies. (Each memory cell has a data capacity of 1 byte).
sizeof(QUADRILATERAL *) = 8. // The sizeof() operation returns the nonnegative integer number of bytes of memory which a pointer-to-QUADRILATERAL type variable occupies. (Each memory cell has a data capacity of 1 byte).
sizeof(QUADRILATERAL **) = 8. // The sizeof() operation returns the nonnegative integer number of bytes of memory which a pointer-to-pointer-to-QUADRILATERAL type variable occupies. (Each memory cell has a data capacity of 1 byte).
sizeof(RECTANGLE) = 168. // The sizeof() operation returns the nonnegative integer number of bytes of memory which a RECTANGLE type object occupies. (Each memory cell has a data capacity of 1 byte).
sizeof(RECTANGLE *) = 8. // The sizeof() operation returns the nonnegative integer number of bytes of memory which a pointer-to-RECTANGLE type variable occupies. (Each memory cell has a data capacity of 1 byte).
sizeof(RECTANGLE **) = 8. // The sizeof() operation returns the nonnegative integer number of bytes of memory which a pointer-to-pointer-to-RECTANGLE type variable occupies. (Each memory cell has a data capacity of 1 byte).
sizeof(SQUARE) = 200. // The sizeof() operation returns the nonnegative integer number of bytes of memory which a SQUARE type object occupies. (Each memory cell has a data capacity of 1 byte).
sizeof(SQUARE *) = 8. // The sizeof() operation returns the nonnegative integer number of bytes of memory which a pointer-to-SQUARE type variable occupies. (Each memory cell has a data capacity of 1 byte).
sizeof(SQUARE **) = 8. // The sizeof() operation returns the nonnegative integer number of bytes of memory which a pointer-to-pointer-to-SQUARE type variable occupies. (Each memory cell has a data capacity of 1 byte).
category = POLYGON/QUADRILATERAL/RECTANGLE/SQUARE. // This is an immutable string type value which is a data member of the caller RECTANGLE object.
color = blue. // This is a string type value which is a data member of the caller RECTANGLE object.
A = POINT(0,0). // A represents a point (which is neither B nor C nor D) plotted on a two-dimensional Cartesian grid (such that the X value represents a real whole number position along the horizontal axis of the Cartesian grid while Y represents a real whole number position along the vertical axis of the same Cartesian grid).
B = POINT(0,3). // B represents a point (which is neither A nor C nor D) plotted on a two-dimensional Cartesian grid (such that the X value represents a real whole number position along the horizontal axis of the Cartesian grid while Y represents a real whole number position along the vertical axis of the same Cartesian grid).
C = POINT(4,3). // C represents a point (which is neither A nor B nor D) plotted on a two-dimensional Cartesian grid (such that the X value represents a real whole number position along the horizontal axis of the Cartesian grid while Y represents a real whole number position along the vertical axis of the same Cartesian grid).
D = POINT(4,0). // D represents a point (which is neither A nor B nor C) plotted on a two-dimensional Cartesian grid (such that the X value represents a real whole number position along the horizontal axis of the Cartesian grid while Y represents a real whole number position along the vertical axis of the same Cartesian grid).
a = B.get_distance_from(C) = 4. // The method returns the approximate nonnegative real number of Cartesian grid unit lengths which span the length of the shortest path between points B and C.
b = C.get_distance_from(D) = 3. // The method returns the approximate nonnegative real number of Cartesian grid unit lengths which span the length of the shortest path between points C and D.
c = D.get_distance_from(A) = 4. // The method returns the approximate nonnegative real number of Cartesian grid unit lengths which span the length of the shortest path between points D and A.
d = A.get_distance_from(B) = 3. // The method returns the approximate nonnegative real number of Cartesian grid unit lengths which span the length of the shortest path between points A and B.
A.get_slope_of_line_to(B) = inf. // The method returns the approximate nonnegative real number which represents the slope of the line which intersects points A and B.
B.get_slope_of_line_to(C) = 0. // The method returns the approximate nonnegative real number which represents the slope of the line which intersects points B and C.
C.get_slope_of_line_to(D) = -inf. // The method returns the approximate nonnegative real number which represents the slope of the line which intersects points C and D.
D.get_slope_of_line_to(A) = 0. // The method returns the approximate nonnegative real number which represents the slope of the line which intersects points B and C.
interior_angle_DAB = interior_angle_of_A = 90.00007601981207017161068506538867950439453125. // The value represents the approximate nonnegative real number angle measurement of the acute or else right angle formed by the intersection of the line segment whose endpoints are D and A with the line segment whose endpoints are A and B such that those two line segments intersect at A (and the angle measurement is in degrees and not in radians).
interior_angle_ABC = interior_angle_of_B = 90.00007601981207017161068506538867950439453125. // The method returns the approximate nonnegative real number angle measurement of the acute or else right angle formed by the intersection of the line segment whose endpoints are A and B with the line segment whose endpoints are B and C such that those two line segments intersect at B (and the angle measurement is in degrees and not in radians).
interior_angle_BCD = interior_angle_of_C = 90.00007601981207017161068506538867950439453125. // The method returns the approximate nonnegative real number angle measurement of the acute or else right angle formed by the intersection of the line segment whose endpoints are B and C with the line segment whose endpoints are C and D such that those two line segments intersect at C (and the angle measurement is in degrees and not in radians).
interior_angle_CDA = interior_angle_of_D = 90.00007601981207017161068506538867950439453125. // The method returns the approximate nonnegative real number angle measurement of the acute or else right angle formed by the intersection of the line segment whose endpoints are C and D with the line segment whose endpoints are D and A such that those two line segments intersect at D (and the angle measurement is in degrees and not in radians).
interior_angle_of_A + interior_angle_of_B + interior_angle_of_C + interior_angle_of_D = 360.000304079248280686442740261554718017578125. // sum of all four approximate interior angle measurements of the quadrilateral represented by the caller QUADRILATERAL object (in degrees and not in radians)
get_perimeter() = a + b + c + d = 14. // The method returns the sum of the four approximated side lengths of the rectangle which the caller RECTANGLE object represents.
get_area() = 12. // The method returns the approximate nonnegative real number of Cartesian grid unit squares which are enclosed inside of the two-dimensional region formed by the four line segments which connect points A to B, B to C, C to D, and D to A.
--------------------------------------------------------------------------------------------------

--------------------------------------------------------------------------------------------------
Unit Test # 21: Create a pointer-to-POLYGON type variable to store the memory address of a dynamically allocated TRILATERAL instance. Use that pointer-to-POLYGON type variable to call the print method of the POLYGON class and the getter methods of the POLYGON class.
--------------------------------------------------------------------------------------------------
// COMMENTED OUT: POLYGON polygon; // This command does not work because POLYGON is an abstract class.
POLYGON * pointer_to_polygon; // The pointer-to-POLYGON type variable can store the memory address of an object whose data type is a non-abstract derived class of POLYGON such as TRILATERAL.
pointer_to_polygon = new TRILATERAL; // Assign memory to a dynamic TRILATERAL instance (i.e. and dynamic implies that the variable was created during program runtime instead of program compile time).
pointer_to_polygon -&gt; print(output); // Indirectly call the POLYGON print method.

--------------------------------------------------------------------------------------------------
memory_address = 0x562bfd0084b0.
category = POLYGON.
color = orange.
&amp;category = 0x562bfd0084b8.
&amp;color = 0x562bfd0084d8.
--------------------------------------------------------------------------------------------------
pointer_to_polygon -&gt; get_area() = 6. // Indirectly call the POLYGON get_area() method.
pointer_to_polygon -&gt; get_perimeter() = 12. // Indirectly call the POLYGON get_permieter() method.
delete pointer_to_polygon; // De-allocate memory which was assigned to the dynamically allocated TRILATERAL instance.
--------------------------------------------------------------------------------------------------
--------------------------------------------------------------------------------------------------
Unit Test # 22: Test the default TRILATERAL constructor and the TRILATERAL print method.
--------------------------------------------------------------------------------------------------
TRILATERAL trilateral;
trilateral.print(); // Test the default argument (which is std::cout).
trilateral.print(output);
output &lt; print(output); // Indirectly call the POLYGON print method.

--------------------------------------------------------------------------------------------------
memory_address = 0x562bfd008670.
category = POLYGON.
color = orange.
&amp;category = 0x562bfd008678.
&amp;color = 0x562bfd008698.
--------------------------------------------------------------------------------------------------
pointer_to_polygon -&gt; get_area() = 0.4999999999999997779553950749686919152736663818359375. // Indirectly call the POLYGON get_area() method.
pointer_to_polygon -&gt; get_perimeter() = 3.41421356237309492343001693370752036571502685546875. // Indirectly call the POLYGON get_permieter() method.
delete pointer_to_polygon; // De-allocate memory which was assigned to the dynamically allocated RIGHT_TRILATERAL instance.
--------------------------------------------------------------------------------------------------

--------------------------------------------------------------------------------------------------
Unit Test # 25: Create a pointer-to-TRILATERAL type variable to store the memory address of a dynamically allocated RIGHT_TRILATERAL instance. Use that pointer-to-TRILATERAL type variable to call the print method of the TRILATERAL class and the getter methods of the TRILATERAL class.
--------------------------------------------------------------------------------------------------
TRILATERAL * pointer_to_trilateral; // The pointer-to-TRILATERAL type variable can store the memory address of an object whose data type is a non-abstract derived class of TRILATERAL such as RIGHT_TRILATERAL.
pointer_to_trilateral = new RIGHT_TRILATERAL; // Assign memory to a dynamic RIGHT_TRILATERAL instance (i.e. and dynamic implies that the variable was created during program runtime instead of program compile time).
pointer_to_trilateral -&gt; print(output); // Indirectly call the TRILATERAL print method.

--------------------------------------------------------------------------------------------------
this = 0x562bfd008670. // The keyword named this is a pointer which stores the memory address of the first memory cell of a TRILATERAL sized chunk of contiguous memory cells which are allocated to the caller TRILATERAL object.
&amp;category = 0x562bfd0086b8. // The reference operation returns the memory address of the first memory cell of a string sized chunk of contiguous memory cells which are allocated to the string data attribute named category.
&amp;color = 0x562bfd008698. // The reference operation returns the memory address of the first memory cell of a string sized chunk of contiguous memory cells which are allocated to the string data attribute named color..
&amp;A = 0x562bfd0086d8. // The reference operation returns the memory address of the first memory cell of a POINT sized chunk of contiguous memory cells which are allocated to the POINT data attribute named A.
&amp;B = 0x562bfd0086e0. // The reference operation returns the memory address of the first memory cell of a POINT sized chunk of contiguous memory cells which are allocated to the POINT data attribute named B.
&amp;C = 0x562bfd0086e8. // The reference operation returns the memory address of the first memory cell of a POINT sized chunk of contiguous memory cells which are allocated to the POINT data attribute named C.
sizeof(int) = 4. // The sizeof() operation returns the nonnegative integer number of bytes of memory which an int type variable occupies. (Each memory cell has a data capacity of 1 byte).
sizeof(int *) = 8. // The sizeof() operation returns the nonnegative integer number of bytes of memory which a pointer-to-int type variable occupies. (Each memory cell has a data capacity of 1 byte).
sizeof(int **) = 8. // The sizeof() operation returns the nonnegative integer number of bytes of memory which an pointer-to-pointer-to-int type variable occupies. (Each memory cell has a data capacity of 1 byte).
sizeof(std::string) = 32. // The sizeof() operation returns the nonnegative integer number of bytes of memory which a string type variable occupies. (Each memory cell has a data capacity of 1 byte).
sizeof(std::string *) = 8. // The sizeof() operation returns the nonnegative integer number of bytes of memory which a pointer-to-string type variable occupies. (Each memory cell has a data capacity of 1 byte).
sizeof(std::string **) = 8. // The sizeof() operation returns the nonnegative integer number of bytes of memory which a pointer-to-pointer-to-string type variable occupies. (Each memory cell has a data capacity of 1 byte).
sizeof(POINT) = 8. // The sizeof() operation returns the nonnegative integer number of bytes of memory which a POINT type object occupies. (Each memory cell has a data capacity of 1 byte).
sizeof(POINT *) = 8. // The sizeof() operation returns the nonnegative integer number of bytes of memory which a pointer-to-POINT type variable occupies. (Each memory cell has a data capacity of 1 byte).
sizeof(POINT **) = 8. // The sizeof() operation returns the nonnegative integer number of bytes of memory which a pointer-to-pointer-to-POINT type variable occupies. (Each memory cell has a data capacity of 1 byte).
sizeof(POLYGON) = 72. // The sizeof() operation returns the nonnegative integer number of bytes of memory which a POLYGON type object occupies. (Each memory cell has a data capacity of 1 byte).
sizeof(POLYGON *) = 8. // The sizeof() operation returns the nonnegative integer number of bytes of memory which a pointer-to-POLYGON type variable occupies. (Each memory cell has a data capacity of 1 byte).
sizeof(POLYGON **) = 8. // The sizeof() operation returns the nonnegative integer number of bytes of memory which a pointer-to-pointer-to-POLYGON type variable occupies. (Each memory cell has a data capacity of 1 byte).
sizeof(TRILATERAL) = 128. // The sizeof() operation returns the nonnegative integer number of bytes of memory which a TRILATERAL type object occupies. (Each memory cell has a data capacity of 1 byte).
sizeof(TRILATERAL *) = 8. // The sizeof() operation returns the nonnegative integer number of bytes of memory which a pointer-to-TRILATERAL type variable occupies. (Each memory cell has a data capacity of 1 byte).
sizeof(TRILATERAL **) = 8. // The sizeof() operation returns the nonnegative integer number of bytes of memory which a pointer-to-pointer-to-TRILATERAL type variable occupies. (Each memory cell has a data capacity of 1 byte).
category = POLYGON/TRILATERAL. // This is an immutable string type value which is a data member of the caller TRILATERAL object.
color = orange. // This is a string type value which is a data member of the caller TRILATERAL object.
A = POINT(0,0). // A represents a point (which is neither B nor C nor D) plotted on a two-dimensional Cartesian grid (such that the X value represents a real whole number position along the horizontal axis of the Cartesian grid while Y represents a real whole number position along the vertical axis of the same Cartesian grid).
B = POINT(0,1). // B represents a point (which is neither A nor C nor D) plotted on a two-dimensional Cartesian grid (such that the X value represents a real whole number position along the horizontal axis of the Cartesian grid while Y represents a real whole number position along the vertical axis of the same Cartesian grid).
C = POINT(1,0). // C represents a point (which is neither A nor B nor D) plotted on a two-dimensional Cartesian grid (such that the X value represents a real whole number position along the horizontal axis of the Cartesian grid while Y represents a real whole number position along the vertical axis of the same Cartesian grid).
a = B.get_distance_from(C) = 1.4142135623730951454746218587388284504413604736328125. // The method returns the approximate nonnegative real number of Cartesian grid unit lengths which span the length of the shortest path between points B and C.
b = C.get_distance_from(A) = 1. // The method returns the approximate nonnegative real number of Cartesian grid unit lengths which span the length of the shortest path between points C and A.
c = A.get_distance_from(B) = 1. // The method returns the approximate nonnegative real number of Cartesian grid unit lengths which span the length of the shortest path between points A and B.
slope_of_side_a = B.get_slope_of_line_to(C) = -1. // The method returns the approximate nonnegative real number which represents the slope of the line which intersects points B and C.
slope_of_side_b = C.get_slope_of_line_to(A) = 0. // The method returns the approximate nonnegative real number which represents the slope of the line which intersects points C and A.
slope_of_side_c = A.get_slope_of_line_to(B) = inf. // The method returns the approximate nonnegative real number which represents the slope of the line which intersects points A and B.
interior_angle_of_A = get_interior_angle_CAB() = 90.0000760198120843824654002673923969268798828125. // The value represents the approximate nonnegative real number angle measurement of the acute or else right angle formed by the intersection of the line segment whose endpoints are C and A with the line segment whose endpoints are A and B such that those two line segments intersect at A (and the angle measurement is in degrees and not in radians).
interior_angle_of_B = get_interior_angle_ABC() = 45.0000380099060208749506273306906223297119140625. // The method returns the approximate nonnegative real number angle measurement of the acute or else right angle formed by the intersection of the line segment whose endpoints are A and B with the line segment whose endpoints are B and C such that those two line segments intersect at B (and the angle measurement is in degrees and not in radians).
interior_angle_of_C = get_interior_angle_BCA() = 45.0000380099060208749506273306906223297119140625. // The method returns the approximate nonnegative real number angle measurement of the acute or else right angle formed by the intersection of the line segment whose endpoints are B and C with the line segment whose endpoints are C and A such that those two line segments intersect at C (and the angle measurement is in degrees and not in radians).
interior_angle_of_A + interior_angle_of_B + interior_angle_of_C = 180.0001520396241403432213701307773590087890625. // sum of all three approximate interior angle measurements of the trilateral represented by the caller TRILATERAL object (in degrees and not in radians)
get_perimeter() = a + b + c = 3.41421356237309492343001693370752036571502685546875. // The method returns the sum of the three approximated side lengths of the trilateral which the caller TRILATERAL object represents.
get_area() = 0.4999999999999997779553950749686919152736663818359375. // The method returns the approximate nonnegative real number of Cartesian grid unit squares which are enclosed inside of the two-dimensional region formed by the three line segments which connect points A to B, B to C, and C to A.
--------------------------------------------------------------------------------------------------
pointer_to_trilateral -&gt; get_area() = 0.4999999999999997779553950749686919152736663818359375. // Indirectly call the TRILATERAL get_area() method.
pointer_to_trilateral -&gt; get_perimeter() = 3.41421356237309492343001693370752036571502685546875. // Indirectly call the TRILATERAL get_permieter() method.
delete pointer_to_trilateral; // De-allocate memory which was assigned to the dynamically allocated RIGHT_TRILATERAL instance.
--------------------------------------------------------------------------------------------------
--------------------------------------------------------------------------------------------------
Unit Test # 27: Test the default RIGHT_TRILATERAL constructor and the RIGHT_TRILATERAL print method.
--------------------------------------------------------------------------------------------------
RIGHT_TRILATERAL right_trilateral;
right_trilateral.print(); // Test the default argument (which is std::cout).
right_trilateral.print(output);
output &lt;&lt; right_trilateral; // overloaded ostream operator as defined in right_trilateral.cpp
--------------------------------------------------------------------------------------------------

--------------------------------------------------------------------------------------------------
this = 0x7ffe7c17e620. // The keyword named this is a pointer which stores the memory address of the first memory cell of a RIGHT_TRILATERAL sized chunk of contiguous memory cells which are allocated to the caller RIGHT_TRILATERAL object.
&amp;category = 0x7ffe7c17e6a0. // The reference operation returns the memory address of the first memory cell of a string sized chunk of contiguous memory cells which are allocated to the string data attribute named category.
&amp;color = 0x7ffe7c17e648. // The reference operation returns the memory address of the first memory cell of a string sized chunk of contiguous memory cells which are allocated to the string data attribute named color..
&amp;A = 0x7ffe7c17e688. // The reference operation returns the memory address of the first memory cell of a POINT sized chunk of contiguous memory cells which are allocated to the POINT data attribute named A.
&amp;B = 0x7ffe7c17e690. // The reference operation returns the memory address of the first memory cell of a POINT sized chunk of contiguous memory cells which are allocated to the POINT data attribute named B.
&amp;C = 0x7ffe7c17e698. // The reference operation returns the memory address of the first memory cell of a POINT sized chunk of contiguous memory cells which are allocated to the POINT data attribute named C.
sizeof(int) = 4. // The sizeof() operation returns the nonnegative integer number of bytes of memory which an int type variable occupies. (Each memory cell has a data capacity of 1 byte).
sizeof(int *) = 8. // The sizeof() operation returns the nonnegative integer number of bytes of memory which a pointer-to-int type variable occupies. (Each memory cell has a data capacity of 1 byte).
sizeof(int **) = 8. // The sizeof() operation returns the nonnegative integer number of bytes of memory which an pointer-to-pointer-to-int type variable occupies. (Each memory cell has a data capacity of 1 byte).
sizeof(std::string) = 32. // The sizeof() operation returns the nonnegative integer number of bytes of memory which a string type variable occupies. (Each memory cell has a data capacity of 1 byte).
sizeof(std::string *) = 8. // The sizeof() operation returns the nonnegative integer number of bytes of memory which a pointer-to-string type variable occupies. (Each memory cell has a data capacity of 1 byte).
sizeof(std::string **) = 8. // The sizeof() operation returns the nonnegative integer number of bytes of memory which a pointer-to-pointer-to-string type variable occupies. (Each memory cell has a data capacity of 1 byte).
sizeof(POINT) = 8. // The sizeof() operation returns the nonnegative integer number of bytes of memory which a POINT type object occupies. (Each memory cell has a data capacity of 1 byte).
sizeof(POINT *) = 8. // The sizeof() operation returns the nonnegative integer number of bytes of memory which a pointer-to-POINT type variable occupies. (Each memory cell has a data capacity of 1 byte).
sizeof(POINT **) = 8. // The sizeof() operation returns the nonnegative integer number of bytes of memory which a pointer-to-pointer-to-POINT type variable occupies. (Each memory cell has a data capacity of 1 byte).
sizeof(POLYGON) = 72. // The sizeof() operation returns the nonnegative integer number of bytes of memory which a POLYGON type object occupies. (Each memory cell has a data capacity of 1 byte).
sizeof(POLYGON *) = 8. // The sizeof() operation returns the nonnegative integer number of bytes of memory which a pointer-to-POLYGON type variable occupies. (Each memory cell has a data capacity of 1 byte).
sizeof(POLYGON **) = 8. // The sizeof() operation returns the nonnegative integer number of bytes of memory which a pointer-to-pointer-to-POLYGON type variable occupies. (Each memory cell has a data capacity of 1 byte).
sizeof(TRILATERAL) = 128. // The sizeof() operation returns the nonnegative integer number of bytes of memory which a TRILATERAL type object occupies. (Each memory cell has a data capacity of 1 byte).
sizeof(TRILATERAL *) = 8. // The sizeof() operation returns the nonnegative integer number of bytes of memory which a pointer-to-TRILATERAL type variable occupies. (Each memory cell has a data capacity of 1 byte).
sizeof(TRILATERAL **) = 8. // The sizeof() operation returns the nonnegative integer number of bytes of memory which a pointer-to-pointer-to-TRILATERAL type variable occupies. (Each memory cell has a data capacity of 1 byte).
sizeof(RIGHT_TRILATERAL) = 160. // The sizeof() operation returns the nonnegative integer number of bytes of memory which a RIGHT_TRILATERAL type object occupies. (Each memory cell has a data capacity of 1 byte).
sizeof(RIGHT_TRILATERAL *) = 8. // The sizeof() operation returns the nonnegative integer number of bytes of memory which a pointer-to-RIGHT_TRILATERAL type variable occupies. (Each memory cell has a data capacity of 1 byte).
sizeof(RIGHT_TRILATERAL **) = 8. // The sizeof() operation returns the nonnegative integer number of bytes of memory which a pointer-to-pointer-to-RIGHT_TRILATERAL type variable occupies. (Each memory cell has a data capacity of 1 byte).
category = POLYGON/TRILATERAL/RIGHT_TRILATERAL. // This is an immutable string type value which is a data member of the caller RIGHT_TRILATERAL object.
color = orange. // This is a string type value which is a data member of the caller RIGHT_TRILATERAL object.
A = POINT(0,0). // A represents a point (which is neither B nor C nor D) plotted on a two-dimensional Cartesian grid (such that the X value represents a real whole number position along the horizontal axis of the Cartesian grid while Y represents a real whole number position along the vertical axis of the same Cartesian grid).
B = POINT(0,1). // B represents a point (which is neither A nor C nor D) plotted on a two-dimensional Cartesian grid (such that the X value represents a real whole number position along the horizontal axis of the Cartesian grid while Y represents a real whole number position along the vertical axis of the same Cartesian grid).
C = POINT(1,0). // C represents a point (which is neither A nor B nor D) plotted on a two-dimensional Cartesian grid (such that the X value represents a real whole number position along the horizontal axis of the Cartesian grid while Y represents a real whole number position along the vertical axis of the same Cartesian grid).
a = B.get_distance_from(C) = 1.4142135623730951454746218587388284504413604736328125. // The method returns the approximate nonnegative real number of Cartesian grid unit lengths which span the length of the shortest path between points B and C.
b = C.get_distance_from(A) = 1. // The method returns the approximate nonnegative real number of Cartesian grid unit lengths which span the length of the shortest path between points C and A.
c = A.get_distance_from(B) = 1. // The method returns the approximate nonnegative real number of Cartesian grid unit lengths which span the length of the shortest path between points A and B.
slope_of_side_a = B.get_slope_of_line_to(C) = -1. // The method returns the approximate nonnegative real number which represents the slope of the line which intersects points B and C.
slope_of_side_b = C.get_slope_of_line_to(A) = 0. // The method returns the approximate nonnegative real number which represents the slope of the line which intersects points C and A.
slope_of_side_c = A.get_slope_of_line_to(B) = inf. // The method returns the approximate nonnegative real number which represents the slope of the line which intersects points A and B.
interior_angle_of_A = get_interior_angle_CAB() = 90.0000760198120843824654002673923969268798828125. // The value represents the approximate nonnegative real number angle measurement of the acute or else right angle formed by the intersection of the line segment whose endpoints are C and A with the line segment whose endpoints are A and B such that those two line segments intersect at A (and the angle measurement is in degrees and not in radians).
interior_angle_of_B = get_interior_angle_ABC() = 45.0000380099060208749506273306906223297119140625. // The method returns the approximate nonnegative real number angle measurement of the acute or else right angle formed by the intersection of the line segment whose endpoints are A and B with the line segment whose endpoints are B and C such that those two line segments intersect at B (and the angle measurement is in degrees and not in radians).
interior_angle_of_C = get_interior_angle_BCA() = 45.0000380099060208749506273306906223297119140625. // The method returns the approximate nonnegative real number angle measurement of the acute or else right angle formed by the intersection of the line segment whose endpoints are B and C with the line segment whose endpoints are C and A such that those two line segments intersect at C (and the angle measurement is in degrees and not in radians).
interior_angle_of_A + interior_angle_of_B + interior_angle_of_C = 180.0001520396241403432213701307773590087890625. // sum of all three approximate interior angle measurements of the trilateral represented by the caller TRILATERAL object (in degrees and not in radians)
get_perimeter() = a + b + c = 3.41421356237309492343001693370752036571502685546875. // The method returns the sum of the three approximated side lengths of the trilateral which the caller TRILATERAL object represents.
get_area() = 0.4999999999999997779553950749686919152736663818359375. // The method returns the approximate nonnegative real number of Cartesian grid unit squares which are enclosed inside of the two-dimensional region formed by the three line segments which connect points A to B, B to C, and C to A.
--------------------------------------------------------------------------------------------------

--------------------------------------------------------------------------------------------------
this = 0x7ffe7c17e620. // The keyword named this is a pointer which stores the memory address of the first memory cell of a RIGHT_TRILATERAL sized chunk of contiguous memory cells which are allocated to the caller RIGHT_TRILATERAL object.
&amp;category = 0x7ffe7c17e6a0. // The reference operation returns the memory address of the first memory cell of a string sized chunk of contiguous memory cells which are allocated to the string data attribute named category.
&amp;color = 0x7ffe7c17e648. // The reference operation returns the memory address of the first memory cell of a string sized chunk of contiguous memory cells which are allocated to the string data attribute named color..
&amp;A = 0x7ffe7c17e688. // The reference operation returns the memory address of the first memory cell of a POINT sized chunk of contiguous memory cells which are allocated to the POINT data attribute named A.
&amp;B = 0x7ffe7c17e690. // The reference operation returns the memory address of the first memory cell of a POINT sized chunk of contiguous memory cells which are allocated to the POINT data attribute named B.
&amp;C = 0x7ffe7c17e698. // The reference operation returns the memory address of the first memory cell of a POINT sized chunk of contiguous memory cells which are allocated to the POINT data attribute named C.
sizeof(int) = 4. // The sizeof() operation returns the nonnegative integer number of bytes of memory which an int type variable occupies. (Each memory cell has a data capacity of 1 byte).
sizeof(int *) = 8. // The sizeof() operation returns the nonnegative integer number of bytes of memory which a pointer-to-int type variable occupies. (Each memory cell has a data capacity of 1 byte).
sizeof(int **) = 8. // The sizeof() operation returns the nonnegative integer number of bytes of memory which an pointer-to-pointer-to-int type variable occupies. (Each memory cell has a data capacity of 1 byte).
sizeof(std::string) = 32. // The sizeof() operation returns the nonnegative integer number of bytes of memory which a string type variable occupies. (Each memory cell has a data capacity of 1 byte).
sizeof(std::string *) = 8. // The sizeof() operation returns the nonnegative integer number of bytes of memory which a pointer-to-string type variable occupies. (Each memory cell has a data capacity of 1 byte).
sizeof(std::string **) = 8. // The sizeof() operation returns the nonnegative integer number of bytes of memory which a pointer-to-pointer-to-string type variable occupies. (Each memory cell has a data capacity of 1 byte).
sizeof(POINT) = 8. // The sizeof() operation returns the nonnegative integer number of bytes of memory which a POINT type object occupies. (Each memory cell has a data capacity of 1 byte).
sizeof(POINT *) = 8. // The sizeof() operation returns the nonnegative integer number of bytes of memory which a pointer-to-POINT type variable occupies. (Each memory cell has a data capacity of 1 byte).
sizeof(POINT **) = 8. // The sizeof() operation returns the nonnegative integer number of bytes of memory which a pointer-to-pointer-to-POINT type variable occupies. (Each memory cell has a data capacity of 1 byte).
sizeof(POLYGON) = 72. // The sizeof() operation returns the nonnegative integer number of bytes of memory which a POLYGON type object occupies. (Each memory cell has a data capacity of 1 byte).
sizeof(POLYGON *) = 8. // The sizeof() operation returns the nonnegative integer number of bytes of memory which a pointer-to-POLYGON type variable occupies. (Each memory cell has a data capacity of 1 byte).
sizeof(POLYGON **) = 8. // The sizeof() operation returns the nonnegative integer number of bytes of memory which a pointer-to-pointer-to-POLYGON type variable occupies. (Each memory cell has a data capacity of 1 byte).
sizeof(TRILATERAL) = 128. // The sizeof() operation returns the nonnegative integer number of bytes of memory which a TRILATERAL type object occupies. (Each memory cell has a data capacity of 1 byte).
sizeof(TRILATERAL *) = 8. // The sizeof() operation returns the nonnegative integer number of bytes of memory which a pointer-to-TRILATERAL type variable occupies. (Each memory cell has a data capacity of 1 byte).
sizeof(TRILATERAL **) = 8. // The sizeof() operation returns the nonnegative integer number of bytes of memory which a pointer-to-pointer-to-TRILATERAL type variable occupies. (Each memory cell has a data capacity of 1 byte).
sizeof(RIGHT_TRILATERAL) = 160. // The sizeof() operation returns the nonnegative integer number of bytes of memory which a RIGHT_TRILATERAL type object occupies. (Each memory cell has a data capacity of 1 byte).
sizeof(RIGHT_TRILATERAL *) = 8. // The sizeof() operation returns the nonnegative integer number of bytes of memory which a pointer-to-RIGHT_TRILATERAL type variable occupies. (Each memory cell has a data capacity of 1 byte).
sizeof(RIGHT_TRILATERAL **) = 8. // The sizeof() operation returns the nonnegative integer number of bytes of memory which a pointer-to-pointer-to-RIGHT_TRILATERAL type variable occupies. (Each memory cell has a data capacity of 1 byte).
category = POLYGON/TRILATERAL/RIGHT_TRILATERAL. // This is an immutable string type value which is a data member of the caller RIGHT_TRILATERAL object.
color = orange. // This is a string type value which is a data member of the caller RIGHT_TRILATERAL object.
A = POINT(0,0). // A represents a point (which is neither B nor C nor D) plotted on a two-dimensional Cartesian grid (such that the X value represents a real whole number position along the horizontal axis of the Cartesian grid while Y represents a real whole number position along the vertical axis of the same Cartesian grid).
B = POINT(0,1). // B represents a point (which is neither A nor C nor D) plotted on a two-dimensional Cartesian grid (such that the X value represents a real whole number position along the horizontal axis of the Cartesian grid while Y represents a real whole number position along the vertical axis of the same Cartesian grid).
C = POINT(1,0). // C represents a point (which is neither A nor B nor D) plotted on a two-dimensional Cartesian grid (such that the X value represents a real whole number position along the horizontal axis of the Cartesian grid while Y represents a real whole number position along the vertical axis of the same Cartesian grid).
a = B.get_distance_from(C) = 1.4142135623730951454746218587388284504413604736328125. // The method returns the approximate nonnegative real number of Cartesian grid unit lengths which span the length of the shortest path between points B and C.
b = C.get_distance_from(A) = 1. // The method returns the approximate nonnegative real number of Cartesian grid unit lengths which span the length of the shortest path between points C and A.
c = A.get_distance_from(B) = 1. // The method returns the approximate nonnegative real number of Cartesian grid unit lengths which span the length of the shortest path between points A and B.
slope_of_side_a = B.get_slope_of_line_to(C) = -1. // The method returns the approximate nonnegative real number which represents the slope of the line which intersects points B and C.
slope_of_side_b = C.get_slope_of_line_to(A) = 0. // The method returns the approximate nonnegative real number which represents the slope of the line which intersects points C and A.
slope_of_side_c = A.get_slope_of_line_to(B) = inf. // The method returns the approximate nonnegative real number which represents the slope of the line which intersects points A and B.
interior_angle_of_A = get_interior_angle_CAB() = 90.0000760198120843824654002673923969268798828125. // The value represents the approximate nonnegative real number angle measurement of the acute or else right angle formed by the intersection of the line segment whose endpoints are C and A with the line segment whose endpoints are A and B such that those two line segments intersect at A (and the angle measurement is in degrees and not in radians).
interior_angle_of_B = get_interior_angle_ABC() = 45.0000380099060208749506273306906223297119140625. // The method returns the approximate nonnegative real number angle measurement of the acute or else right angle formed by the intersection of the line segment whose endpoints are A and B with the line segment whose endpoints are B and C such that those two line segments intersect at B (and the angle measurement is in degrees and not in radians).
interior_angle_of_C = get_interior_angle_BCA() = 45.0000380099060208749506273306906223297119140625. // The method returns the approximate nonnegative real number angle measurement of the acute or else right angle formed by the intersection of the line segment whose endpoints are B and C with the line segment whose endpoints are C and A such that those two line segments intersect at C (and the angle measurement is in degrees and not in radians).
interior_angle_of_A + interior_angle_of_B + interior_angle_of_C = 180.0001520396241403432213701307773590087890625. // sum of all three approximate interior angle measurements of the trilateral represented by the caller TRILATERAL object (in degrees and not in radians)
get_perimeter() = a + b + c = 3.41421356237309492343001693370752036571502685546875. // The method returns the sum of the three approximated side lengths of the trilateral which the caller TRILATERAL object represents.
get_area() = 0.4999999999999997779553950749686919152736663818359375. // The method returns the approximate nonnegative real number of Cartesian grid unit squares which are enclosed inside of the two-dimensional region formed by the three line segments which connect points A to B, B to C, and C to A.
--------------------------------------------------------------------------------------------------
--------------------------------------------------------------------------------------------------
Unit Test # 28: Test the normal RIGHT_TRILATERAL constructor and RIGHT_TRILATERAL copy constructor using valid function inputs and the RIGHT_TRILATERAL print method.
--------------------------------------------------------------------------------------------------
RIGHT_TRILATERAL right_trilateral_0 = RIGHT_TRILATERAL(&quot;purple&quot;, POINT(0,0), POINT(0,100), POINT(100,0));
right_trilateral_0.print(output);
RIGHT_TRILATERAL right_trilateral_1 = RIGHT_TRILATERAL(&quot;green&quot;, POINT(-3,0), POINT(0,-4), POINT(0,0);
right_trilateral_1.print(output);
RIGHT_TRILATERAL right_trilateral_2 = RIGHT_TRILATERAL(right_trilateral_0);
right_trilateral_2.print(output);
--------------------------------------------------------------------------------------------------

--------------------------------------------------------------------------------------------------
this = 0x7ffe7c17e4e0. // The keyword named this is a pointer which stores the memory address of the first memory cell of a RIGHT_TRILATERAL sized chunk of contiguous memory cells which are allocated to the caller RIGHT_TRILATERAL object.
&amp;category = 0x7ffe7c17e560. // The reference operation returns the memory address of the first memory cell of a string sized chunk of contiguous memory cells which are allocated to the string data attribute named category.
&amp;color = 0x7ffe7c17e508. // The reference operation returns the memory address of the first memory cell of a string sized chunk of contiguous memory cells which are allocated to the string data attribute named color..
&amp;A = 0x7ffe7c17e548. // The reference operation returns the memory address of the first memory cell of a POINT sized chunk of contiguous memory cells which are allocated to the POINT data attribute named A.
&amp;B = 0x7ffe7c17e550. // The reference operation returns the memory address of the first memory cell of a POINT sized chunk of contiguous memory cells which are allocated to the POINT data attribute named B.
&amp;C = 0x7ffe7c17e558. // The reference operation returns the memory address of the first memory cell of a POINT sized chunk of contiguous memory cells which are allocated to the POINT data attribute named C.
sizeof(int) = 4. // The sizeof() operation returns the nonnegative integer number of bytes of memory which an int type variable occupies. (Each memory cell has a data capacity of 1 byte).
sizeof(int *) = 8. // The sizeof() operation returns the nonnegative integer number of bytes of memory which a pointer-to-int type variable occupies. (Each memory cell has a data capacity of 1 byte).
sizeof(int **) = 8. // The sizeof() operation returns the nonnegative integer number of bytes of memory which an pointer-to-pointer-to-int type variable occupies. (Each memory cell has a data capacity of 1 byte).
sizeof(std::string) = 32. // The sizeof() operation returns the nonnegative integer number of bytes of memory which a string type variable occupies. (Each memory cell has a data capacity of 1 byte).
sizeof(std::string *) = 8. // The sizeof() operation returns the nonnegative integer number of bytes of memory which a pointer-to-string type variable occupies. (Each memory cell has a data capacity of 1 byte).
sizeof(std::string **) = 8. // The sizeof() operation returns the nonnegative integer number of bytes of memory which a pointer-to-pointer-to-string type variable occupies. (Each memory cell has a data capacity of 1 byte).
sizeof(POINT) = 8. // The sizeof() operation returns the nonnegative integer number of bytes of memory which a POINT type object occupies. (Each memory cell has a data capacity of 1 byte).
sizeof(POINT *) = 8. // The sizeof() operation returns the nonnegative integer number of bytes of memory which a pointer-to-POINT type variable occupies. (Each memory cell has a data capacity of 1 byte).
sizeof(POINT **) = 8. // The sizeof() operation returns the nonnegative integer number of bytes of memory which a pointer-to-pointer-to-POINT type variable occupies. (Each memory cell has a data capacity of 1 byte).
sizeof(POLYGON) = 72. // The sizeof() operation returns the nonnegative integer number of bytes of memory which a POLYGON type object occupies. (Each memory cell has a data capacity of 1 byte).
sizeof(POLYGON *) = 8. // The sizeof() operation returns the nonnegative integer number of bytes of memory which a pointer-to-POLYGON type variable occupies. (Each memory cell has a data capacity of 1 byte).
sizeof(POLYGON **) = 8. // The sizeof() operation returns the nonnegative integer number of bytes of memory which a pointer-to-pointer-to-POLYGON type variable occupies. (Each memory cell has a data capacity of 1 byte).
sizeof(TRILATERAL) = 128. // The sizeof() operation returns the nonnegative integer number of bytes of memory which a TRILATERAL type object occupies. (Each memory cell has a data capacity of 1 byte).
sizeof(TRILATERAL *) = 8. // The sizeof() operation returns the nonnegative integer number of bytes of memory which a pointer-to-TRILATERAL type variable occupies. (Each memory cell has a data capacity of 1 byte).
sizeof(TRILATERAL **) = 8. // The sizeof() operation returns the nonnegative integer number of bytes of memory which a pointer-to-pointer-to-TRILATERAL type variable occupies. (Each memory cell has a data capacity of 1 byte).
sizeof(RIGHT_TRILATERAL) = 160. // The sizeof() operation returns the nonnegative integer number of bytes of memory which a RIGHT_TRILATERAL type object occupies. (Each memory cell has a data capacity of 1 byte).
sizeof(RIGHT_TRILATERAL *) = 8. // The sizeof() operation returns the nonnegative integer number of bytes of memory which a pointer-to-RIGHT_TRILATERAL type variable occupies. (Each memory cell has a data capacity of 1 byte).
sizeof(RIGHT_TRILATERAL **) = 8. // The sizeof() operation returns the nonnegative integer number of bytes of memory which a pointer-to-pointer-to-RIGHT_TRILATERAL type variable occupies. (Each memory cell has a data capacity of 1 byte).
category = POLYGON/TRILATERAL/RIGHT_TRILATERAL. // This is an immutable string type value which is a data member of the caller RIGHT_TRILATERAL object.
color = purple. // This is a string type value which is a data member of the caller RIGHT_TRILATERAL object.
A = POINT(0,0). // A represents a point (which is neither B nor C nor D) plotted on a two-dimensional Cartesian grid (such that the X value represents a real whole number position along the horizontal axis of the Cartesian grid while Y represents a real whole number position along the vertical axis of the same Cartesian grid).
B = POINT(0,100). // B represents a point (which is neither A nor C nor D) plotted on a two-dimensional Cartesian grid (such that the X value represents a real whole number position along the horizontal axis of the Cartesian grid while Y represents a real whole number position along the vertical axis of the same Cartesian grid).
C = POINT(100,0). // C represents a point (which is neither A nor B nor D) plotted on a two-dimensional Cartesian grid (such that the X value represents a real whole number position along the horizontal axis of the Cartesian grid while Y represents a real whole number position along the vertical axis of the same Cartesian grid).
a = B.get_distance_from(C) = 141.421356237309510106570087373256683349609375. // The method returns the approximate nonnegative real number of Cartesian grid unit lengths which span the length of the shortest path between points B and C.
b = C.get_distance_from(A) = 100. // The method returns the approximate nonnegative real number of Cartesian grid unit lengths which span the length of the shortest path between points C and A.
c = A.get_distance_from(B) = 100. // The method returns the approximate nonnegative real number of Cartesian grid unit lengths which span the length of the shortest path between points A and B.
slope_of_side_a = B.get_slope_of_line_to(C) = -1. // The method returns the approximate nonnegative real number which represents the slope of the line which intersects points B and C.
slope_of_side_b = C.get_slope_of_line_to(A) = 0. // The method returns the approximate nonnegative real number which represents the slope of the line which intersects points C and A.
slope_of_side_c = A.get_slope_of_line_to(B) = inf. // The method returns the approximate nonnegative real number which represents the slope of the line which intersects points A and B.
interior_angle_of_A = get_interior_angle_CAB() = 90.00007601981207017161068506538867950439453125. // The value represents the approximate nonnegative real number angle measurement of the acute or else right angle formed by the intersection of the line segment whose endpoints are C and A with the line segment whose endpoints are A and B such that those two line segments intersect at A (and the angle measurement is in degrees and not in radians).
interior_angle_of_B = get_interior_angle_ABC() = 45.00003800990604219123270013369619846343994140625. // The method returns the approximate nonnegative real number angle measurement of the acute or else right angle formed by the intersection of the line segment whose endpoints are A and B with the line segment whose endpoints are B and C such that those two line segments intersect at B (and the angle measurement is in degrees and not in radians).
interior_angle_of_C = get_interior_angle_BCA() = 45.00003800990604219123270013369619846343994140625. // The method returns the approximate nonnegative real number angle measurement of the acute or else right angle formed by the intersection of the line segment whose endpoints are B and C with the line segment whose endpoints are C and A such that those two line segments intersect at C (and the angle measurement is in degrees and not in radians).
interior_angle_of_A + interior_angle_of_B + interior_angle_of_C = 180.0001520396241403432213701307773590087890625. // sum of all three approximate interior angle measurements of the trilateral represented by the caller TRILATERAL object (in degrees and not in radians)
get_perimeter() = a + b + c = 341.421356237309510106570087373256683349609375. // The method returns the sum of the three approximated side lengths of the trilateral which the caller TRILATERAL object represents.
get_area() = 5000. // The method returns the approximate nonnegative real number of Cartesian grid unit squares which are enclosed inside of the two-dimensional region formed by the three line segments which connect points A to B, B to C, and C to A.
--------------------------------------------------------------------------------------------------

--------------------------------------------------------------------------------------------------
this = 0x7ffe7c17e580. // The keyword named this is a pointer which stores the memory address of the first memory cell of a RIGHT_TRILATERAL sized chunk of contiguous memory cells which are allocated to the caller RIGHT_TRILATERAL object.
&amp;category = 0x7ffe7c17e600. // The reference operation returns the memory address of the first memory cell of a string sized chunk of contiguous memory cells which are allocated to the string data attribute named category.
&amp;color = 0x7ffe7c17e5a8. // The reference operation returns the memory address of the first memory cell of a string sized chunk of contiguous memory cells which are allocated to the string data attribute named color..
&amp;A = 0x7ffe7c17e5e8. // The reference operation returns the memory address of the first memory cell of a POINT sized chunk of contiguous memory cells which are allocated to the POINT data attribute named A.
&amp;B = 0x7ffe7c17e5f0. // The reference operation returns the memory address of the first memory cell of a POINT sized chunk of contiguous memory cells which are allocated to the POINT data attribute named B.
&amp;C = 0x7ffe7c17e5f8. // The reference operation returns the memory address of the first memory cell of a POINT sized chunk of contiguous memory cells which are allocated to the POINT data attribute named C.
sizeof(int) = 4. // The sizeof() operation returns the nonnegative integer number of bytes of memory which an int type variable occupies. (Each memory cell has a data capacity of 1 byte).
sizeof(int *) = 8. // The sizeof() operation returns the nonnegative integer number of bytes of memory which a pointer-to-int type variable occupies. (Each memory cell has a data capacity of 1 byte).
sizeof(int **) = 8. // The sizeof() operation returns the nonnegative integer number of bytes of memory which an pointer-to-pointer-to-int type variable occupies. (Each memory cell has a data capacity of 1 byte).
sizeof(std::string) = 32. // The sizeof() operation returns the nonnegative integer number of bytes of memory which a string type variable occupies. (Each memory cell has a data capacity of 1 byte).
sizeof(std::string *) = 8. // The sizeof() operation returns the nonnegative integer number of bytes of memory which a pointer-to-string type variable occupies. (Each memory cell has a data capacity of 1 byte).
sizeof(std::string **) = 8. // The sizeof() operation returns the nonnegative integer number of bytes of memory which a pointer-to-pointer-to-string type variable occupies. (Each memory cell has a data capacity of 1 byte).
sizeof(POINT) = 8. // The sizeof() operation returns the nonnegative integer number of bytes of memory which a POINT type object occupies. (Each memory cell has a data capacity of 1 byte).
sizeof(POINT *) = 8. // The sizeof() operation returns the nonnegative integer number of bytes of memory which a pointer-to-POINT type variable occupies. (Each memory cell has a data capacity of 1 byte).
sizeof(POINT **) = 8. // The sizeof() operation returns the nonnegative integer number of bytes of memory which a pointer-to-pointer-to-POINT type variable occupies. (Each memory cell has a data capacity of 1 byte).
sizeof(POLYGON) = 72. // The sizeof() operation returns the nonnegative integer number of bytes of memory which a POLYGON type object occupies. (Each memory cell has a data capacity of 1 byte).
sizeof(POLYGON *) = 8. // The sizeof() operation returns the nonnegative integer number of bytes of memory which a pointer-to-POLYGON type variable occupies. (Each memory cell has a data capacity of 1 byte).
sizeof(POLYGON **) = 8. // The sizeof() operation returns the nonnegative integer number of bytes of memory which a pointer-to-pointer-to-POLYGON type variable occupies. (Each memory cell has a data capacity of 1 byte).
sizeof(TRILATERAL) = 128. // The sizeof() operation returns the nonnegative integer number of bytes of memory which a TRILATERAL type object occupies. (Each memory cell has a data capacity of 1 byte).
sizeof(TRILATERAL *) = 8. // The sizeof() operation returns the nonnegative integer number of bytes of memory which a pointer-to-TRILATERAL type variable occupies. (Each memory cell has a data capacity of 1 byte).
sizeof(TRILATERAL **) = 8. // The sizeof() operation returns the nonnegative integer number of bytes of memory which a pointer-to-pointer-to-TRILATERAL type variable occupies. (Each memory cell has a data capacity of 1 byte).
sizeof(RIGHT_TRILATERAL) = 160. // The sizeof() operation returns the nonnegative integer number of bytes of memory which a RIGHT_TRILATERAL type object occupies. (Each memory cell has a data capacity of 1 byte).
sizeof(RIGHT_TRILATERAL *) = 8. // The sizeof() operation returns the nonnegative integer number of bytes of memory which a pointer-to-RIGHT_TRILATERAL type variable occupies. (Each memory cell has a data capacity of 1 byte).
sizeof(RIGHT_TRILATERAL **) = 8. // The sizeof() operation returns the nonnegative integer number of bytes of memory which a pointer-to-pointer-to-RIGHT_TRILATERAL type variable occupies. (Each memory cell has a data capacity of 1 byte).
category = POLYGON/TRILATERAL/RIGHT_TRILATERAL. // This is an immutable string type value which is a data member of the caller RIGHT_TRILATERAL object.
color = green. // This is a string type value which is a data member of the caller RIGHT_TRILATERAL object.
A = POINT(-3,0). // A represents a point (which is neither B nor C nor D) plotted on a two-dimensional Cartesian grid (such that the X value represents a real whole number position along the horizontal axis of the Cartesian grid while Y represents a real whole number position along the vertical axis of the same Cartesian grid).
B = POINT(0,-4). // B represents a point (which is neither A nor C nor D) plotted on a two-dimensional Cartesian grid (such that the X value represents a real whole number position along the horizontal axis of the Cartesian grid while Y represents a real whole number position along the vertical axis of the same Cartesian grid).
C = POINT(0,0). // C represents a point (which is neither A nor B nor D) plotted on a two-dimensional Cartesian grid (such that the X value represents a real whole number position along the horizontal axis of the Cartesian grid while Y represents a real whole number position along the vertical axis of the same Cartesian grid).
a = B.get_distance_from(C) = 4. // The method returns the approximate nonnegative real number of Cartesian grid unit lengths which span the length of the shortest path between points B and C.
b = C.get_distance_from(A) = 3. // The method returns the approximate nonnegative real number of Cartesian grid unit lengths which span the length of the shortest path between points C and A.
c = A.get_distance_from(B) = 5. // The method returns the approximate nonnegative real number of Cartesian grid unit lengths which span the length of the shortest path between points A and B.
slope_of_side_a = B.get_slope_of_line_to(C) = inf. // The method returns the approximate nonnegative real number which represents the slope of the line which intersects points B and C.
slope_of_side_b = C.get_slope_of_line_to(A) = 0. // The method returns the approximate nonnegative real number which represents the slope of the line which intersects points C and A.
slope_of_side_c = A.get_slope_of_line_to(B) = -1.3333333333333332593184650249895639717578887939453125. // The method returns the approximate nonnegative real number which represents the slope of the line which intersects points A and B.
interior_angle_of_A = get_interior_angle_CAB() = 53.1301472312714935242183855734765529632568359375. // The value represents the approximate nonnegative real number angle measurement of the acute or else right angle formed by the intersection of the line segment whose endpoints are C and A with the line segment whose endpoints are A and B such that those two line segments intersect at A (and the angle measurement is in degrees and not in radians).
interior_angle_of_B = get_interior_angle_ABC() = 36.86992878854056954196494189091026782989501953125. // The method returns the approximate nonnegative real number angle measurement of the acute or else right angle formed by the intersection of the line segment whose endpoints are A and B with the line segment whose endpoints are B and C such that those two line segments intersect at B (and the angle measurement is in degrees and not in radians).
interior_angle_of_C = get_interior_angle_BCA() = 90.00007601981207017161068506538867950439453125. // The method returns the approximate nonnegative real number angle measurement of the acute or else right angle formed by the intersection of the line segment whose endpoints are B and C with the line segment whose endpoints are C and A such that those two line segments intersect at C (and the angle measurement is in degrees and not in radians).
interior_angle_of_A + interior_angle_of_B + interior_angle_of_C = 180.0001520396241403432213701307773590087890625. // sum of all three approximate interior angle measurements of the trilateral represented by the caller TRILATERAL object (in degrees and not in radians)
get_perimeter() = a + b + c = 12. // The method returns the sum of the three approximated side lengths of the trilateral which the caller TRILATERAL object represents.
get_area() = 6. // The method returns the approximate nonnegative real number of Cartesian grid unit squares which are enclosed inside of the two-dimensional region formed by the three line segments which connect points A to B, B to C, and C to A.
--------------------------------------------------------------------------------------------------

--------------------------------------------------------------------------------------------------
this = 0x7ffe7c17e620. // The keyword named this is a pointer which stores the memory address of the first memory cell of a RIGHT_TRILATERAL sized chunk of contiguous memory cells which are allocated to the caller RIGHT_TRILATERAL object.
&amp;category = 0x7ffe7c17e6a0. // The reference operation returns the memory address of the first memory cell of a string sized chunk of contiguous memory cells which are allocated to the string data attribute named category.
&amp;color = 0x7ffe7c17e648. // The reference operation returns the memory address of the first memory cell of a string sized chunk of contiguous memory cells which are allocated to the string data attribute named color..
&amp;A = 0x7ffe7c17e688. // The reference operation returns the memory address of the first memory cell of a POINT sized chunk of contiguous memory cells which are allocated to the POINT data attribute named A.
&amp;B = 0x7ffe7c17e690. // The reference operation returns the memory address of the first memory cell of a POINT sized chunk of contiguous memory cells which are allocated to the POINT data attribute named B.
&amp;C = 0x7ffe7c17e698. // The reference operation returns the memory address of the first memory cell of a POINT sized chunk of contiguous memory cells which are allocated to the POINT data attribute named C.
sizeof(int) = 4. // The sizeof() operation returns the nonnegative integer number of bytes of memory which an int type variable occupies. (Each memory cell has a data capacity of 1 byte).
sizeof(int *) = 8. // The sizeof() operation returns the nonnegative integer number of bytes of memory which a pointer-to-int type variable occupies. (Each memory cell has a data capacity of 1 byte).
sizeof(int **) = 8. // The sizeof() operation returns the nonnegative integer number of bytes of memory which an pointer-to-pointer-to-int type variable occupies. (Each memory cell has a data capacity of 1 byte).
sizeof(std::string) = 32. // The sizeof() operation returns the nonnegative integer number of bytes of memory which a string type variable occupies. (Each memory cell has a data capacity of 1 byte).
sizeof(std::string *) = 8. // The sizeof() operation returns the nonnegative integer number of bytes of memory which a pointer-to-string type variable occupies. (Each memory cell has a data capacity of 1 byte).
sizeof(std::string **) = 8. // The sizeof() operation returns the nonnegative integer number of bytes of memory which a pointer-to-pointer-to-string type variable occupies. (Each memory cell has a data capacity of 1 byte).
sizeof(POINT) = 8. // The sizeof() operation returns the nonnegative integer number of bytes of memory which a POINT type object occupies. (Each memory cell has a data capacity of 1 byte).
sizeof(POINT *) = 8. // The sizeof() operation returns the nonnegative integer number of bytes of memory which a pointer-to-POINT type variable occupies. (Each memory cell has a data capacity of 1 byte).
sizeof(POINT **) = 8. // The sizeof() operation returns the nonnegative integer number of bytes of memory which a pointer-to-pointer-to-POINT type variable occupies. (Each memory cell has a data capacity of 1 byte).
sizeof(POLYGON) = 72. // The sizeof() operation returns the nonnegative integer number of bytes of memory which a POLYGON type object occupies. (Each memory cell has a data capacity of 1 byte).
sizeof(POLYGON *) = 8. // The sizeof() operation returns the nonnegative integer number of bytes of memory which a pointer-to-POLYGON type variable occupies. (Each memory cell has a data capacity of 1 byte).
sizeof(POLYGON **) = 8. // The sizeof() operation returns the nonnegative integer number of bytes of memory which a pointer-to-pointer-to-POLYGON type variable occupies. (Each memory cell has a data capacity of 1 byte).
sizeof(TRILATERAL) = 128. // The sizeof() operation returns the nonnegative integer number of bytes of memory which a TRILATERAL type object occupies. (Each memory cell has a data capacity of 1 byte).
sizeof(TRILATERAL *) = 8. // The sizeof() operation returns the nonnegative integer number of bytes of memory which a pointer-to-TRILATERAL type variable occupies. (Each memory cell has a data capacity of 1 byte).
sizeof(TRILATERAL **) = 8. // The sizeof() operation returns the nonnegative integer number of bytes of memory which a pointer-to-pointer-to-TRILATERAL type variable occupies. (Each memory cell has a data capacity of 1 byte).
sizeof(RIGHT_TRILATERAL) = 160. // The sizeof() operation returns the nonnegative integer number of bytes of memory which a RIGHT_TRILATERAL type object occupies. (Each memory cell has a data capacity of 1 byte).
sizeof(RIGHT_TRILATERAL *) = 8. // The sizeof() operation returns the nonnegative integer number of bytes of memory which a pointer-to-RIGHT_TRILATERAL type variable occupies. (Each memory cell has a data capacity of 1 byte).
sizeof(RIGHT_TRILATERAL **) = 8. // The sizeof() operation returns the nonnegative integer number of bytes of memory which a pointer-to-pointer-to-RIGHT_TRILATERAL type variable occupies. (Each memory cell has a data capacity of 1 byte).
category = POLYGON/TRILATERAL/RIGHT_TRILATERAL. // This is an immutable string type value which is a data member of the caller RIGHT_TRILATERAL object.
color = purple. // This is a string type value which is a data member of the caller RIGHT_TRILATERAL object.
A = POINT(0,0). // A represents a point (which is neither B nor C nor D) plotted on a two-dimensional Cartesian grid (such that the X value represents a real whole number position along the horizontal axis of the Cartesian grid while Y represents a real whole number position along the vertical axis of the same Cartesian grid).
B = POINT(0,100). // B represents a point (which is neither A nor C nor D) plotted on a two-dimensional Cartesian grid (such that the X value represents a real whole number position along the horizontal axis of the Cartesian grid while Y represents a real whole number position along the vertical axis of the same Cartesian grid).
C = POINT(100,0). // C represents a point (which is neither A nor B nor D) plotted on a two-dimensional Cartesian grid (such that the X value represents a real whole number position along the horizontal axis of the Cartesian grid while Y represents a real whole number position along the vertical axis of the same Cartesian grid).
a = B.get_distance_from(C) = 141.421356237309510106570087373256683349609375. // The method returns the approximate nonnegative real number of Cartesian grid unit lengths which span the length of the shortest path between points B and C.
b = C.get_distance_from(A) = 100. // The method returns the approximate nonnegative real number of Cartesian grid unit lengths which span the length of the shortest path between points C and A.
c = A.get_distance_from(B) = 100. // The method returns the approximate nonnegative real number of Cartesian grid unit lengths which span the length of the shortest path between points A and B.
slope_of_side_a = B.get_slope_of_line_to(C) = -1. // The method returns the approximate nonnegative real number which represents the slope of the line which intersects points B and C.
slope_of_side_b = C.get_slope_of_line_to(A) = 0. // The method returns the approximate nonnegative real number which represents the slope of the line which intersects points C and A.
slope_of_side_c = A.get_slope_of_line_to(B) = inf. // The method returns the approximate nonnegative real number which represents the slope of the line which intersects points A and B.
interior_angle_of_A = get_interior_angle_CAB() = 90.00007601981207017161068506538867950439453125. // The value represents the approximate nonnegative real number angle measurement of the acute or else right angle formed by the intersection of the line segment whose endpoints are C and A with the line segment whose endpoints are A and B such that those two line segments intersect at A (and the angle measurement is in degrees and not in radians).
interior_angle_of_B = get_interior_angle_ABC() = 45.00003800990604219123270013369619846343994140625. // The method returns the approximate nonnegative real number angle measurement of the acute or else right angle formed by the intersection of the line segment whose endpoints are A and B with the line segment whose endpoints are B and C such that those two line segments intersect at B (and the angle measurement is in degrees and not in radians).
interior_angle_of_C = get_interior_angle_BCA() = 45.00003800990604219123270013369619846343994140625. // The method returns the approximate nonnegative real number angle measurement of the acute or else right angle formed by the intersection of the line segment whose endpoints are B and C with the line segment whose endpoints are C and A such that those two line segments intersect at C (and the angle measurement is in degrees and not in radians).
interior_angle_of_A + interior_angle_of_B + interior_angle_of_C = 180.0001520396241403432213701307773590087890625. // sum of all three approximate interior angle measurements of the trilateral represented by the caller TRILATERAL object (in degrees and not in radians)
get_perimeter() = a + b + c = 341.421356237309510106570087373256683349609375. // The method returns the sum of the three approximated side lengths of the trilateral which the caller TRILATERAL object represents.
get_area() = 5000. // The method returns the approximate nonnegative real number of Cartesian grid unit squares which are enclosed inside of the two-dimensional region formed by the three line segments which connect points A to B, B to C, and C to A.
--------------------------------------------------------------------------------------------------
--------------------------------------------------------------------------------------------------
Unit Test # 29: Test the normal RIGHT_TRILATERAL constructor using invalid function inputs and the RIGHT_TRILATERAL print method.
--------------------------------------------------------------------------------------------------
RIGHT_TRILATERAL right_trilateral_0 = RIGHT_TRILATERAL(&quot;red&quot;, POINT(-2,-2), POINT(0,0), POINT(4,4));
right_trilateral_0.print(output);
RIGHT_TRILATERAL right_trilateral_1 = RIGHT_TRILATERAL(&quot;green&quot;, POINT(0,0), POINT(4,5), POINT(9,-3));
right_trilateral_1.print(output);
RIGHT_TRILATERAL right_trilateral_2 = RIGHT_TRILATERAL(&quot;blue&quot;, POINT(0,0), POINT(4,5), POINT(0,0));
right_trilateral_2.print(output);
--------------------------------------------------------------------------------------------------

--------------------------------------------------------------------------------------------------
this = 0x7ffe7c17e4e0. // The keyword named this is a pointer which stores the memory address of the first memory cell of a RIGHT_TRILATERAL sized chunk of contiguous memory cells which are allocated to the caller RIGHT_TRILATERAL object.
&amp;category = 0x7ffe7c17e560. // The reference operation returns the memory address of the first memory cell of a string sized chunk of contiguous memory cells which are allocated to the string data attribute named category.
&amp;color = 0x7ffe7c17e508. // The reference operation returns the memory address of the first memory cell of a string sized chunk of contiguous memory cells which are allocated to the string data attribute named color..
&amp;A = 0x7ffe7c17e548. // The reference operation returns the memory address of the first memory cell of a POINT sized chunk of contiguous memory cells which are allocated to the POINT data attribute named A.
&amp;B = 0x7ffe7c17e550. // The reference operation returns the memory address of the first memory cell of a POINT sized chunk of contiguous memory cells which are allocated to the POINT data attribute named B.
&amp;C = 0x7ffe7c17e558. // The reference operation returns the memory address of the first memory cell of a POINT sized chunk of contiguous memory cells which are allocated to the POINT data attribute named C.
sizeof(int) = 4. // The sizeof() operation returns the nonnegative integer number of bytes of memory which an int type variable occupies. (Each memory cell has a data capacity of 1 byte).
sizeof(int *) = 8. // The sizeof() operation returns the nonnegative integer number of bytes of memory which a pointer-to-int type variable occupies. (Each memory cell has a data capacity of 1 byte).
sizeof(int **) = 8. // The sizeof() operation returns the nonnegative integer number of bytes of memory which an pointer-to-pointer-to-int type variable occupies. (Each memory cell has a data capacity of 1 byte).
sizeof(std::string) = 32. // The sizeof() operation returns the nonnegative integer number of bytes of memory which a string type variable occupies. (Each memory cell has a data capacity of 1 byte).
sizeof(std::string *) = 8. // The sizeof() operation returns the nonnegative integer number of bytes of memory which a pointer-to-string type variable occupies. (Each memory cell has a data capacity of 1 byte).
sizeof(std::string **) = 8. // The sizeof() operation returns the nonnegative integer number of bytes of memory which a pointer-to-pointer-to-string type variable occupies. (Each memory cell has a data capacity of 1 byte).
sizeof(POINT) = 8. // The sizeof() operation returns the nonnegative integer number of bytes of memory which a POINT type object occupies. (Each memory cell has a data capacity of 1 byte).
sizeof(POINT *) = 8. // The sizeof() operation returns the nonnegative integer number of bytes of memory which a pointer-to-POINT type variable occupies. (Each memory cell has a data capacity of 1 byte).
sizeof(POINT **) = 8. // The sizeof() operation returns the nonnegative integer number of bytes of memory which a pointer-to-pointer-to-POINT type variable occupies. (Each memory cell has a data capacity of 1 byte).
sizeof(POLYGON) = 72. // The sizeof() operation returns the nonnegative integer number of bytes of memory which a POLYGON type object occupies. (Each memory cell has a data capacity of 1 byte).
sizeof(POLYGON *) = 8. // The sizeof() operation returns the nonnegative integer number of bytes of memory which a pointer-to-POLYGON type variable occupies. (Each memory cell has a data capacity of 1 byte).
sizeof(POLYGON **) = 8. // The sizeof() operation returns the nonnegative integer number of bytes of memory which a pointer-to-pointer-to-POLYGON type variable occupies. (Each memory cell has a data capacity of 1 byte).
sizeof(TRILATERAL) = 128. // The sizeof() operation returns the nonnegative integer number of bytes of memory which a TRILATERAL type object occupies. (Each memory cell has a data capacity of 1 byte).
sizeof(TRILATERAL *) = 8. // The sizeof() operation returns the nonnegative integer number of bytes of memory which a pointer-to-TRILATERAL type variable occupies. (Each memory cell has a data capacity of 1 byte).
sizeof(TRILATERAL **) = 8. // The sizeof() operation returns the nonnegative integer number of bytes of memory which a pointer-to-pointer-to-TRILATERAL type variable occupies. (Each memory cell has a data capacity of 1 byte).
sizeof(RIGHT_TRILATERAL) = 160. // The sizeof() operation returns the nonnegative integer number of bytes of memory which a RIGHT_TRILATERAL type object occupies. (Each memory cell has a data capacity of 1 byte).
sizeof(RIGHT_TRILATERAL *) = 8. // The sizeof() operation returns the nonnegative integer number of bytes of memory which a pointer-to-RIGHT_TRILATERAL type variable occupies. (Each memory cell has a data capacity of 1 byte).
sizeof(RIGHT_TRILATERAL **) = 8. // The sizeof() operation returns the nonnegative integer number of bytes of memory which a pointer-to-pointer-to-RIGHT_TRILATERAL type variable occupies. (Each memory cell has a data capacity of 1 byte).
category = POLYGON/TRILATERAL/RIGHT_TRILATERAL. // This is an immutable string type value which is a data member of the caller RIGHT_TRILATERAL object.
color = red. // This is a string type value which is a data member of the caller RIGHT_TRILATERAL object.
A = POINT(0,0). // A represents a point (which is neither B nor C nor D) plotted on a two-dimensional Cartesian grid (such that the X value represents a real whole number position along the horizontal axis of the Cartesian grid while Y represents a real whole number position along the vertical axis of the same Cartesian grid).
B = POINT(0,1). // B represents a point (which is neither A nor C nor D) plotted on a two-dimensional Cartesian grid (such that the X value represents a real whole number position along the horizontal axis of the Cartesian grid while Y represents a real whole number position along the vertical axis of the same Cartesian grid).
C = POINT(1,0). // C represents a point (which is neither A nor B nor D) plotted on a two-dimensional Cartesian grid (such that the X value represents a real whole number position along the horizontal axis of the Cartesian grid while Y represents a real whole number position along the vertical axis of the same Cartesian grid).
a = B.get_distance_from(C) = 1.4142135623730951454746218587388284504413604736328125. // The method returns the approximate nonnegative real number of Cartesian grid unit lengths which span the length of the shortest path between points B and C.
b = C.get_distance_from(A) = 1. // The method returns the approximate nonnegative real number of Cartesian grid unit lengths which span the length of the shortest path between points C and A.
c = A.get_distance_from(B) = 1. // The method returns the approximate nonnegative real number of Cartesian grid unit lengths which span the length of the shortest path between points A and B.
slope_of_side_a = B.get_slope_of_line_to(C) = -1. // The method returns the approximate nonnegative real number which represents the slope of the line which intersects points B and C.
slope_of_side_b = C.get_slope_of_line_to(A) = 0. // The method returns the approximate nonnegative real number which represents the slope of the line which intersects points C and A.
slope_of_side_c = A.get_slope_of_line_to(B) = inf. // The method returns the approximate nonnegative real number which represents the slope of the line which intersects points A and B.
interior_angle_of_A = get_interior_angle_CAB() = 90.0000760198120843824654002673923969268798828125. // The value represents the approximate nonnegative real number angle measurement of the acute or else right angle formed by the intersection of the line segment whose endpoints are C and A with the line segment whose endpoints are A and B such that those two line segments intersect at A (and the angle measurement is in degrees and not in radians).
interior_angle_of_B = get_interior_angle_ABC() = 45.0000380099060208749506273306906223297119140625. // The method returns the approximate nonnegative real number angle measurement of the acute or else right angle formed by the intersection of the line segment whose endpoints are A and B with the line segment whose endpoints are B and C such that those two line segments intersect at B (and the angle measurement is in degrees and not in radians).
interior_angle_of_C = get_interior_angle_BCA() = 45.0000380099060208749506273306906223297119140625. // The method returns the approximate nonnegative real number angle measurement of the acute or else right angle formed by the intersection of the line segment whose endpoints are B and C with the line segment whose endpoints are C and A such that those two line segments intersect at C (and the angle measurement is in degrees and not in radians).
interior_angle_of_A + interior_angle_of_B + interior_angle_of_C = 180.0001520396241403432213701307773590087890625. // sum of all three approximate interior angle measurements of the trilateral represented by the caller TRILATERAL object (in degrees and not in radians)
get_perimeter() = a + b + c = 3.41421356237309492343001693370752036571502685546875. // The method returns the sum of the three approximated side lengths of the trilateral which the caller TRILATERAL object represents.
get_area() = 0.4999999999999997779553950749686919152736663818359375. // The method returns the approximate nonnegative real number of Cartesian grid unit squares which are enclosed inside of the two-dimensional region formed by the three line segments which connect points A to B, B to C, and C to A.
--------------------------------------------------------------------------------------------------

--------------------------------------------------------------------------------------------------
this = 0x7ffe7c17e580. // The keyword named this is a pointer which stores the memory address of the first memory cell of a RIGHT_TRILATERAL sized chunk of contiguous memory cells which are allocated to the caller RIGHT_TRILATERAL object.
&amp;category = 0x7ffe7c17e600. // The reference operation returns the memory address of the first memory cell of a string sized chunk of contiguous memory cells which are allocated to the string data attribute named category.
&amp;color = 0x7ffe7c17e5a8. // The reference operation returns the memory address of the first memory cell of a string sized chunk of contiguous memory cells which are allocated to the string data attribute named color..
&amp;A = 0x7ffe7c17e5e8. // The reference operation returns the memory address of the first memory cell of a POINT sized chunk of contiguous memory cells which are allocated to the POINT data attribute named A.
&amp;B = 0x7ffe7c17e5f0. // The reference operation returns the memory address of the first memory cell of a POINT sized chunk of contiguous memory cells which are allocated to the POINT data attribute named B.
&amp;C = 0x7ffe7c17e5f8. // The reference operation returns the memory address of the first memory cell of a POINT sized chunk of contiguous memory cells which are allocated to the POINT data attribute named C.
sizeof(int) = 4. // The sizeof() operation returns the nonnegative integer number of bytes of memory which an int type variable occupies. (Each memory cell has a data capacity of 1 byte).
sizeof(int *) = 8. // The sizeof() operation returns the nonnegative integer number of bytes of memory which a pointer-to-int type variable occupies. (Each memory cell has a data capacity of 1 byte).
sizeof(int **) = 8. // The sizeof() operation returns the nonnegative integer number of bytes of memory which an pointer-to-pointer-to-int type variable occupies. (Each memory cell has a data capacity of 1 byte).
sizeof(std::string) = 32. // The sizeof() operation returns the nonnegative integer number of bytes of memory which a string type variable occupies. (Each memory cell has a data capacity of 1 byte).
sizeof(std::string *) = 8. // The sizeof() operation returns the nonnegative integer number of bytes of memory which a pointer-to-string type variable occupies. (Each memory cell has a data capacity of 1 byte).
sizeof(std::string **) = 8. // The sizeof() operation returns the nonnegative integer number of bytes of memory which a pointer-to-pointer-to-string type variable occupies. (Each memory cell has a data capacity of 1 byte).
sizeof(POINT) = 8. // The sizeof() operation returns the nonnegative integer number of bytes of memory which a POINT type object occupies. (Each memory cell has a data capacity of 1 byte).
sizeof(POINT *) = 8. // The sizeof() operation returns the nonnegative integer number of bytes of memory which a pointer-to-POINT type variable occupies. (Each memory cell has a data capacity of 1 byte).
sizeof(POINT **) = 8. // The sizeof() operation returns the nonnegative integer number of bytes of memory which a pointer-to-pointer-to-POINT type variable occupies. (Each memory cell has a data capacity of 1 byte).
sizeof(POLYGON) = 72. // The sizeof() operation returns the nonnegative integer number of bytes of memory which a POLYGON type object occupies. (Each memory cell has a data capacity of 1 byte).
sizeof(POLYGON *) = 8. // The sizeof() operation returns the nonnegative integer number of bytes of memory which a pointer-to-POLYGON type variable occupies. (Each memory cell has a data capacity of 1 byte).
sizeof(POLYGON **) = 8. // The sizeof() operation returns the nonnegative integer number of bytes of memory which a pointer-to-pointer-to-POLYGON type variable occupies. (Each memory cell has a data capacity of 1 byte).
sizeof(TRILATERAL) = 128. // The sizeof() operation returns the nonnegative integer number of bytes of memory which a TRILATERAL type object occupies. (Each memory cell has a data capacity of 1 byte).
sizeof(TRILATERAL *) = 8. // The sizeof() operation returns the nonnegative integer number of bytes of memory which a pointer-to-TRILATERAL type variable occupies. (Each memory cell has a data capacity of 1 byte).
sizeof(TRILATERAL **) = 8. // The sizeof() operation returns the nonnegative integer number of bytes of memory which a pointer-to-pointer-to-TRILATERAL type variable occupies. (Each memory cell has a data capacity of 1 byte).
sizeof(RIGHT_TRILATERAL) = 160. // The sizeof() operation returns the nonnegative integer number of bytes of memory which a RIGHT_TRILATERAL type object occupies. (Each memory cell has a data capacity of 1 byte).
sizeof(RIGHT_TRILATERAL *) = 8. // The sizeof() operation returns the nonnegative integer number of bytes of memory which a pointer-to-RIGHT_TRILATERAL type variable occupies. (Each memory cell has a data capacity of 1 byte).
sizeof(RIGHT_TRILATERAL **) = 8. // The sizeof() operation returns the nonnegative integer number of bytes of memory which a pointer-to-pointer-to-RIGHT_TRILATERAL type variable occupies. (Each memory cell has a data capacity of 1 byte).
category = POLYGON/TRILATERAL/RIGHT_TRILATERAL. // This is an immutable string type value which is a data member of the caller RIGHT_TRILATERAL object.
color = green. // This is a string type value which is a data member of the caller RIGHT_TRILATERAL object.
A = POINT(0,0). // A represents a point (which is neither B nor C nor D) plotted on a two-dimensional Cartesian grid (such that the X value represents a real whole number position along the horizontal axis of the Cartesian grid while Y represents a real whole number position along the vertical axis of the same Cartesian grid).
B = POINT(0,1). // B represents a point (which is neither A nor C nor D) plotted on a two-dimensional Cartesian grid (such that the X value represents a real whole number position along the horizontal axis of the Cartesian grid while Y represents a real whole number position along the vertical axis of the same Cartesian grid).
C = POINT(1,0). // C represents a point (which is neither A nor B nor D) plotted on a two-dimensional Cartesian grid (such that the X value represents a real whole number position along the horizontal axis of the Cartesian grid while Y represents a real whole number position along the vertical axis of the same Cartesian grid).
a = B.get_distance_from(C) = 1.4142135623730951454746218587388284504413604736328125. // The method returns the approximate nonnegative real number of Cartesian grid unit lengths which span the length of the shortest path between points B and C.
b = C.get_distance_from(A) = 1. // The method returns the approximate nonnegative real number of Cartesian grid unit lengths which span the length of the shortest path between points C and A.
c = A.get_distance_from(B) = 1. // The method returns the approximate nonnegative real number of Cartesian grid unit lengths which span the length of the shortest path between points A and B.
slope_of_side_a = B.get_slope_of_line_to(C) = -1. // The method returns the approximate nonnegative real number which represents the slope of the line which intersects points B and C.
slope_of_side_b = C.get_slope_of_line_to(A) = 0. // The method returns the approximate nonnegative real number which represents the slope of the line which intersects points C and A.
slope_of_side_c = A.get_slope_of_line_to(B) = inf. // The method returns the approximate nonnegative real number which represents the slope of the line which intersects points A and B.
interior_angle_of_A = get_interior_angle_CAB() = 90.0000760198120843824654002673923969268798828125. // The value represents the approximate nonnegative real number angle measurement of the acute or else right angle formed by the intersection of the line segment whose endpoints are C and A with the line segment whose endpoints are A and B such that those two line segments intersect at A (and the angle measurement is in degrees and not in radians).
interior_angle_of_B = get_interior_angle_ABC() = 45.0000380099060208749506273306906223297119140625. // The method returns the approximate nonnegative real number angle measurement of the acute or else right angle formed by the intersection of the line segment whose endpoints are A and B with the line segment whose endpoints are B and C such that those two line segments intersect at B (and the angle measurement is in degrees and not in radians).
interior_angle_of_C = get_interior_angle_BCA() = 45.0000380099060208749506273306906223297119140625. // The method returns the approximate nonnegative real number angle measurement of the acute or else right angle formed by the intersection of the line segment whose endpoints are B and C with the line segment whose endpoints are C and A such that those two line segments intersect at C (and the angle measurement is in degrees and not in radians).
interior_angle_of_A + interior_angle_of_B + interior_angle_of_C = 180.0001520396241403432213701307773590087890625. // sum of all three approximate interior angle measurements of the trilateral represented by the caller TRILATERAL object (in degrees and not in radians)
get_perimeter() = a + b + c = 3.41421356237309492343001693370752036571502685546875. // The method returns the sum of the three approximated side lengths of the trilateral which the caller TRILATERAL object represents.
get_area() = 0.4999999999999997779553950749686919152736663818359375. // The method returns the approximate nonnegative real number of Cartesian grid unit squares which are enclosed inside of the two-dimensional region formed by the three line segments which connect points A to B, B to C, and C to A.
--------------------------------------------------------------------------------------------------

--------------------------------------------------------------------------------------------------
this = 0x7ffe7c17e620. // The keyword named this is a pointer which stores the memory address of the first memory cell of a RIGHT_TRILATERAL sized chunk of contiguous memory cells which are allocated to the caller RIGHT_TRILATERAL object.
&amp;category = 0x7ffe7c17e6a0. // The reference operation returns the memory address of the first memory cell of a string sized chunk of contiguous memory cells which are allocated to the string data attribute named category.
&amp;color = 0x7ffe7c17e648. // The reference operation returns the memory address of the first memory cell of a string sized chunk of contiguous memory cells which are allocated to the string data attribute named color..
&amp;A = 0x7ffe7c17e688. // The reference operation returns the memory address of the first memory cell of a POINT sized chunk of contiguous memory cells which are allocated to the POINT data attribute named A.
&amp;B = 0x7ffe7c17e690. // The reference operation returns the memory address of the first memory cell of a POINT sized chunk of contiguous memory cells which are allocated to the POINT data attribute named B.
&amp;C = 0x7ffe7c17e698. // The reference operation returns the memory address of the first memory cell of a POINT sized chunk of contiguous memory cells which are allocated to the POINT data attribute named C.
sizeof(int) = 4. // The sizeof() operation returns the nonnegative integer number of bytes of memory which an int type variable occupies. (Each memory cell has a data capacity of 1 byte).
sizeof(int *) = 8. // The sizeof() operation returns the nonnegative integer number of bytes of memory which a pointer-to-int type variable occupies. (Each memory cell has a data capacity of 1 byte).
sizeof(int **) = 8. // The sizeof() operation returns the nonnegative integer number of bytes of memory which an pointer-to-pointer-to-int type variable occupies. (Each memory cell has a data capacity of 1 byte).
sizeof(std::string) = 32. // The sizeof() operation returns the nonnegative integer number of bytes of memory which a string type variable occupies. (Each memory cell has a data capacity of 1 byte).
sizeof(std::string *) = 8. // The sizeof() operation returns the nonnegative integer number of bytes of memory which a pointer-to-string type variable occupies. (Each memory cell has a data capacity of 1 byte).
sizeof(std::string **) = 8. // The sizeof() operation returns the nonnegative integer number of bytes of memory which a pointer-to-pointer-to-string type variable occupies. (Each memory cell has a data capacity of 1 byte).
sizeof(POINT) = 8. // The sizeof() operation returns the nonnegative integer number of bytes of memory which a POINT type object occupies. (Each memory cell has a data capacity of 1 byte).
sizeof(POINT *) = 8. // The sizeof() operation returns the nonnegative integer number of bytes of memory which a pointer-to-POINT type variable occupies. (Each memory cell has a data capacity of 1 byte).
sizeof(POINT **) = 8. // The sizeof() operation returns the nonnegative integer number of bytes of memory which a pointer-to-pointer-to-POINT type variable occupies. (Each memory cell has a data capacity of 1 byte).
sizeof(POLYGON) = 72. // The sizeof() operation returns the nonnegative integer number of bytes of memory which a POLYGON type object occupies. (Each memory cell has a data capacity of 1 byte).
sizeof(POLYGON *) = 8. // The sizeof() operation returns the nonnegative integer number of bytes of memory which a pointer-to-POLYGON type variable occupies. (Each memory cell has a data capacity of 1 byte).
sizeof(POLYGON **) = 8. // The sizeof() operation returns the nonnegative integer number of bytes of memory which a pointer-to-pointer-to-POLYGON type variable occupies. (Each memory cell has a data capacity of 1 byte).
sizeof(TRILATERAL) = 128. // The sizeof() operation returns the nonnegative integer number of bytes of memory which a TRILATERAL type object occupies. (Each memory cell has a data capacity of 1 byte).
sizeof(TRILATERAL *) = 8. // The sizeof() operation returns the nonnegative integer number of bytes of memory which a pointer-to-TRILATERAL type variable occupies. (Each memory cell has a data capacity of 1 byte).
sizeof(TRILATERAL **) = 8. // The sizeof() operation returns the nonnegative integer number of bytes of memory which a pointer-to-pointer-to-TRILATERAL type variable occupies. (Each memory cell has a data capacity of 1 byte).
sizeof(RIGHT_TRILATERAL) = 160. // The sizeof() operation returns the nonnegative integer number of bytes of memory which a RIGHT_TRILATERAL type object occupies. (Each memory cell has a data capacity of 1 byte).
sizeof(RIGHT_TRILATERAL *) = 8. // The sizeof() operation returns the nonnegative integer number of bytes of memory which a pointer-to-RIGHT_TRILATERAL type variable occupies. (Each memory cell has a data capacity of 1 byte).
sizeof(RIGHT_TRILATERAL **) = 8. // The sizeof() operation returns the nonnegative integer number of bytes of memory which a pointer-to-pointer-to-RIGHT_TRILATERAL type variable occupies. (Each memory cell has a data capacity of 1 byte).
category = POLYGON/TRILATERAL/RIGHT_TRILATERAL. // This is an immutable string type value which is a data member of the caller RIGHT_TRILATERAL object.
color = blue. // This is a string type value which is a data member of the caller RIGHT_TRILATERAL object.
A = POINT(0,0). // A represents a point (which is neither B nor C nor D) plotted on a two-dimensional Cartesian grid (such that the X value represents a real whole number position along the horizontal axis of the Cartesian grid while Y represents a real whole number position along the vertical axis of the same Cartesian grid).
B = POINT(0,1). // B represents a point (which is neither A nor C nor D) plotted on a two-dimensional Cartesian grid (such that the X value represents a real whole number position along the horizontal axis of the Cartesian grid while Y represents a real whole number position along the vertical axis of the same Cartesian grid).
C = POINT(1,0). // C represents a point (which is neither A nor B nor D) plotted on a two-dimensional Cartesian grid (such that the X value represents a real whole number position along the horizontal axis of the Cartesian grid while Y represents a real whole number position along the vertical axis of the same Cartesian grid).
a = B.get_distance_from(C) = 1.4142135623730951454746218587388284504413604736328125. // The method returns the approximate nonnegative real number of Cartesian grid unit lengths which span the length of the shortest path between points B and C.
b = C.get_distance_from(A) = 1. // The method returns the approximate nonnegative real number of Cartesian grid unit lengths which span the length of the shortest path between points C and A.
c = A.get_distance_from(B) = 1. // The method returns the approximate nonnegative real number of Cartesian grid unit lengths which span the length of the shortest path between points A and B.
slope_of_side_a = B.get_slope_of_line_to(C) = -1. // The method returns the approximate nonnegative real number which represents the slope of the line which intersects points B and C.
slope_of_side_b = C.get_slope_of_line_to(A) = 0. // The method returns the approximate nonnegative real number which represents the slope of the line which intersects points C and A.
slope_of_side_c = A.get_slope_of_line_to(B) = inf. // The method returns the approximate nonnegative real number which represents the slope of the line which intersects points A and B.
interior_angle_of_A = get_interior_angle_CAB() = 90.0000760198120843824654002673923969268798828125. // The value represents the approximate nonnegative real number angle measurement of the acute or else right angle formed by the intersection of the line segment whose endpoints are C and A with the line segment whose endpoints are A and B such that those two line segments intersect at A (and the angle measurement is in degrees and not in radians).
interior_angle_of_B = get_interior_angle_ABC() = 45.0000380099060208749506273306906223297119140625. // The method returns the approximate nonnegative real number angle measurement of the acute or else right angle formed by the intersection of the line segment whose endpoints are A and B with the line segment whose endpoints are B and C such that those two line segments intersect at B (and the angle measurement is in degrees and not in radians).
interior_angle_of_C = get_interior_angle_BCA() = 45.0000380099060208749506273306906223297119140625. // The method returns the approximate nonnegative real number angle measurement of the acute or else right angle formed by the intersection of the line segment whose endpoints are B and C with the line segment whose endpoints are C and A such that those two line segments intersect at C (and the angle measurement is in degrees and not in radians).
interior_angle_of_A + interior_angle_of_B + interior_angle_of_C = 180.0001520396241403432213701307773590087890625. // sum of all three approximate interior angle measurements of the trilateral represented by the caller TRILATERAL object (in degrees and not in radians)
get_perimeter() = a + b + c = 3.41421356237309492343001693370752036571502685546875. // The method returns the sum of the three approximated side lengths of the trilateral which the caller TRILATERAL object represents.
get_area() = 0.4999999999999997779553950749686919152736663818359375. // The method returns the approximate nonnegative real number of Cartesian grid unit squares which are enclosed inside of the two-dimensional region formed by the three line segments which connect points A to B, B to C, and C to A.
--------------------------------------------------------------------------------------------------

--------------------------------
End Of Program
--------------------------------</pre>
<hr />
<p>This web page was last updated on 29_AUGUST_2024. The content displayed on this web page is licensed as <a style="background: #000000;color: #ff9000" href="https://karlinaobject.wordpress.com/public_domain/" target="_blank" rel="noopener">PUBLIC_DOMAIN</a> intellectual property.</p>
<hr />
